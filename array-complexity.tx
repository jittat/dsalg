\chapter{อาร์เรย์ พอยน์เตอร์ และการวิเคราะห์ความซับซ้อน}

ในบทนี้เราจะพิจารณาโครงสร้างข้อมูลพื้นฐานสำหรับจัดเก็บและประมวลผลข้อมูลจำนวนมากที่เรียกว่า{\em
อาร์เรย์} (array) รวมไปถึงข้อมูลประเภท{\em พอยน์เตอร์} (pointer)
ซึ่งเก็บตำแหน่งภายในหน่วยความจำ
โดยเราจะเริ่มพิจารณาแนวคิดของโครงสร้างข้อมูลและชนิดข้อมูลดังกล่าวโดยไม่ขึ้นกับภาษาโปรแกรมที่ใช้
จากนั้นเราจะศึกษาวิธีการเขียนในภาษา C/C++
และศึกษาความสัมพันธ์ระหว่างพอยน์เตอร์และอาร์เรย์ซึ่งเป็นคุณลักษณะเฉพาะที่มีในภาษา C/C++

ในขณะเดียวกัน เราจะเริ่มศึกษาการวิเคราะห์อัลกอริทึม โดยจะเริ่มที่{\em
  การวิเคราะห์ความซับซ้อน} (complexity analysis) และ{\em
  การวิเคราะห์เชิงเส้นกำกับ} (asymptotic analysis) โดยใช้สัญกรณ์โอใหญ่ (Big-O
notation)

\section{อาร์เรย์}
อาร์เรย์เป็นโครงสร้างข้อมูลที่เก็บกลุ่มของข้อมูลเป็นรายการ
โดยที่ข้อมูลแต่ละตัวจะถูกเก็บต่อเนื่องกันในหน่วยความจำ และถูกอ้างถึงโดยใช้ดัชนี (index)
ตัวอย่างง่าย ๆ ของอาร์เรย์คือรายการข้อมูลด้านล่างนี้

\begin{center}
2, 3, 5, 7, 11, 13, 17, 19, 23
\end{center}

ถ้าเราเรียกรายการดังกล่าวว่ารายการ $A$ และอ้างถึงข้อมูลแต่ละตัวด้วยดัชนีที่เริ่มต้นด้วย 0
ข้อมูลแต่ละตัวในรายการจะถูกอ้างถึงได้ดังตารางในรูปที่~\ref{fig:array-array-access}

\begin{figure}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
$A[0]$ & $A[1]$ & $A[2]$ & $A[3]$ & $A[4]$ & $A[5]$ & $A[6]$ & $A[7]$ & $A[8]$ \\
\hline
2 & 3 & 5 & 7 & 11 & 13 & 17 & 19 & 23\\
\hline
\end{tabular}
\end{center}
\caption{การอ้างถึงข้อมูลแต่ละตัวในอาร์เรย์ $A$}
\label{fig:array-array-access}
\end{figure}


---q การคำนวณค่า
จงหาผลลัพธ์ของนิพจน์เหล่านี้ (1) $A[4]$, (2) $A[7]$, (3) $A[A[0]]$, (4) $A[A[A[0]]]$, (5) $A[200]$
===
(1) 11, (2) 19, (3) 5, (4) 13, (5) ไม่มีค่า (ดูอธิบายเพิ่มเติม)
---

การหาคำตอบของคำถามที่ (3) นั้น จำเป็นต้องเข้าใจขั้นตอนการคำนวณค่าของนิพจน์
เราต้องการหาค่า $A[A[0]]$ ดังนั้นเราต้องหาค่า $A[0]$ ก่อน
เมื่อพิจารณาในอาร์เรย์เราพบว่า $A[0]$ คือ $2$ ดังนั้น จากนั้นเราจึงพิจารณาข้อมูล
$A[2]$ ในอารเรย์ ซึ่งจะได้ค่า $5$

ในการทำงานจริง อาร์เรย์จะเก็บในหน่วยความจำที่ต่อเนื่องกัน
และมักจะมีขอบเขตที่จำกัดและต้องระบุเมื่อเริ่มใช้ เช่น อาร์เรย์จำนวน 100 ช่อง หรือ
100000 ช่องเป็นต้น รูปที่~\ref{fig:array-array-in-mem}
แสดงตัวอย่างของการเก็บข้อมูลของอาร์เรย์ในหน่วยความจำ

\begin{figure}
TODO: ใส่รูป
\caption{การเก็บข้อมูลของอาร์เรย์ในหน่วยความจำ}
\label{fig:array-array-in-mem}
\end{figure}

คำถามที่ (5) เป็นการอ้างถึงข้อมูลที่อยู่นอกขอบเขตของอาร์เรย์
ซึ่งผลลัพธ์ที่ได้จะขึ้นกับภาษาโปรแกรมที่ใช้ สำหรับภาษา C หรือ C++
ผลลัพธ์ที่ได้จะขึ้นกับข้อมูลในหน่วยความจำในตำแหน่งที่ $A[200]$ ควรจะอยู่
เราจะได้ศึกษารายละเอียดนี้ต่อไป อย่างไรก็ตาม ปกติแล้ว ในการใช้งานอาร์เรย์
เราจะไม่อ้างถึงข้อมูลที่อยู่นอกขอบเขตของอาร์เรย์

การระบุดัชนีของข้อมูลในอาร์เรย์ในหนังสือเล่มนี้จะอ้างอิงจากภาษาตระกูลภาษา C
นั่นคือเริ่มต้นที่ 0 \ \ สำหรับบางภาษา เราสามารถระบุค่าเริ่มต้นของดัชนีได้และมักเริ่มที่ 1
เช่นภาษาปาสคาล (Pascal) เป็นต้น
อย่างไรก็ตามแนวคิดในการพัฒนาโปรแกรมนั้นจะไม่ต่างกัน

เมื่อเราสามารถอ้างถึงข้อมูลได้ด้วยดัชนี
เราสามารถใช้ตัวแปรเพื่อแทนค่าดัชนีของข้อมูลที่เราต้องการใช้งานได้
ความสามารถนี้ทำให้เราสามารถเขียนโปรแกรมที่มีลักษณะดังด้านล่างได้

---algt *
* ให้ $x\leftarrow 0$
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,8$
** ให้ $x \leftarrow x + A[i]$
---

---q *
อัลกอริทึมดังกล่าวคำนวณค่าบางอย่างในตัวแปร $x$ ค่านั้นคืออะไร?
===
ผลรวมของข้อมูลทั้งหมดในอาร์เรย์ $A$
---

สังเกตว่าอัลกอริทึมข้างต้นเขียนให้ทำงานกับอาร์เรย์ $A$ ที่มีดัชนีมากที่สุดคือ 8 เท่านั้น
ในการพัฒนาอัลกอริทึมทั่วไปเรามักเขียนให้ทำงานได้กับข้อมูลทั่วไป ซึ่งในกรณีนี้
การจะปรับให้ทำงานได้กับอาร์เรย์ใด ๆ เราจะต้องระบุขนาดของอาร์เรย์ด้วย
เราสามารถเขียนอัลกอริทึมดังกล่าวโดยระบุพารามิเตอร์ให้ชัดเจนขึ้นได้ดังด้านล่าง

---algt คำนวณค่าบางอย่างของอาร์เรย์ $A$ ที่มีข้อมูลจำนวน $n$ ตัว
* ให้ $x\leftarrow 0$
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,n-1$
** ให้ $x \leftarrow x + A[i]$
* คืนค่า $x$ เป็นคำตอบ
---

\subsection{เวลาที่ใช้ในการทำงาน}

ค่าพารามิเตอร์ $n$ ที่เราส่งให้กับโปรแกรมย่อย ระบุจำนวนรอบของการทำงาน
ซึ่งจะเป็นตัวกำหนดเวลาที่โปรแกรมย่อยใช้ในการทำงานด้วย อย่างไรก็ตาม
เพียงแค่พิจารณาโปรแกรมย่อยดังกล่าว เราไม่สามารถระบุเวลาจริง ๆ
ที่โปรแกรมย่อยจะทำงานได้เนื่องจากเราไม่ทราบปัจจัยหลาย ๆ อย่าง

---q เวลาการทำงานจริงบนคอมพิวเตอร์
ปัจจัยอะไรบ้างที่กำหนดเวลาทำงานบนคอมพิวเตอร์จริง ๆ ของโปรแกรมย่อยข้างต้น
===
เวลาในการทำงานจริง ขึ้นกับ (1) โปรแกรมภาษาคอมพิวเตอร์ที่เขียนจากโปรแกรมย่อย (2)
คอมไพเลอร์ที่ใช้ (3) เครื่องคอมพิวเตอร์ที่นำโปรแกรมไปทำงาน
และสถานะของเครื่องในขณะที่โปรแกรมทำงาน  
---

สังเกตว่าการพิจารณาแค่อัลกอริทึมเพียงอย่างเดียว
หรือกระทั่งจะพิจารณาโปรแกรมในภาษาเครื่องที่ถูกคอมไพล์แล้วร่วมด้วย
ก็ไม่สามารถทำให้เราระบุเวลาการทำงานบนคอมพิวเตอร์จริงได้อย่างแม่นยำ
ยิ่งในปัจจุบันที่คอมพิวเตอร์สามารถทำงานหลาย ๆ งานในเวลาเดียวกัน
การทำนายเวลาการทำงานจริงยิ่งกระทำได้ยากขึ้นด้วย

อย่างไรก็ตาม แม้การระบุเวลาการทำงานจริง ๆ ทำได้ยาก
การทำนายเวลาการทำงานของอัลกอริทึมก่อนที่จะนำไปพัฒนาเป็นโปรแกรมก็ยังเป็นสิ่งจำเป็นมาก
เนื่องจากในหลาย ๆ เราสามารถเลือกใช้อัลกอริทึมได้หลากหลาย
และอัลกอริทึมเหล่านั้นก็มีความซับซ้อนในการนำไปพัฒนาเป็นโปรแกรมที่แตกต่างกัน
โปรแกรมเมอร์จึงต้องเลือกใช้อัลกอริทึมให้เหมาะสม นั่นคือเป็นอัลกอริทึมที่เมื่อนำไปพัฒนาแล้ว
มีประสิทธิภาพพอ (ทำงานได้ทันเวลา)
และมีความซับซ้อนในการเขียนในระดับที่โปรแกรมเมอร์สามารถจัดการได้
การเลือกนำอัลกอริทึมที่ทราบว่ามีประสิทธิภาพดีที่สุดไปพัฒนานั้น
อาจไม่ใช่ทางเลือกที่ดีที่สุดก็เป็นได้

ดังนั้น เราจะพยายามวิเคราะห์เวลาการทำงานของโปรแกรมย่อย
ที่อยู่ในรูปของโปรแกรมลำลองด้านบน ให้ละเอียดเท่าที่เราพอจะทำได้
แน่นอนเราจำเป็นต้องเพิ่มข้อสมมติหลายอย่างเพื่อให้การวิเคราะห์เป็นไปได้

ข้อสมมติข้อแรก (ที่เราจะใช้ตลอดในหนังสือเล่มนี้) คือ
เราจะสมมติว่าคอมพิวเตอร์นั้นทำงานทีละคำสั่ง นั่นคือไม่ใช่คอมพิวเตอร์แบบขนาน
หรือเป็นคอมพิวเตอร์ที่มีหน่วยประมวลผลหลายตัวทำงานพร้อมกัน\footnote{TODO:
  ระบุว่าถึงจะเป็นกรณีดังกล่าว การวิเคราะห์ก็ยังเป็นไปได้}

ถ้าพิจารณาต่อไป
เราจะพบว่าโปรแกรมดังกล่าวทำงานจะใช้เวลาในการทำงานที่แปรผันตามค่าพารามิเตอร์ $n$
เพื่อจะให้เราสามารถวิเคราะห์เวลาการทำงานออกมาได้
เราจะสมมติว่าคอมพิวเตอร์เมื่อทำงานตามโปรแกรมดังกล่าว ใช้เวลา 1
หน่วยในการประมวลผลคำสั่งแต่ละบรรทัด
เราจะสามารถคำนวณเวลาที่โปรแกรมดังกล่าวใช้โดยพิจารณาจำนวนครั้งที่คำสั่งในแต่ละบรรทัดทำงาน
ดังด้านล่าง

---algt *
* ให้ $x\leftarrow 0$   \ \ \ \ $\rhd\rhd\rhd$ ทำงาน 1 ครั้ง
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,n-1$  \ \ \ \ $\rhd\rhd\rhd$ ทำงาน $n$ ครั้ง
** ให้ $x \leftarrow x + A[i]$  \ \ \ \ $\rhd\rhd\rhd$ ทำงาน $n$ ครั้ง
* คืนค่า $x$ เป็นคำตอบ  \ \ \ \ $\rhd\rhd\rhd$ ทำงาน 1 ครั้ง
---

ดังนั้นเราจะได้ว่าเวลารวมคือ $2n + 2$ หน่วย คำถามที่ตามมาก็คือ
ผลลัพธ์จากการวิเคราะห์ดังกล่าวมีความแม่นยำ และสามารถนำไปใช้พิจารณาต่อไปได้เพียงใด

TODO: อธิบายและยกตัวอย่างถึงความจำเป็นของ asymptotic analysis

\subsection{การประมวลผลรายการด้วยอาร์เรย์}

ในส่วนนี้เราจะพัฒนาโปรแกรมลำลองเพื่อประมวลผลข้อมูลในรายการที่เก็บในอาร์เรย์
พร้อมกับวิเคราะห์เวลาการทำงาน

---q *
สมมติว่าเรามีรายการของข้อมูล ลองนึกตัวอย่างการประมวลผลที่เราสามารถกระทำกับข้อมูลในรายการนี้
---

ก่อนที่เราจะประมวลผลได้ เราต้องพิจารณาวิธีการจัดเก็บข้อมูลแบบรายการลงในอาร์เรย์ก่อน
สังเกตว่าโครงสร้างข้อมูลแบบอาร์เรย์มีลักษณะเป็นรายการอยู่แล้ว
อย่างไรก็ตามในการจัดการกับรายการที่มีจำนวนข้อมูลเปลี่ยนแปลงได้
การใช้อาร์เรย์เพียงอย่างเดียวนั้นไม่เพียงพอ

---q *
อะไรคือสิ่งที่ขาดหายไป ถ้าเราใช้แค่อาร์เรย์ในการจัดเก็บรายการที่จำนวนข้อมูลในรายการเปลี่ยนแปลงได้
---

ดังนั้น เราจะใช้ตัวแปรอีกหนึ่งตัวในการเก็บจำนวนข้อมูลที่มีในอาร์เรย์
โปรแกรมลำลองที่เราจะพัฒนาจะเปลี่ยนค่าของตัวแปรนี้โดยตรงเพื่อปรับให้มีค่าที่ถูกต้องภายหลังการประมวลผล
ในการพัฒนาโปรแกรมลำลองให้เป็นโปรแกรมภาษา C/C++
การทำงานดังกล่าวจะต้องใช้การส่งรับพารามิเตอร์เป็นพอยน์เตอร์หรือส่งแบบ pass by
reference ซึ่งเราจะได้พิจารณาในส่วน~\ref{sect:array-pointer-c}
นอกจากนี้ในบทที่~\ref{chapter:class} เราจะได้ศึกษาวิธีการที่จะ ``ประกอบรวม''
อาร์เรย์และตัวแปรที่เก็บจำนวนข้อมูลที่อยู่ในอาร์เรย์เข้าด้วยกัน
เพื่อสร้างเป็นชนิดข้อมูลใหม่ที่นำไปใช้งานได้สะดวกต่อไป

เราจะพิจารณาการประมวลผลกับอาร์เรย์ในรูปแบบต่าง ๆ ดังนี้ (1) การค้นข้อมูลในรายการ, (2) การเพิ่มข้อมูลลงไปตอนท้ายของรายการ, (3) การลบข้อมูลในรายการ, และ (4) การแทรกข้อมูลในรายการ

\subsubsection{การค้นข้อมูล} 
สำหรับการค้นข้อมูลในรายการ
เป้าหมายของการทำงานคือทราบว่ามีข้อมูลที่เราต้องการหาหรือไม่ และถ้ามีอยู่ที่ตำแหน่งใด
ในกรณีนี้เราจะต้องพิจารณาข้อมูลทุกตัวในรายการ
โปรแกรมลำลองมีลักษณะไม่ต่างจากที่เราเคยเขียนเท่าใดนัก

---algt ค้นหาข้อมูล $x$ ในอาร์เรย์ $A$ ที่มีข้อมูลจำนวน $n$ ตัว
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots, n-1$
** ถ้า $A[i] = x$
*** คืนค่า $i$ เป็นผลลัพธ์
* ตอบว่าไม่พบค่าที่ต้องการ
---

ในการพัฒนาโปรแกรมจริง ๆ
เราจะต้องจัดการในกรณีที่จะต้องตอบว่าไม่พบค่าที่ต้องการให้ชัดเจนกว่านี้
แต่ในขณะนี้เราจะสมมติว่าโปรแกรมย่อยสามารถตอบแบบนี้ได้

---q *
ในกรณีของโปรแกรมย่อยสำหรับหาผลรวม เราพบว่าโปรแกรมทำงานในเวลาที่แปรผันกับค่า $n$
เสมอ เป็นไปได้หรือไม่ ที่โปรแกรมย่อยสำหรับจะทำงานโดยวนรอบเป็นจำนวนครั้งที่น้อยกว่าค่า $n$ มาก? และเป็นในกรณีใด?
---

---q *
สำหรับอาร์เรย์ที่มีข้อมูล $n$ ตัว เมื่อใดที่โปรแกรมย่อยจะทำงานโดยวนรอบมากที่สุด
---

โปรแกรมย่อยข้างต้นอาจจะทำงานได้รวดเร็วมาก ถ้าข้อมูลที่ต้องการค้นหาอยู่ตอนต้นของอาร์เรย์
โปรแกรมย่อยลักษณะนี้เป็นตัวอย่างที่ดีของโปรแกรมย่อยที่เวลาการทำงานขึ้นกับข้อมูลป้อนเข้า
ทำให้ในการวิเคราะห์เวลาการทำงานนั้น เราจำเป็นจะต้องพิจารณาข้อมูลป้อนเข้าด้วย
อย่างไรก็ตามเราไม่สามารถที่จะวิเคราะห์เวลาการทำงานของโปรแกรมลำลองบนข้อมูลป้อนเข้าทุกรูปแบบได้
เพราะว่าจำนวนของข้อมูลป้อนเข้านั้นมีไม่จำกัด

ในทางปฏิบัติแล้ว เราจึงจะแบ่งวิเคราะห์เวลาการทำงานเป็นกรณีย่อย ๆ สามกรณีคือ
\begin{itemize}
\item การวิเคราะห์ในกรณีที่ดีที่สุด (best-case analysis),
\item การวิเคราะห์ในกรณีที่เลวร้ายที่สุด (worst-case analysis), และ
\item การวิเคราะห์ในกรณีเฉลี่ย (average-case analysis)
\end{itemize}

สำหรับการวิเคราะห์ในกรณีเฉลี่ยนั้น เป็นการวิเคราะห์เชิงความน่าจะเป็น
เราจำเป็นจะต้องนิยามลักษณะการกระจายของข้อมูลป้อนเข้าให้ชัดเจน จึงจะสามารถกระทำได้
เราจะได้ศึกษาตัวอย่างการวิเคราะห์นี้ในบทที่~\ref{chapter:randomization}
ในที่นี้เราจะสนใจเฉพาะการวิเคราะห์กรณีที่ดีที่สุด และการวิเคราะห์ในกรณีที่เลวร้ายที่สุด

กรณีที่ดีที่สุดคือกรณีที่มีการวนรอบเพียงรอบเดียว นั้นคือเป็นกรณีที่ $A[0] = x$
สังเกตว่าถ้าเราสมมติให้การประมวลผลแต่ละบรรทัดใช้เวลา 1 หน่วย ในกรณีที่ดีที่สุด
โปรแกรมลำลองดังกล่าวจะใช้เวลาทำงาน $4$ หน่วย

กรณีที่เลวร้ายที่สุดเกิดขึ้นเมื่อไม่พบข้อมูลที่ต้องการหา
สังเกตว่าโปรแกรมจะทำงานวนอยู่ที่สองบรรทัดแรกเป็นจำนวน $n$ ครั้ง และคืนคำตอบ
ดังนั้นโปรแกรมจะใช้เวลาทำงาน $2n + 1$ หน่วย

\subsubsection{การเพิ่มข้อมูลลงไปท้ายรายการ}

เราจะเพิ่มข้อมูลลงไปตอนท้ายของอาร์เรย์
นั่นคือใส่ข้อมูลในอาร์เรย์ที่มีดัชนีมากกว่าดัชนีตัวสุดท้าย
โปรแกรมลำลองที่น่าจะทำงานได้เขียนดังนี้

---algt เพิ่มข้อมูล $x$ ในตอนท้ายอาร์เรย์ $A$ ที่มีข้อมูล $n$ ตัว
* $A[n] \leftarrow x$
* $n \leftarrow n + 1$
---

อย่างไรก็ตาม ในการนำไปใช้จริง โปรแกรมลำลองดังกล่าวอาจจะทำให้เกิดข้อผิดพลาดขึ้นระหว่างการทำงานได้

---q *
กรณีใดที่โปรแกรมลำลองข้างต้นอาจทำให้เกิดข้อผิดพลาดขึ้นระหว่างการทำงาน
===
จากที่เราได้เคยเกริ่นบ้างแล้วว่า ในการใช้งานอาร์เรย์
โดยมากจะต้องระบุขอบเขตหรือจำนวนข้อมูลมากที่สุดที่เก็บในอาร์เรย์ได้
ในกรณีของโปรแกรมลำลองนี้ถ้าเราเรียกใช้เมื่อ $n$
มีขนาดมากกว่าหรือเท่ากับจำนวนข้อมูลที่อาร์เรย์เก็บได้ คำสั่ง $A[n]\leftarrow x$
ก็อาจจะเขียนข้อมูลลงในหน่วยความจำบริเวณที่อยู่นอกขอบเขตของอาร์เรย์ $A$ ได้
---

ดังนั้นเพื่อความไม่ประมาท
โปรแกรมย่อยควรจะต้องตรวจสอบขนาดของอาร์เรย์เพื่อป้องกันความผิดพลาดนี้ด้วย
ในการเขียนต่อไปเราจะให้ $MAXLEN$ เป็นค่าคงที่แทนขนาดมากที่สุดของอาร์เรย์ $A$
เราปรับแก้โปรแกรมย่อยได้ดังด้านล่าง

---algt เพิ่มข้อมูล $x$ ในตอนท้ายอาร์เรย์ $A$ ที่มีข้อมูล $n$ ตัว (แก้ไข)
* ถ้า $n < MAXLEN$ แล้ว
** $A[n] \leftarrow x$
** $n \leftarrow n + 1$
* ไม่เช่นนั้น
** รายงานว่าไม่สามารถเพิ่มข้อมูลได้
---

โปรแกรมย่อยนี้ ในการวิเคราะห์เวลาการทำงานมีสองกรณีให้เราพิจารณา สังเกตว่า
จะใช้เวลาในการทำงานไม่เกิน $3$ หน่วยไม่ว่าในกรณีใด 

ในกรณีแรก (กรณีที่ $n<MAXLEN$) โปรแกรมย่อยจะใช้เวลาการทำงาน $3$ หน่วย
และในอีกกรณีจะใช้เวลาการทำงาน $2$ หน่วย อย่างไรก็ตาม
ผู้อ่านอย่าเพิ่งรีบสรุปว่ากรณีแรกทำงานจริง ๆ ได้เร็วกว่า เพราะว่าความแตกต่างนี้จริง ๆ
แล้วเกิดจากข้อสมมติว่าการทำงานในทุกคำสั่งมีความเร็วเท่ากันคือ 1 หน่วย
ดังนั้นประเด็นสำคัญของการวิเคราะห์นี้คือโปรแกรมย่อยนี้ทำงานในเวลาที่ไม่ขึ้นกับค่า $n$


\subsubsection{การลบข้อมูลในรายการและการแทรกข้อมูลในรายการ}

\section{พอยน์เตอร์}

การเก็บข้อมูลในหน่วยความจำคอมพิวเตอร์

\section{การวิเคราะห์เชิงเส้นกำกับ}

\section{การประกาศและใช้งานอาร์เรย์ในภาษา C/C++}

ในภาษา C หรือ C++ เราสามารถประกาศตัวแปรประเภทอาร์เรย์ได้โดยใช้รูปแบบดังนี้

\begin{center}
ชนิดข้อมูล ชื่อตัวแปร[ขนาด];
\end{center}

ตัวอย่างด้านล่างแสดงการประกาศตัวแปรอาร์เรย์ของจำนวนเต็ม ({\ttt int})
และอาร์เรย์ของอักขระ ({\ttt char})

---src[cpp]
int a[100];
char buf[1000];
---

\section{อาร์เรย์และพอยน์เตอร์ในภาษา C/C++}
\label{sect:array-pointer-c}
