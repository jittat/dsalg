\chapter{การ{\wbr}ซ่อน{\wbr}รายละเอียด: ค{\wbr}ลา{\wbr}ส{\wbr}และ{\wbr}เท็ม{\wbr}เพล{\wbr}ต}

ใน{\wbr}บท{\wbr}นี้{\wbr}เรา{\wbr}จะ{\wbr}ศึกษา{\wbr}เครื่องมือ{\wbr}ของ{\wbr}ภาษา C++ ที่{\wbr}เรา{\wbr}จะ{\wbr}ใช้{\wbr}พัฒนา{\wbr}โครงสร้าง{\wbr}ข้อมูล{\wbr}
เรา{\wbr}จะ{\wbr}ศึกษา{\wbr}บาง{\wbr}ส่วน{\wbr}ของ{\wbr}แนว{\wbr}คิด{\wbr}การ{\wbr}โปรแกรม{\wbr}เชิง{\wbr}วัตถุ (object-oriented programming)
และ{\wbr}การ{\wbr}โปรแกรม{\wbr}เชิง{\wbr}เจน{\wbr}เน{\wbr}อริ{\wbr}ก (generic programming)
ผ่าน{\wbr}ทางการ{\wbr}ปรับปรุง{\wbr}โครงสร้าง{\wbr}ข้อมูล{\wbr}สำหรับ{\wbr}จัด{\wbr}เก็บ{\wbr}รายการ{\wbr}ด้วย{\wbr}อาร์เรย์{\wbr}ที่{\wbr}เรา{\wbr}ได้{\wbr}อิม{\wbr}พลี{\wbr}เมนท์{\wbr}ใน{\wbr}บท{\wbr}ก่อน ๆ

เป้าหมาย{\wbr}ของ{\wbr}เนื้อหา{\wbr}ใน{\wbr}บท{\wbr}นี้{\wbr}เพื่อที่จะ{\wbr}ปู{\wbr}พื้นฐาน{\wbr}ภาษา C++
ให้{\wbr}กับ{\wbr}ผู้อ่าน{\wbr}ให้{\wbr}มาก{\wbr}พอ{\wbr}ที่{\wbr}จะ{\wbr}ศึกษา{\wbr}การ{\wbr}เขียน{\wbr}โครงสร้าง{\wbr}ข้อมูล{\wbr}ใน{\wbr}บท{\wbr}ต่อ ๆ ไป{\wbr}ได้{\wbr}เท่านั้น{\wbr}
ดังนั้น{\wbr}รายละเอียด{\wbr}หลาย ๆ อย่าง{\wbr}ของ{\wbr}การ{\wbr}เขียน{\wbr}จะ{\wbr}ถูก{\wbr}ละ{\wbr}ไว้{\wbr}หรือ{\wbr}เอ่ยถึง{\wbr}คร่าว ๆ
\ ผู้อ่าน{\wbr}ที่{\wbr}สนใจ{\wbr}จึง{\wbr}ควร{\wbr}หา{\wbr}แหล่ง{\wbr}อ้างอิง{\wbr}เพิ่มเติม{\wbr}ด้วย{\wbr}

\section{การ{\wbr}รวม{\wbr}กลุ่ม{\wbr}ข้อมูล{\wbr}และ{\wbr}กระบวนการ{\wbr}จัดการ}

ใน{\wbr}ส่วน{\wbr}นี้ เรา{\wbr}จะ{\wbr}ปรับปรุง{\wbr}รูปแบบ{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}โครงสร้าง{\wbr}ข้อมูล{\wbr}ให้{\wbr}สะดวก{\wbr}ขึ้น{\wbr}
โดย{\wbr}การ{\wbr}รวม{\wbr}ตัวแปร{\wbr}ที่{\wbr}เกี่ยวข้อง{\wbr}หลาย{\wbr}ตัว{\wbr}เข้า{\wbr}ด้วย{\wbr}กัน{\wbr}เป็น{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ใหม่{\wbr}
จากนั้น{\wbr}เรา{\wbr}จะ{\wbr}รวม{\wbr}กระบวนการ{\wbr}จัดการ{\wbr}เข้า{\wbr}ไว้{\wbr}ดว้ย

\subsection{การ{\wbr}รวม{\wbr}กลุ่ม{\wbr}ข้อมูล: {\ct struct}}

ถ้า{\wbr}เรา{\wbr}พิจารณา{\wbr}ฟังก์ชัน{\wbr}ต่าง ๆ ที่{\wbr}เรา{\wbr}อิม{\wbr}พลี{\wbr}เมนท์
เรา{\wbr}จะ{\wbr}พบ{\wbr}ว่า{\wbr}ทุก{\wbr}ครั้ง{\wbr}ใน{\wbr}การ{\wbr}เรียก{\wbr}ใช้{\wbr}เรา{\wbr}จำเป็น{\wbr}จะ{\wbr}ต้อง{\wbr}ส่ง{\wbr}พารามิเตอร์ {\ct list} ที่{\wbr}เก็บ{\wbr}ข้อมูล{\wbr}
และ {\ct size} ที่{\wbr}ระบุ{\wbr}จำนวน{\wbr}ข้อมูล{\wbr}ใน{\wbr}รายการ{\wbr}ไป{\wbr}พร้อม ๆ กัน{\wbr}ตลอด{\wbr}
ข้อสังเกต{\wbr}นี้{\wbr}แสดง{\wbr}ว่า{\wbr}ข้อมูล{\wbr}ทั้ง{\wbr}สอง{\wbr}มี{\wbr}ความ{\wbr}เกี่ยวข้อง{\wbr}กัน{\wbr}มาก{\wbr}
ใน{\wbr}กรณี{\wbr}นี้{\wbr}เพราะว่า{\wbr}เป็น{\wbr}ข้อมูล{\wbr}พื้นฐาน{\wbr}ของ{\wbr}การ{\wbr}จัดการ{\wbr}เกี่ยวกับ{\wbr}รายการ{\wbr}ของ{\wbr}เรา{\wbr}

สิ่ง{\wbr}แรก{\wbr}ที่{\wbr}เรา{\wbr}สามารถ{\wbr}ปรับปรุง{\wbr}ได้{\wbr}คือ{\wbr}การ{\wbr}รวม{\wbr}กลุ่ม{\wbr}ข้อมูล{\wbr}นี้{\wbr}เข้า{\wbr}ด้วย{\wbr}กัน ใน{\wbr}ภาษา C++
เรา{\wbr}สามารถ{\wbr}ประกาศ{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}แบบ{\wbr}โครงสร้าง{\wbr}โดย{\wbr}ใช้{\wbr}คีย์{\wbr}เวิร์ด {\ct struct}
เพื่อ{\wbr}รวม{\wbr}กลุ่ม{\wbr}ข้อมูล{\wbr}หลาย ๆ ชนิด{\wbr}เข้า{\wbr}ด้วย{\wbr}กัน{\wbr}

\latintext
\begin{codelist}{C++}{}
const int max_list_size = 1000;

struct list {
  int items[max_list_size];
  int size;
};
\end{codelist}
\thaitext

ใน{\wbr}การ{\wbr}ประกาศ{\wbr}นั้น{\wbr}เรา{\wbr}จะ{\wbr}ระบุ{\wbr}สมาชิก (member) ของ{\wbr}โครงสร้าง{\wbr}ที่{\wbr}เรา{\wbr}ประกาศ{\wbr}
เรา{\wbr}สามารถ{\wbr}ประกาศ{\wbr}ชนิด{\wbr}ข้อมูล {\ct list} ที่{\wbr}มี{\wbr}สมาชิก{\wbr}คือ{\wbr}อาร์เรย์ {\ct items}
และ{\wbr}จำนวนเต็ม {\ct size} ดัง{\wbr}โปรแกรม{\wbr}ด้าน{\wbr}ล่าง{\wbr}
(สังเกต{\wbr}ว่า{\wbr}เรา{\wbr}ประกาศ{\wbr}ขนาด{\wbr}ของ{\wbr}อาร์เรย์{\wbr}ไว้{\wbr}ที่{\wbr}ค่าคงที่ {\ct max\_list\_size}
โดย{\wbr}ให้{\wbr}มี{\wbr}ขนาด 1000 ช่อง)

สังเกต{\wbr}ว่า{\wbr}เรา{\wbr}จะ{\wbr}ต้อง{\wbr}ใช้{\wbr}เครื่องหมาย {\ct ;} ใน{\wbr}การ{\wbr}ปิด{\wbr}การ{\wbr}ประกาศ {\ct struct} ด้วย{\wbr}

เรา{\wbr}สามารถ{\wbr}ประกาศ{\wbr}ตัวแปร{\wbr}ที่{\wbr}มี{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}เป็น {\ct list} ได้ ตัวแปร{\wbr}นี้{\wbr}จะ{\wbr}มี{\wbr}สมาชิก{\wbr}ชื่อ {\ct
  items} และ {\ct size} ซึ่ง{\wbr}สามารถ{\wbr}อ้าง{\wbr}ถึง{\wbr}ได้{\wbr}โดย{\wbr}ใช้{\wbr}โอ{\wbr}เปอเรเตอร์ {\ct .}
ยก{\wbr}ตัวอย่าง{\wbr}เช่น ถ้า{\wbr}เรา{\wbr}ประกาศ{\wbr}
\begin{center}
{\ct list lst;}
\end{center}
เรา{\wbr}จะ{\wbr}สามารถ{\wbr}อ้าง{\wbr}ถึง {\ct lst.items} และ {\ct lst.size} ได้{\wbr}

เรา{\wbr}สามารถ{\wbr}ปรับ{\wbr}ฟังก์ชัน{\wbr}ต่าง ๆ ที่{\wbr}เคย{\wbr}ต้อง{\wbr}รับ{\wbr}พารามิเตอร์{\wbr}สอง{\wbr}ตัว{\wbr}ให้{\wbr}รับ{\wbr}โครงสร้าง {\ct list}
เพียง{\wbr}พารามิเตอร์{\wbr}เดียว{\wbr}ได้ บาง{\wbr}ฟังก์ชัน{\wbr}ที่{\wbr}สำคัญ{\wbr}แสดง{\wbr}ใน{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-struct-list}

\begin{figure}
\latintext
\begin{codelist}{C++}{caption={\thaitext บาง{\wbr}ฟังก์ชัน{\wbr}ที่ทำงาน{\wbr}กับ {\ct list}\latintext},label=code:abs-struct-list}
typedef int* list_itr;

void list_init(list& l)
{
  l.size = 0;
}

list_itr list_itr_end(list& l)
{
  return &l.items[l.size];
}

list_itr list_find(list& l, int x)
{
  for(int i = 0; i < l.size; ++i)
    if(l.items[i] == x)
      return &l.items[i];
  return list_itr_end(l);
}

list_itr list_append(list& l, int x)
{
  if(l.size >= max_list_size)
    throw "List overflow";
  l.items[l.size] = x;
  ++l.size;
  return &l.items[l.size-1];
}
\end{codelist}
\thaitext
\end{figure}

สังเกต{\wbr}ว่า{\wbr}ฟังก์ชัน {\ct list\_append}
คืน{\wbr}ค่า{\wbr}เป็น{\wbr}ตัว{\wbr}วิ่ง{\wbr}ที่{\wbr}ชี้{\wbr}ไป{\wbr}ที่{\wbr}ข้อมูล{\wbr}ที่{\wbr}เพิ่ง{\wbr}เพิ่ม{\wbr}เข้า{\wbr}ไป{\wbr}ใน{\wbr}รายการ ค่า{\wbr}นี้{\wbr}โดยมาก{\wbr}จะ{\wbr}ไม่{\wbr}ได้{\wbr}ใช้{\wbr}
อย่างไรก็ตาม{\wbr}อาจ{\wbr}จะ{\wbr}เป็น{\wbr}ประโยชน์{\wbr}ใน{\wbr}การ{\wbr}อ้าง{\wbr}ถึง{\wbr}ต่อไป{\wbr}ได้ เรา{\wbr}จึง{\wbr}ให้{\wbr}ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}คืน{\wbr}ค่า{\wbr}มา{\wbr}

อย่างไรก็ตาม เรา{\wbr}ต้อง{\wbr}ระวัง{\wbr}วิธีการ{\wbr}ผ่าน{\wbr}พารามิเตอร์ เนื่องจาก{\wbr}โดย{\wbr}ปกติ C++
จะ{\wbr}ส่ง{\wbr}ค่า{\wbr}พารามิเตอร์{\wbr}แบบ pass by value ดังนั้น ถ้า{\wbr}เรา{\wbr}ส่ง{\wbr}ค่า{\wbr}โครงสร้าง {\ct list}
โดย{\wbr}ตรง จะ{\wbr}ทำ{\wbr}ให้{\wbr}ระบบ{\wbr}สร้าง{\wbr}ตัวแปร{\wbr}ประเภท {\ct list}
อีก{\wbr}ตัว{\wbr}หนึ่ง{\wbr}และ{\wbr}คัดลอก{\wbr}ข้อมูล{\wbr}จาก{\wbr}อาร์กิวเมนท์{\wbr}ที่{\wbr}เรา{\wbr}ส่ง{\wbr}ไป{\wbr}ยัง{\wbr}ตัวแปร{\wbr}ชั่ว{\wbr}คราวนี้{\wbr}
ซึ่ง{\wbr}ใน{\wbr}กรณี{\wbr}ของ{\wbr}โครงสร้าง {\ct list} นอกจาก{\wbr}จะ{\wbr}ทำ{\wbr}ให้{\wbr}โปรแกรม{\wbr}ทำงาน{\wbr}ไม่{\wbr}ถูกต้อง{\wbr}แล้ว{\wbr}
(เช่น{\wbr}ใน{\wbr}กรณี{\wbr}ของ{\wbr}ฟังก์ชัน {\ct list\_init})
ยัง{\wbr}เป็น{\wbr}การ{\wbr}ทำ{\wbr}ให้{\wbr}โปรแกรม{\wbr}มี{\wbr}ประสิทธิภาพ{\wbr}การ{\wbr}ทำงาน{\wbr}ต่ำ{\wbr}ลง{\wbr}โดย{\wbr}ไม่{\wbr}จำเป็น{\wbr}ด้วย{\wbr}

ตัวอย่าง{\wbr}การ{\wbr}เรียก{\wbr}ใช้{\wbr}งาน{\wbr}ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}แสดง{\wbr}ใน{\wbr}โปรแกรม{\wbr}ต่อไปนี้{\wbr}

\latintext
\begin{codelist}{C++}{}
  list lst;
  list_init(lst);
  list_append(lst,10);  list_append(lst,30);  list_append(lst,20);
  if(list_find(lst,5) != list_itr_end(lst))  // find 5 in list
    cout << "found" << endl;
  else
    cout << "not found" << endl;
\end{codelist}
\thaitext

\subsection{การ{\wbr}รวม{\wbr}กระบวนการ{\wbr}เข้า{\wbr}เป็น{\wbr}ฟังก์ชัน{\wbr}สมาชิก} 

สังเกต{\wbr}ว่า{\wbr}ฟังก์ชัน{\wbr}ต่าง ๆ ที่ทำงาน{\wbr}กับ{\wbr}รายการ{\wbr}ที่{\wbr}เรา{\wbr}เขียน{\wbr}นั้น โดยมาก{\wbr}จะ{\wbr}ทำงาน{\wbr}กับ{\wbr}โครงสร้าง{\wbr}
{\ct list} ที่{\wbr}รับ{\wbr}พารามิเตอร์{\wbr}มา เนื่องจาก{\wbr}ฟังก์ชัน{\wbr}เหล่านี้{\wbr}ประมวลผล{\wbr}กับ{\wbr}ข้อมูล{\wbr}โดย{\wbr}ตรง{\wbr}
เรา{\wbr}จะ{\wbr}รวม{\wbr}ฟังก์ชัน{\wbr}เหล่านั้น{\wbr}เข้า{\wbr}เป็น{\wbr}สมาชิก{\wbr}ของ{\wbr}โครงสร้าง {\ct list}
เพื่อให้{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}ทำ{\wbr}ได้{\wbr}สะดวก{\wbr}ขึ้น ตัวอย่าง{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}ฟังก์ชัน{\wbr}เหล่านี้{\wbr}ผ่าน{\wbr}ทาง{\wbr}ตัวแปร {\ct
  list} แสดง{\wbr}ใน{\wbr}โปรแกรม{\wbr}ถัด{\wbr}ไป เรา{\wbr}จะ{\wbr}สังเกต{\wbr}ว่า{\wbr}การ{\wbr}เรียก{\wbr}ใช้{\wbr}งาน{\wbr}ดู{\wbr}กระชับ{\wbr}ขึ้น{\wbr}

\latintext
\begin{codelist}{C++}{}
  list lst;
  lst.init();
  lst.append(10);  lst.append(30);  lst.append(20);
  if(lst.find(5) != lst.end())  // find 5 in list
    cout << "found" << endl;
  else
    cout << "not found" << endl;
\end{codelist}
\thaitext

เรา{\wbr}จะ{\wbr}เพิ่ม{\wbr}การ{\wbr}ประกาศ{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}เข้า{\wbr}ไป{\wbr}ใน{\wbr}การ{\wbr}ประกาศ {\ct struct}
ดัง{\wbr}แสดง{\wbr}ใน{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-struct-list-functions}
ฟังก์ชัน{\wbr}เหล่านี้{\wbr}เรียก{\wbr}ว่า{\em ฟังก์ชัน{\wbr}สมาชิก} ({\em member function})

นอกจากนี้ เรา{\wbr}ยัง{\wbr}นำ{\wbr}ชนิด{\wbr}ข้อมูล {\ct list\_itr} ย้าย{\wbr}ไป{\wbr}ประกาศ{\wbr}ไว้{\wbr}ภายใน{\wbr}โครงสร้าง {\ct
  list} ด้วย โดย{\wbr}ใช้{\wbr}ชื่อ{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}เป็น {\ct iterator} (สังเกต{\wbr}ว่า{\wbr}เรา{\wbr}ตัด{\wbr}คำขึ้นต้น {\ct
  list} ทิ้ง{\wbr}ไป{\wbr}หมด เพื่อ{\wbr}ไม่{\wbr}ให้{\wbr}ชื่อ{\wbr}ซ้ำซ้อน) นอกจากนี้{\wbr}เรา{\wbr}ยัง{\wbr}หลีกเลี่ยง{\wbr}การ{\wbr}ตั้ง{\wbr}ชื่อ{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ว่า{\wbr}
{\ct delete} โดย{\wbr}ใช้{\wbr}ชื่อ{\wbr}ว่า {\ct del} แทน เพราะ{\wbr}จะ{\wbr}ซ้ำ{\wbr}กับ{\wbr}ชื่อ{\wbr}โอ{\wbr}เปอเรเตอร์ {\ct
  delete}

\begin{figure}
\latintext
\begin{codelist}{C++}{caption={\thaitext การ{\wbr}ประกาศ{\wbr}โครงสร้าง {\ct list} ที่{\wbr}ระบุ{\wbr}ฟังก์ชัน{\wbr}สมาชิก\latintext},label=code:abs-struct-list-functions}
struct list {
  // members
  int items[max_list_size];
  int size;

  typedef int* iterator;

  // member functions
  void init();
  iterator begin();
  iterator end();
  iterator find(int x);
  iterator append(int x);
  void del(iterator p);
  void insert_after(iterator p, int x);
};
\end{codelist}
\thaitext
\end{figure}

ฟังก์ชัน{\wbr}สมาชิก{\wbr}เหล่านี้ จะ{\wbr}ทำงาน{\wbr}กับ{\wbr}ตัวแปร{\wbr}โครงสร้าง {\ct list}
และ{\wbr}สามารถ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก{\wbr}ที่{\wbr}เป็น{\wbr}ตัวแปร{\wbr}เช่น {\ct size} และ {\ct items} ได้{\wbr}โดย{\wbr}ตรง{\wbr}
รูป{\wbr}ที่~\ref{fig:abs-member-functions}

\begin{figure}
TODO: add this
\caption{แสดง{\wbr}ลักษณะ{\wbr}การ{\wbr}ทำงาน{\wbr}ของ{\wbr}ฟังก์ชัน{\wbr}สมาชิก}
\label{fig:abs-member-functions}
\end{figure}

หลังจาก{\wbr}ประกาศ{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ต่าง ๆ เหล่านี้ ใน{\wbr}โครงสร้าง {\ct list} แล้ว{\wbr}
เรา{\wbr}จะ{\wbr}นิยาม{\wbr}ฟังก์ชัน{\wbr}ดังกล่าว โปรแกรม{\wbr}ที่~\ref{code:abs-list-init-find}
แสดง{\wbr}การ{\wbr}นิยาม{\wbr}ฟังก์ชัน {\ct list::init}, {\ct list::end}, และ {\ct list:find}

\begin{figure}
\latintext
\begin{codelist}{C++}{}
void list::init()
{
  size = 0;
}

list::iterator list::end()
{
  return &items[size];
}

list::iterator list::find(int x)
{
  for(int i = 0; i < size; ++i)
    if(items[i] == x)
      return &items[i];
  return end(l);
}
\end{codelist}
\thaitext
\end{figure}

เช่นเดียวกับ{\wbr}การ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก {\ct size} และ {\ct items} ของ{\wbr}ตัวแปร {\ct l} ด้วย{\wbr}
{\ct l.size} และ {\ct l.items} ใน{\wbr}การ{\wbr}อ้าง{\wbr}ถึง{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ของ{\wbr}ตัวแปร{\wbr}ต่าง ๆ
เรา{\wbr}จะ{\wbr}ใช้{\wbr}โอ{\wbr}เปอเรเตอร์{\wbr}จุด ({\ct .})  ส่วน{\wbr}ใน{\wbr}กรณี{\wbr}ที่{\wbr}เรา{\wbr}จะ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก{\wbr}ของ{\wbr}โครงสร้าง{\wbr}เอง{\wbr}
เรา{\wbr}จะ{\wbr}ใช้{\wbr}โอ{\wbr}เปอเรเตอร์ {\ct ::} เช่น {\ct list::init} และ {\ct
  list::iterator}

สังเกต{\wbr}ว่า{\wbr}ภายใน{\wbr}ฟังก์ชัน{\wbr}สมาชิก {\ct list::init} เรา{\wbr}สามารถ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก {\ct size}
ได้{\wbr}โดย{\wbr}ตรง ตัวแปร{\wbr}ดังกล่าว{\wbr}จะ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก {\ct size}
ของ{\wbr}ตัวแปร{\wbr}ที่{\wbr}เรา{\wbr}เรียก{\wbr}ฟังก์ชัน{\wbr}เหล่านี้{\wbr}ผ่าน เช่น ถ้า{\wbr}เรา{\wbr}เรียก {\ct lst.init()} ตัวแปร{\wbr}
{\ct size} ใน{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ที่{\wbr}เรา{\wbr}เขียน{\wbr}จะ{\wbr}หมายถึง {\ct lst.size}

\begin{quiz}{ฟังก์ชัน{\wbr}สมาชิก{\wbr}อื่น ๆ}
เขียน{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}อื่น ๆ ของ{\wbr}โครงสร้าง {\ct list} และ{\wbr}ทดสอบ{\wbr}กับ{\wbr}โปรแกรม{\wbr}ตัวอย่าง{\wbr}
\end{quiz}

\section{การ{\wbr}ซ่อน{\wbr}รายละเอียด: {\ct class}}

ใน{\wbr}ส่วน{\wbr}ที่แล้ว{\wbr}เรา{\wbr}พัฒนา{\wbr}ชนิด{\wbr}ข้อมูล {\ct list}
ที่{\wbr}รวม{\wbr}ข้อมูล{\wbr}และ{\wbr}กระบวนการ{\wbr}ที่ทำงาน{\wbr}กับ{\wbr}ข้อมูล{\wbr}ไว้{\wbr}ด้วย{\wbr}กัน ทำ{\wbr}ให้การ{\wbr}ใช้{\wbr}งาน{\wbr}ต่าง ๆ
สะดวก{\wbr}ขึ้น{\wbr}และ{\wbr}เขียน{\wbr}โปรแกรม{\wbr}ได้{\wbr}อย่าง{\wbr}กระชับ{\wbr}ขึ้น การ{\wbr}สร้าง{\wbr}ชนิด{\wbr}ข้อมูล {\ct list} ที่{\wbr}เรา{\wbr}ทำ{\wbr}นี้{\wbr}
เป็น{\wbr}ส่วนหนึ่ง{\wbr}ของ{\wbr}การ{\wbr}จัดการ{\wbr}กับ{\wbr}ความ{\wbr}ซับซ้อน{\wbr}ของ{\wbr}ซอฟต์แวร์ โดย{\wbr}การ{\wbr}แบ่ง{\wbr}งาน{\wbr}เป็น{\wbr}ส่วนย่อย ๆ
และ{\wbr}พัฒนา{\wbr}โปรแกรม{\wbr}เพื่อ{\wbr}รับผิดชอบ{\wbr}งาน{\wbr}แต่ละ{\wbr}ส่วน{\wbr}แยกกัน{\wbr}ไป{\wbr}

อย่างไรก็ตาม สังเกต{\wbr}ว่า{\wbr}ใน{\wbr}การ{\wbr}เขียน{\wbr}ที่{\wbr}ผ่าน{\wbr}มา{\wbr}
เรา{\wbr}ไม่{\wbr}สามารถ{\wbr}รับประกัน{\wbr}ว่า{\wbr}งาน{\wbr}ที่{\wbr}แบ่ง{\wbr}ออก{\wbr}มา{\wbr}พัฒนา{\wbr}เป็น{\wbr}ส่วน ๆ นั้น{\wbr}
จะ{\wbr}ถูก{\wbr}แบ่ง{\wbr}ไป{\wbr}ดูแล{\wbr}แยก{\wbr}ขาด{\wbr}จาก{\wbr}กัน ยก{\wbr}ตัวอย่าง{\wbr}เช่น{\wbr}
อาจ{\wbr}มี{\wbr}ส่วนหนึ่ง{\wbr}ของ{\wbr}ระบบ{\wbr}ที่{\wbr}ต้องการ{\wbr}แทรก{\wbr}ข้อมูล{\wbr}ใน{\wbr}รายการ{\wbr}เพื่อ{\wbr}เป็น{\wbr}รายการ{\wbr}แรก ซึ่ง{\wbr}โครงสร้าง{\wbr}
{\ct list} ที่{\wbr}เรา{\wbr}ได้{\wbr}พัฒนา{\wbr}ไว้ ยัง{\wbr}ไม่{\wbr}ได้{\wbr}รองรับ{\wbr}
โปรแกรมเมอร์{\wbr}ผู้รับผิดชอบ{\wbr}ใน{\wbr}ส่วน{\wbr}นั้น{\wbr}ก็{\wbr}อาจ{\wbr}จะ{\wbr}เปิด{\wbr}ดู{\wbr}ส่วน{\wbr}ของ{\wbr}โปรแกรม{\wbr}ที่{\wbr}เรา{\wbr}เขียน{\wbr}ขึ้น{\wbr}
และ{\wbr}เขียน{\wbr}โปรแกรม{\wbr}ใน{\wbr}ลักษณะ{\wbr}ด้าน{\wbr}ล่าง{\wbr}ขึ้น{\wbr}มา{\wbr}เพื่อ{\wbr}ทำงาน{\wbr}ดังกล่าว{\wbr}

\latintext
\begin{codelist}{C++}{}
for(int i = lst.size-1; i >= 0; --i)
  lst.items[i+1] = lst.items[i];
lst.items[0] = x;
++lst.size;
\end{codelist}
\thaitext

โปรแกรม{\wbr}ดังกล่าว{\wbr}สามารถ{\wbr}ทำงาน{\wbr}ได้{\wbr}ถูกต้อง{\wbr}
อย่างไรก็ตาม{\wbr}โปรแกรม{\wbr}ไม่{\wbr}มี{\wbr}การ{\wbr}ตรวจสอบ{\wbr}ขอบเขต{\wbr}ของ{\wbr}อาร์เรย์{\wbr}เลย{\wbr}
ทำ{\wbr}ให้{\wbr}โปรแกรม{\wbr}อาจ{\wbr}จะ{\wbr}เกิด{\wbr}ความผิด{\wbr}พลาด{\wbr}ได้{\wbr}ใน{\wbr}ภายหลัง สังเกต{\wbr}ว่า{\wbr}
ถ้า{\wbr}โปรแกรมเมอร์{\wbr}คน{\wbr}ที่{\wbr}เขียน{\wbr}โปรแกรม{\wbr}ดังกล่าว เขียน{\wbr}ผิดพลาด (เช่น ลืม{\wbr}เพิ่ม{\wbr}ค่า {\ct
  lst.size} ก็{\wbr}อาจ{\wbr}จะ{\wbr}มี{\wbr}ผลกระทบ{\wbr}ไป{\wbr}กับ{\wbr}ทุก{\wbr}ส่วน{\wbr}ของ{\wbr}ระบบ{\wbr}ที่{\wbr}มี{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}รายการ{\wbr}นี้)

อย่างไรก็ตาม{\wbr}
ความ{\wbr}ยาก{\wbr}ของ{\wbr}การ{\wbr}พัฒนา{\wbr}ซอฟต์แวร์{\wbr}ขนาด{\wbr}ใหญ่{\wbr}ไม่{\wbr}ได้{\wbr}เกิด{\wbr}จาก{\wbr}ความ{\wbr}ซับซ้อน{\wbr}เพียง{\wbr}อย่างเดียว{\wbr}
แต่{\wbr}ระบบ{\wbr}ขนาด{\wbr}ใหญ่{\wbr}ยัง{\wbr}มี{\wbr}ความ{\wbr}ต้องการ{\wbr}ใน{\wbr}การ{\wbr}ปรับ{\wbr}เปลี่ยน{\wbr}ตลอดเวลา{\wbr}
เพื่อให้{\wbr}สามารถ{\wbr}รองรับ{\wbr}ความ{\wbr}ต้องการ{\wbr}ของ{\wbr}ผู้ใช้{\wbr}ได้{\wbr}

สมมติ{\wbr}ว่า{\wbr}ใน{\wbr}อนาคต มี{\wbr}ความจำ{\wbr}เป็น{\wbr}ต้อง{\wbr}เปลี่ยน{\wbr}รูปแบบ{\wbr}ใน{\wbr}การ{\wbr}เก็บ{\wbr}ข้อมูล{\wbr}รายการ{\wbr}ใหม่{\wbr}
จาก{\wbr}ที่{\wbr}เคย{\wbr}ใช้{\wbr}อาร์เรย์ มา{\wbr}ใช้{\wbr}โครงสร้าง{\wbr}ข้อมูล{\wbr}แบบ{\wbr}อื่น{\wbr}ที่{\wbr}มี{\wbr}ประสิทธิภาพ{\wbr}มาก{\wbr}กว่า{\wbr}
ถ้า{\wbr}เรา{\wbr}ยอม{\wbr}ให้{\wbr}โปรแกรม{\wbr}ใน{\wbr}ส่วน{\wbr}ต่าง ๆ พัฒนา{\wbr}กระบวนการ{\wbr}จัดการ{\wbr}รายการ{\wbr}ได้{\wbr}โดย{\wbr}เป็น{\wbr}อิสระ{\wbr}
เรา{\wbr}จะ{\wbr}ต้อง{\wbr}เข้า{\wbr}ไป{\wbr}แก้ไข{\wbr}โปรแกรม{\wbr}ต่าง ๆ
เหล่านั้น{\wbr}เพื่อให้{\wbr}การ{\wbr}เปลี่ยนแปลง{\wbr}โครงสร้าง{\wbr}ภายใน{\wbr}ของ{\wbr}รายการ{\wbr}เป็น{\wbr}ไป{\wbr}ได้{\wbr}

ยิ่ง{\wbr}ไป{\wbr}กว่า{\wbr}นั้น ถ้า{\wbr}เรา{\wbr}เปลี่ยนแปลง{\wbr}โปรแกรม{\wbr}โดย{\wbr}ที่{\wbr}ยัง{\wbr}ใช้{\wbr}ตัวแปร{\wbr}สมาชิก {\ct items} หรือ {\ct
  size} อยู่{\wbr}แต่{\wbr}ใช้{\wbr}ใน{\wbr}ความหมาย{\wbr}อื่น โปรแกรม{\wbr}ใน{\wbr}ส่วน{\wbr}อื่น ๆ
ที่{\wbr}เรียก{\wbr}ใช้{\wbr}ข้อมูล{\wbr}จาก{\wbr}รายการ{\wbr}ผ่าน{\wbr}ทาง{\wbr}สมาชิก{\wbr}ดังกล่าว{\wbr}โดย{\wbr}ตรง{\wbr}ก็{\wbr}จะ{\wbr}ยัง{\wbr}สามารถ{\wbr}คอมไพล์{\wbr}ได้{\wbr}
รวม{\wbr}ถึง{\wbr}อาจ{\wbr}จะ{\wbr}ทำงาน{\wbr}ได้{\wbr}โดย{\wbr}ที่{\wbr}เรา{\wbr}ไม่{\wbr}ทราบ{\wbr}ว่า{\wbr}มี{\wbr}ความผิด{\wbr}พลาด{\wbr}ซ่อน{\wbr}อยู่{\wbr}
ความผิด{\wbr}พลาด{\wbr}พวก{\wbr}นี้{\wbr}ก็{\wbr}เป็น{\wbr}เสมือน{\wbr}ระเบิดเวลา{\wbr}รอ{\wbr}การ{\wbr}ระเบิด{\wbr}เท่านั้น{\wbr}เอง{\wbr}

ภาษา C++ ได้{\wbr}พัฒนา{\wbr}มา{\wbr}จาก{\wbr}ภาษา C
โดย{\wbr}มี{\wbr}เป้าหมาย{\wbr}ที่{\wbr}จะ{\wbr}ทำ{\wbr}ให้{\wbr}ภาษา{\wbr}โปรแกรม{\wbr}ช่วย{\wbr}จัดการ{\wbr}กับ{\wbr}ความ{\wbr}ซับซ้อน{\wbr}ได้{\wbr}ดี{\wbr}ขึ้น{\wbr}
หนึ่ง{\wbr}ใน{\wbr}ความ{\wbr}สามารถ{\wbr}ที่{\wbr}เพิ่ม{\wbr}เข้า{\wbr}มา{\wbr}คือ{\wbr}การ{\wbr}รวม{\wbr}กระบวนการ{\wbr}เข้า{\wbr}กับ{\wbr}ข้อมูล ดังที่{\wbr}เรา{\wbr}ได้{\wbr}ทดลอง{\wbr}ใช้{\wbr}แล้ว{\wbr}
อีก{\wbr}หนึ่ง{\wbr}ความ{\wbr}สามารถ{\wbr}ที่{\wbr}สำคัญ{\wbr}ไม่{\wbr}แพ้{\wbr}กัน{\wbr}
ก็{\wbr}คือ{\wbr}ความ{\wbr}สามารถ{\wbr}ใน{\wbr}การ{\wbr}กำหนด{\wbr}ขอบเขต{\wbr}การ{\wbr}เข้า{\wbr}ใช้{\wbr}สมาชิก{\wbr}ของ{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ที่{\wbr}เรา{\wbr}ได้{\wbr}สร้าง{\wbr}ขึ้น เช่น{\wbr}
ใน{\wbr}กรณี{\wbr}นี้ เรา{\wbr}สามารถ{\wbr}ระบุ{\wbr}ได้{\wbr}ว่า{\wbr}สมาชิก {\ct items} และ {\ct size}
เป็น{\wbr}สมาชิก{\wbr}ภายใน{\wbr}ของ{\wbr}ส่วน{\wbr}นี้ และ{\wbr}ไม่{\wbr}ยอม{\wbr}ให้{\wbr}โปรแกรม{\wbr}ใน{\wbr}ส่วน{\wbr}อื่น ๆ เข้าถึง{\wbr}ได้{\wbr}โดย{\wbr}ตรง{\wbr}

เรา{\wbr}จะ{\wbr}ศึกษา{\wbr}ความ{\wbr}สามารถ{\wbr}ดังกล่าว{\wbr}โดย{\wbr}การ{\wbr}พัฒนา{\wbr}ค{\wbr}ลา{\wbr}ส ({\ct class})
สำหรับ{\wbr}จัดการ{\wbr}กับ{\wbr}รายการ  

ใน{\wbr}ภาษา C++ ค{\wbr}ลา{\wbr}ส เป็น{\wbr}การ{\wbr}สร้าง{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ใหม่ ใน{\wbr}ลักษณะ{\wbr}เดียวกัน{\wbr}กับ {\ct struct} จริง{\wbr}
ๆ แล้ว โครงสร้าง{\wbr}สอง{\wbr}แบบ{\wbr}นี้{\wbr}มี{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}เหมือน{\wbr}กัน{\wbr}ทุก{\wbr}ประการ{\wbr}
ยกเว้น{\wbr}เกณฑ์{\wbr}มาตรฐาน{\wbr}ใน{\wbr}การ{\wbr}ควบคุม{\wbr}การ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก{\wbr}
สำหรับ{\wbr}ตัวแปร{\wbr}ที่{\wbr}ประกาศ{\wbr}ขึ้น{\wbr}จาก{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}หรือ{\wbr}โครงสร้าง เรา{\wbr}นิยม{\wbr}เรียก{\wbr}ว่า{\em วัตถุ}

เรา{\wbr}จะ{\wbr}นิยาม{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ได้{\wbr}ใน{\wbr}ลักษณะ{\wbr}เดียวกับ{\wbr}การ{\wbr}นิยาม {\ct struct} แต่{\wbr}สมาชิก{\wbr}ต่าง ๆ
ที่{\wbr}เรา{\wbr}นิยาม{\wbr}ใน{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}จะ{\wbr}ไม่{\wbr}สามารถ{\wbr}ถูก{\wbr}อ้าง{\wbr}ถึง{\wbr}ได้{\wbr}จาก{\wbr}โปรแกรม{\wbr}ที่อยู่ ``ภายนอก'' ค{\wbr}ลา{\wbr}ส
ยกเว้น{\wbr}จะ{\wbr}เป็น{\wbr}ส่วน{\wbr}ที่{\wbr}เรา{\wbr}ระบุ{\wbr}ไว้ พิจารณา{\wbr}ตัวอย่าง{\wbr}โปรแกรม{\wbr}ด้าน{\wbr}ล่าง{\wbr}เพื่อ{\wbr}เปรียบเทียบ{\wbr}

\latintext
\begin{codelist}{C++}{}
struct test1 { int a;  int f() { return a+1; } };
class test2 { int a; int f() { return a+1; } };

test1 s1;  test2 s2;
cout << s1.a << endl;       // works
cout << s2.a << endl;       // compilation error
cout << s1.f() << endl;     // works
cout << s2.f() << endl;     // compilation error
\end{codelist}
\thaitext

สังเกต{\wbr}ว่า{\wbr}ฟังก์ชัน{\wbr}สมาชิก {\ct test2::f } สามารถ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก {\ct a} ได้{\wbr}
แต่{\wbr}โปรแกรม{\wbr}ภายนอก{\wbr}ไม่{\wbr}สามารถ{\wbr}อ้าง{\wbr}ถึง{\wbr}ได้{\wbr}

ใน{\wbr}การ{\wbr}ระบุ{\wbr}ขอบเขต{\wbr}การ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก{\wbr}ใน{\wbr}ค{\wbr}ลา{\wbr}ส เรา{\wbr}จะ{\wbr}ใช้{\wbr}คีย์{\wbr}เวิร์ด {\ct private} และ {\ct
  public} สมาชิก{\wbr}ที่อยู่{\wbr}หลักการ{\wbr}ระบุ {\ct public}
เป็น{\wbr}ส่วน{\wbr}สาธารณะ{\wbr}จะ{\wbr}ถูก{\wbr}อ้าง{\wbr}ถึง{\wbr}จาก{\wbr}ส่วน{\wbr}ใด ๆ ของ{\wbr}โปรแกรม{\wbr}ก็ได้ ส่วน{\wbr}ที่{\wbr}ถูก{\wbr}ระบุ{\wbr}ว่า{\wbr}เป็น {\ct
  private} จะ{\wbr}เป็น{\wbr}สมาชิก{\wbr}ส่วนตัว{\wbr}และ{\wbr}ถูก{\wbr}อ้าง{\wbr}ถึง{\wbr}ได้{\wbr}จาก{\wbr}สมาชิก{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}เท่านั้น{\wbr}
ใน{\wbr}กรณี{\wbr}ที่{\wbr}เรา{\wbr}ไม่{\wbr}ได้{\wbr}ระบุ{\wbr}อะไร สมาชิก{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}จะ{\wbr}เป็น{\wbr}สมาชิก{\wbr}ส่วนตัว \ \ \ ใน{\wbr}ทาง{\wbr}กลับ{\wbr}กัน{\wbr}
สำหรับ{\wbr}การ{\wbr}นิยาม{\wbr}โครงสร้าง{\wbr}นั้น สมาชิก{\wbr}ที่{\wbr}ไม่{\wbr}ได้{\wbr}ระบุ{\wbr}ขอบเขต{\wbr}การ{\wbr}เข้าถึง{\wbr}
จะ{\wbr}ถูก{\wbr}พิจารณา{\wbr}เป็น{\wbr}สมาชิก{\wbr}สาธารณะ{\wbr}

พิจารณา{\wbr}ค{\wbr}ลา{\wbr}ส {\ct test2}
ที่{\wbr}แก้ไข{\wbr}แล้ว{\wbr}ด้าน{\wbr}ล่าง{\wbr}ที่{\wbr}เปิด{\wbr}ให้{\wbr}ฟังก์ชัน {\ct test2::f} สามารถ{\wbr}เข้าถึง{\wbr}ได้{\wbr}จาก{\wbr}ทุก ๆ ที่{\wbr}
สังเกต{\wbr}ว่า{\wbr}เรา{\wbr}เพิ่ม{\wbr}ฟังก์ชัน {\ct set\_a} เพื่อให้{\wbr}เรา{\wbr}สามารถ{\wbr}กำหนด{\wbr}ค่า{\wbr}ให้{\wbr}กับ {\ct a}
ได้{\wbr}ด้วย (ไม่{\wbr}เช่นนั้น{\wbr}เรา{\wbr}จะ{\wbr}ไม่{\wbr}มี{\wbr}ทาง{\wbr}กำหนด{\wbr}ค่า{\wbr}ให้{\wbr}กับ {\ct a} ได้{\wbr}เลย)

\latintext
\begin{codelist}{C++}{}
class test2 { 
  int a; 
public: 
  void set_a(int aa) { a = aa; }
  int f() { return a+1; } 
};
\end{codelist}
\thaitext

\subsection{ค{\wbr}ลา{\wbr}ส{\wbr}สำหรับ{\wbr}ตัว{\wbr}นับ}
เรา{\wbr}จะ{\wbr}เขียน{\wbr}ค{\wbr}ลา{\wbr}ส {\ct counter} สำหรับ{\wbr}ใช้{\wbr}เป็น{\wbr}ตัว{\wbr}นับ{\wbr}
ค{\wbr}ลา{\wbr}ส{\wbr}ดังกล่าว{\wbr}ไม่{\wbr}ได้{\wbr}มี{\wbr}ความ{\wbr}ซับซ้อน{\wbr}ใน{\wbr}การ{\wbr}เขียน{\wbr}จึง{\wbr}เป็น{\wbr}ตัวอย่าง{\wbr}ที่{\wbr}ดี{\wbr}ใน{\wbr}การ{\wbr}เริ่มต้น{\wbr}

ใน{\wbr}การ{\wbr}ออกแบบ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}นั้น เรา{\wbr}จำเป็น{\wbr}จะ{\wbr}ต้อง{\wbr}พิจารณา{\wbr}ส่วน{\wbr}ที่{\wbr}ผู้ใช้{\wbr}จะ{\wbr}เรียก{\wbr}ใช้{\wbr}งาน{\wbr}ก่อน{\wbr}
ฟังก์ชัน{\wbr}สมาชิก{\wbr}ใน{\wbr}กลุ่ม{\wbr}นี้{\wbr}จะ{\wbr}เป็น{\wbr}อิน{\wbr}เทอร์เฟส{\wbr}ของ{\wbr}วัตถุ{\wbr}ใน{\wbr}ค{\wbr}ลา{\wbr}ส ที่{\wbr}ผู้ใช้{\wbr}งาน{\wbr}จะ{\wbr}เรียก{\wbr}ใช้{\wbr}
อิน{\wbr}เทอร์เฟส{\wbr}ของ{\wbr}ตัว{\wbr}นับ{\wbr}นั้น{\wbr}ไม่{\wbr}ซับซ้อน ดัง{\wbr}แสดง{\wbr}ใน{\wbr}รายการ{\wbr}ด้าน{\wbr}ล่าง{\wbr}
\begin{itemize}
\item Init($z$) -- กำหนด{\wbr}ค่า{\wbr}เริ่มต้น{\wbr}ใหักับ{\wbr}ตัว{\wbr}นับ โดย{\wbr}ให้{\wbr}มี{\wbr}ค่า{\wbr}เท่า{\wbr}กับ $z$
\item Inc() -- เพิ่ม{\wbr}ค่าตัว{\wbr}นับ{\wbr}ขึ้น 1
\item Get() -- คืน{\wbr}ค่า{\wbr}ปัจจุบัน{\wbr}ของ{\wbr}ตัว{\wbr}นับ{\wbr}
\end{itemize}

สังเกต{\wbr}ว่า{\wbr}โดย{\wbr}ทั่วไป{\wbr}แล้ว เรา{\wbr}มัก{\wbr}กำหนด{\wbr}ให้{\wbr}ตัว{\wbr}นับ{\wbr}มี{\wbr}ค่า{\wbr}เริ่มต้น{\wbr}เป็น 0
จึง{\wbr}เป็น{\wbr}การ{\wbr}เหมาะสม{\wbr}ที่{\wbr}จะ{\wbr}เพิ่ม{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ที่ทำงาน{\wbr}ดังกล่าว{\wbr}ไว้{\wbr}ด้วย{\wbr}
\begin{itemize}
\item Init --- กำหนด{\wbr}ค่า{\wbr}เริ่มต้น{\wbr}ให้{\wbr}กับ{\wbr}ตัว{\wbr}นับ โดย{\wbr}ให้{\wbr}มี{\wbr}ค่า{\wbr}เท่า{\wbr}กับ 0
\end{itemize}

เรา{\wbr}จะ{\wbr}นิยาม{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ดังกล่าว{\wbr}ใน{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-counter} สมาชิก{\wbr}ข้อมูล{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส
{\ct counter} มี{\wbr}เพียงแค่{\wbr}ค่าตัว{\wbr}นับ{\wbr}ที่{\wbr}นับ{\wbr}ได้ {\ct c} เนื่องจาก{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}นี้{\wbr}สั้น{\wbr}
เรา{\wbr}จึง{\wbr}นิยาม{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}เหล่านี้{\wbr}ไว้{\wbr}ภายใน{\wbr}การ{\wbr}นิยาม{\wbr}ค{\wbr}ลา{\wbr}ส
สำหรับ{\wbr}ฟังก์ชัน{\wbr}ที่{\wbr}นิยาม{\wbr}ภายใน{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}เหล่านี้ คอม{\wbr}ไพล{\wbr}เลอร์{\wbr}ภาษา C++ จะ{\wbr}แปลง{\wbr}ให้{\wbr}เป็น{\wbr}ฟังก์ชัน{\wbr}แบบ{\wbr}
inline โดย{\wbr}อัตโนมัติ{\wbr}

สังเกต{\wbr}การ{\wbr}ประกาศ{\wbr}อาร์กิวเมนท์{\wbr}ปริยาย{\wbr}ใน{\wbr}ฟังก์ชัน{\wbr}สมาชิก {\ct counter::init}
ถ้า{\wbr}มี{\wbr}การ{\wbr}เรียก{\wbr}คำสั่ง{\wbr}ที่{\wbr}ไม่{\wbr}ได้{\wbr}ระบุ{\wbr}ค่า{\wbr}พารามิเตอร์ {\ct z} จะ{\wbr}เปรียบ{\wbr}เสมือน{\wbr}ส่ง{\wbr}ค่า {\ct 0}
เป็น{\wbr}อาร์กิวเมนท์  

ใน{\wbr}ค{\wbr}ลา{\wbr}ส เรา{\wbr}นิยม{\wbr}ประกาศ{\wbr}สมาชิก{\wbr}ที่{\wbr}เป็น{\wbr}สาธารณะ{\wbr}ก่อน{\wbr}
เพราะ{\wbr}ข้อมูล{\wbr}ส่วน{\wbr}อิน{\wbr}เทอร์เฟส{\wbr}จะ{\wbr}เป็น{\wbr}สิ่ง{\wbr}สำคัญ{\wbr}กว่า{\wbr}สำหรับ{\wbr}ผู้{\wbr}ที่{\wbr}นำ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ของ{\wbr}เรา{\wbr}ไป{\wbr}ใช้{\wbr}

\latintext
\begin{codelist}{C++}{caption={\thaitext นิยาม{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส {\ct counter}\latintext},label=code:abs-counter}
class counter {
public:
  void init(int z=0) { c = z; }
  void inc() { ++c; }
  int get() { return c; }
private:
  int c;
};
\end{codelist}
\thaitext

\subsection{ตัว{\wbr}สร้าง: constructor}
ฟังก์ชัน{\wbr}สมาชิก {\ct counter::init} ทำ{\wbr}หน้าที่{\wbr}เฉพาะ คือ{\wbr}กำหนด{\wbr}ค่า{\wbr}เริ่มต้น{\wbr}ให้{\wbr}กับ{\wbr}วัตถุ{\wbr}ใน{\wbr}ค{\wbr}ลา{\wbr}ส
{\ct counter}

\begin{quiz}{}
ถ้า{\wbr}เรา{\wbr}ลืม{\wbr}เรียก{\wbr}ฟังก์ชัน {\ct init} ก่อน{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}ตัว{\wbr}นับ{\wbr}จะ{\wbr}เกิด{\wbr}อะไร{\wbr}ขึ้น?
\end{quiz}

สังเกต{\wbr}ว่า ระหว่าง{\wbr}ที่{\wbr}เรา{\wbr}ประกาศ{\wbr}ตัวแปร จนถึง{\wbr}ก่อน{\wbr}ที่{\wbr}จะ{\wbr}เรียก{\wbr}ใช้{\wbr}ฟังก์ชัน {\ct init} นั้น{\wbr}
สถานะ{\wbr}ของ{\wbr}วัตถุ{\wbr}นั้น{\wbr}เป็น{\wbr}สถานะ{\wbr}ที่{\wbr}ไม่{\wbr}มี{\wbr}ความหมาย เนื่องจาก{\wbr}ยัง{\wbr}ไม่{\wbr}มี{\wbr}การ{\wbr}กำหนด{\wbr}ค่า \ \ ใน{\wbr}ภาษา{\wbr}
C++ เรา{\wbr}สามารถ{\wbr}กำหนด{\wbr}ฟังก์ชัน{\wbr}สมาชิกพิเศษ{\wbr}ให้{\wbr}ทำงาน{\wbr}ทันที{\wbr}
เมื่อ{\wbr}มี{\wbr}การ{\wbr}ประกาศใช้{\wbr}งาน{\wbr}วัตถุ{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}นั้น ๆ  ฟังก์ชัน{\wbr}นี้{\wbr}จะ{\wbr}ทำ{\wbr}หน้าที่{\wbr}เหมือน{\wbr}กับ{\wbr}ฟังก์ชัน {\ct init}  แต่{\wbr}เรา{\wbr}จะ{\wbr}สามารถ{\wbr}รับประกัน{\wbr}ได้{\wbr}ว่า{\wbr}เมื่อ{\wbr}เรา{\wbr}นิยาม{\wbr}วัตถุ{\wbr}แล้ว วัตถุ{\wbr}นั้น{\wbr}จะ{\wbr}อยู่{\wbr}ใน{\wbr}สภาพ{\wbr}ที่ ``พร้อม{\wbr}ใช้{\wbr}งาน'' ทันที{\wbr}

ฟังก์ชัน{\wbr}ดังกล่าว เรียก{\wbr}ว่า{\em ตัว{\wbr}สร้าง} ({\em constructor})
โดย{\wbr}เรา{\wbr}สามารถ{\wbr}ระบุ{\wbr}ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}โดย{\wbr}ตั้ง{\wbr}ชื่อ{\wbr}ให้{\wbr}เหมือน{\wbr}กับ{\wbr}ชื่อ{\wbr}ค{\wbr}ลา{\wbr}ส
ตัวอย่าง{\wbr}ของ{\wbr}การ{\wbr}ประกาศ{\wbr}ตัว{\wbr}สร้าง{\wbr}
และ{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}แสดง{\wbr}ใน{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-counter-cons} \ ใน{\wbr}โปรแกรม{\wbr}ดังกล่าว{\wbr}
เมื่อ{\wbr}เรา{\wbr}ประกาศ{\wbr}วัตถุ {\ct a} และ {\ct b} ฟังก์ชัน{\wbr}สมาชิก {\ct counter::counter}
จะ{\wbr}ถูก{\wbr}เรียก{\wbr}ใช้{\wbr}งาน{\wbr}

\latintext
\begin{codelist}{C++}{caption={\thaitext นิยาม{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส {\ct counter} ที่{\wbr}ใช้{\wbr}ตัว{\wbr}สร้าง และ{\wbr}ตัวอย่าง{\wbr}การ{\wbr}ใช้{\wbr}งาน\latintext},label=code:abs-counter-cons}
class counter {
public:
  counter(int z=0) { c = z; }
  void inc() { ++c; }
  int get() { return c; }
private:
  int c;
};

  //...
  counter a, b(10);
  cout << a.get() << endl;    // outputs 0
  b.inc(); a.inc();
  cout << b.get() << endl;    // outputs 11
  cout << a.get() << endl;    // outputs 1
\end{codelist}
\thaitext

สังเกต{\wbr}ว่า{\wbr}ภายใน{\wbr}ตัว{\wbr}สร้าง {\ct counter::counter} จริง ๆ
แล้ว{\wbr}สิ่ง{\wbr}ที่{\wbr}เรา{\wbr}ทำ{\wbr}ก็{\wbr}เป็น{\wbr}การ{\wbr}สร้าง{\wbr}ตัวแปร {\ct c} นั่นเอง{\wbr}
เรา{\wbr}สามารถ{\wbr}ระบุ{\wbr}ความ{\wbr}ตั้งใจ{\wbr}ดังกล่าว{\wbr}ให้{\wbr}ชัดเจน{\wbr}โดย{\wbr}ระบุ{\wbr}คำสั่ง{\wbr}ดังกล่าว{\wbr}ให้{\wbr}เป็น{\wbr}การ{\wbr}เรียก{\wbr}ตัว{\wbr}สร้าง{\wbr}ของ{\wbr}
{\ct c} ดัง{\wbr}ส่วน{\wbr}ของ{\wbr}โปรแกรม{\wbr}ด้าน{\wbr}ล่าง{\wbr}นี้ \ เรา{\wbr}จะ{\wbr}ได้{\wbr}เห็น{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}ใน{\wbr}ลักษณะ{\wbr}นี้{\wbr}ต่อ ๆ ไป{\wbr}

\latintext
\begin{codelist}{C++}{}
  //...
  counter(z=0) : c(z) {}
\end{codelist}
\thaitext

ข้อ{\wbr}ควร{\wbr}ระวัง{\wbr}ใน{\wbr}การ{\wbr}ใช้{\wbr}การ{\wbr}กำหนด{\wbr}ค่า{\wbr}ลักษณะ{\wbr}นี้{\wbr}คือ{\wbr}
สมาชิก{\wbr}จะ{\wbr}ได้{\wbr}รับ{\wbr}การ{\wbr}กำหนด{\wbr}ค่า{\bf ตาม{\wbr}ลำดับ{\wbr}ที่{\wbr}นิยาม}ใน{\wbr}ค{\wbr}ลา{\wbr}ส
ไม่{\wbr}ใช่{\wbr}ตาม{\wbr}ลำดับ{\wbr}ที่{\wbr}เรา{\wbr}เขียน{\wbr}ใน{\wbr}รายการ{\wbr}กำหนด{\wbr}ค่า{\wbr}เริ่มต้น{\wbr}

\subsection{ค{\wbr}ลา{\wbr}ส {\ct list}}

เรา{\wbr}สามารถ{\wbr}ปรับ{\wbr}การ{\wbr}นิยาม{\wbr}โครงสร้าง {\ct list} ให้{\wbr}ซ่อน{\wbr}สมาชิก {\ct items} และ {\ct
  size} ได้{\wbr}ดัง{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-class-list}
สังเกต{\wbr}ว่า{\wbr}เรา{\wbr}เปลี่ยน{\wbr}ไป{\wbr}นิยาม{\wbr}ค{\wbr}ลา{\wbr}ส และ{\wbr}ประกาศ{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ต่าง ๆ แบบ {\ct public}

เรา{\wbr}ต้องการ{\wbr}ให้{\wbr}ผู้ใช้{\wbr}สามารถ{\wbr}เข้าถึง{\wbr}ขนาด{\wbr}ของ{\wbr}รายการ{\wbr}ได้ เรา{\wbr}จึง{\wbr}สร้าง{\wbr}ฟังก์ชัน{\wbr}สมาชิก {\ct
  list::size} สังเกต{\wbr}ว่า{\wbr}ชื่อดัง{\wbr}กล่าว{\wbr}ตรง{\wbr}กับ{\wbr}ชื่อ{\wbr}ของ{\wbr}ตัวแปร{\wbr}ที่{\wbr}เรา{\wbr}เคย{\wbr}ใช้{\wbr}
เพื่อ{\wbr}แก้{\wbr}ปัญหา{\wbr}ดังกล่าว{\wbr}เรา{\wbr}อาจ{\wbr}จะ{\wbr}ใช้{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}เป็น {\ct list::get\_size}
อย่างไรก็ตาม เรา{\wbr}ต้องการ{\wbr}ทำ{\wbr}ให้{\wbr}อิน{\wbr}เทอร์เฟส{\wbr}เรียบ{\wbr}ง่าย ดังนั้น{\wbr}เรา{\wbr}จะ{\wbr}คง{\wbr}อิน{\wbr}เทอร์เฟส{\wbr}เป็น {\ct
  list::size} ไว้ แต่{\wbr}จะ{\wbr}เปลี่ยน{\wbr}ชื่อ{\wbr}สมาชิก{\wbr}ส่วนตัว{\wbr}แทน{\wbr}

หนังสือ{\wbr}เล่ม{\wbr}นี้{\wbr}จะ{\wbr}ทำ{\wbr}ตาม{\wbr}คำแนะนำ{\wbr}ใน{\wbr}การ{\wbr}ตั้ง{\wbr}ชื่อ{\wbr}สมาชิก{\wbr}ส่วนตัว โดย{\wbr}จะ{\wbr}ตาม{\wbr}ชื่อ{\wbr}ด้วย{\wbr}เครื่องหมาย{\wbr}ขีด{\wbr}ล่าง{\wbr}
นั่น{\wbr}คือ{\wbr}เรา{\wbr}จะ{\wbr}เปลี่ยน{\wbr}ชื่อ{\wbr}จาก {\ct items} และ {\ct size} เป็น {\ct items\_} และ{\wbr}
{\ct size\_}

สังเกต{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}ตัว{\wbr}สร้าง{\wbr}เพื่อ{\wbr}กำหนด{\wbr}ค่า{\wbr}เริ่มต้น{\wbr}ให้{\wbr}กับ{\wbr}ตัวแปร {\ct size\_}
เรา{\wbr}ได้{\wbr}ย้าย{\wbr}นิยาม{\wbr}ของ{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ที่{\wbr}เกี่ยวกับ{\wbr}ตัว{\wbr}วิ่ง{\wbr}มา{\wbr}นิยาม{\wbr}ภายใน{\wbr}การ{\wbr}นิยาม{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}เพราะว่า{\wbr}เป็น{\wbr}ฟังก์ชัน{\wbr}ที่{\wbr}สั้น{\wbr}
\ ส่วน{\wbr}การ{\wbr}นิยาม{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}อื่น ๆ ของ{\wbr}โครงสร้าง{\wbr}นั้น{\wbr}ไม่{\wbr}มี{\wbr}การ{\wbr}เปลี่ยนแปลง{\wbr}
ยกเว้น{\wbr}การ{\wbr}อ้าง{\wbr}สมาชิก {\ct items\_} และ {\ct size\_}

\begin{figure}
\latintext
\begin{codelist}{C++}{caption={\thaitext นิยาม{\wbr}ค{\wbr}ลา{\wbr}ส {\ct list}\latintext},label=code:abs-class-list}
class list {
public:
  typedef int* iterator;

  list() : size_(0) {}

  int size() { return size_; }
  iterator begin() { return &items_[0]; }
  iterator end() { return &items_[size_]; }

  iterator find(int x);
  iterator append(int x);
  void del(iterator p);
  void insert_after(iterator p, int x);

private:
  int items_[max_list_size];
  int size_;
};
\end{codelist}
\thaitext
\end{figure}

\section{รายการ{\wbr}บน{\wbr}อาร์เรย์{\wbr}ที่{\wbr}เปลี่ยน{\wbr}ขนาด{\wbr}ได้}
ค{\wbr}ลา{\wbr}ส {\ct list} ที่{\wbr}เรา{\wbr}พัฒนา{\wbr}ขึ้น{\wbr}เก็บ{\wbr}ข้อมูล{\wbr}บน{\wbr}อาร์เรย์{\wbr}ที่{\wbr}มี{\wbr}ขนาด{\wbr}เท่า{\wbr}กับ{\wbr}ค่าคงที่ {\ct
  max\_list\_size} ใน{\wbr}ส่วน{\wbr}นี้{\wbr}เรา{\wbr}จะ{\wbr}ปรับปรุง{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ดังกล่าว{\wbr}
ให้{\wbr}ผู้ใช้{\wbr}สามารถ{\wbr}ระบุ{\wbr}ขนาด{\wbr}ของ{\wbr}อาร์เรย์{\wbr}ที่{\wbr}ต้องการ{\wbr}ใช้ได้{\wbr}เมื่อ{\wbr}เริ่ม{\wbr}สร้าง{\wbr}
\ \ การ{\wbr}ปรับปรุง{\wbr}นี้{\wbr}จะ{\wbr}ทำ{\wbr}ให้{\wbr}เรา{\wbr}ได้{\wbr}ศึกษา{\wbr}ความ{\wbr}สามารถ{\wbr}อื่น ๆ ของ{\wbr}ภาษา C++

\begin{quiz}{}
เรา{\wbr}จะ{\wbr}ต้อง{\wbr}ปรับ{\wbr}ตัว{\wbr}สร้าง{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส list อย่างไร?
\end{quiz}

แทน{\wbr}ที่{\wbr}เรา{\wbr}จะ{\wbr}ใช้{\wbr}อาร์เรย์ เรา{\wbr}จะ{\wbr}ใช้{\wbr}พอยน์เตอร์{\wbr}ไป{\wbr}ยัง {\ct int}
ชี้{\wbr}ไป{\wbr}ยัง{\wbr}อาร์เรย์{\wbr}ที่{\wbr}เรา{\wbr}จะ{\wbr}จอง{\wbr}ให้{\wbr}มี{\wbr}ขนาด{\wbr}ตาม{\wbr}ที่{\wbr}ผู้ใช้{\wbr}ระบุ{\wbr}
เรา{\wbr}จะ{\wbr}ปรับ{\wbr}สมาชิก{\wbr}ส่วนตัว{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}และ{\wbr}ตัว{\wbr}สร้าง{\wbr}เป็น{\wbr}ดัง{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-list-adj-array}
สังเกต{\wbr}ว่า{\wbr}ฟังก์ชัน {\ct list:list} ที่{\wbr}เป็น{\wbr}ตัว{\wbr}สร้าง{\wbr}จะ{\wbr}รับ{\wbr}พารามิเตอร์ {\ct max\_size}
เพื่อ{\wbr}นำมา{\wbr}จอง{\wbr}อาร์เรย์ เรา{\wbr}ใส่{\wbr}ค่า{\wbr}ปริยาย{\wbr}ของ{\wbr}ขนาด{\wbr}ของ{\wbr}อาร์เรย์{\wbr}ไว้{\wbr}เท่า{\wbr}กับ{\wbr}ค่าคงที่ {\ct
  default\_max\_list\_size}

\begin{figure}
\latintext
\begin{codelist}{C++}{caption={\thaitext นิยาม{\wbr}สมาชิก{\wbr}ส่วนตัว และ{\wbr}ตัว{\wbr}สร้าง{\wbr}ของ{\wbr}รายการ{\wbr}ที่{\wbr}เลือก{\wbr}ขนาด{\wbr}อาร์เรย์{\wbr}ได้\latintext},label=code:abs-list-adj-array}
const int default_max_list_size = 1000;

class list {
public:
  list(int max_size=default_max_list_size);
  // ... 
private:
  int* items_;
  int size_;
  int max_size_;
};

list::~list(int max_size)
  : size_(0), max_size_(max_size) 
{
  items_ = new int[max_size_];
}
\end{codelist}
\thaitext
\end{figure}

\begin{quiz}{}
สังเกต{\wbr}ว่า{\wbr}เรา{\wbr}กำหนด{\wbr}ค่าคงที่ {\ct default\_max\_list\_size} ไว้{\wbr}ก่อน{\wbr}การ{\wbr}นิยาม{\wbr}ค{\wbr}ลา{\wbr}ส
ถ้า{\wbr}เรา{\wbr}ประกาศ{\wbr}ค่าคงที่{\wbr}ดังกล่าว{\wbr}ไว้{\wbr}ภายใน{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}จะ{\wbr}เป็น{\wbr}อย่างไร?
ทดลอง{\wbr}ปรับ{\wbr}โปรแกรม{\wbr}และ{\wbr}พิจารณา{\wbr}ข้อผิดพลาด{\wbr}ที่{\wbr}คอม{\wbr}ไพ{\wbr}เลอร์{\wbr}แจ้ง ทำไม{\wbr}จึง{\wbr}เกิด{\wbr}ปัญหา{\wbr}นั้น?
\end{quiz}

ใน{\wbr}โปรแกรม{\wbr}ที่{\wbr}เรา{\wbr}เขียน{\wbr}ขึ้น เมื่อ{\wbr}เรา{\wbr}ประกาศ{\wbr}วัตถุ{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส {\ct list}
ตัว{\wbr}สร้าง{\wbr}จะ{\wbr}จอง{\wbr}เนื้อที่{\wbr}หน่วยความจำ{\wbr}เป็น{\wbr}เนื้อที่{\wbr}อาร์เรย์{\wbr}และ{\wbr}กำหนด{\wbr}ให้{\wbr}พอยน์เตอร์ {\ct items\_}
ชี้{\wbr}ไป{\wbr}ที่{\wbr}อาร์เรย์{\wbr}นั้น \ อย่างไรก็ตาม{\wbr}เมื่อ{\wbr}วัตถุ{\wbr}นั้น{\wbr}หมด{\wbr}ขอบเขต{\wbr}การ{\wbr}ใช้{\wbr}งาน{\wbr}แล้ว{\wbr}
ถ้า{\wbr}เรา{\wbr}ไม่{\wbr}ได้{\wbr}ดำเนินการ{\wbr}อะไร จะ{\wbr}ไม่{\wbr}มี{\wbr}การ{\wbr}คืน{\wbr}หน่วยความจำ{\wbr}คืน{\wbr}กลับ{\wbr}ให้{\wbr}ระบบ{\wbr}
ทำ{\wbr}ให้{\wbr}เกิด{\wbr}สภาวะ{\wbr}ที่{\wbr}เรียก{\wbr}ว่า{\wbr}หน่วยความจำ{\wbr}รั่ว (memory leak) \ เพื่อ{\wbr}หลีกเลี่ยง{\wbr}ปัญหา{\wbr}ดังกล่าว{\wbr}
ถ้า{\wbr}เรา{\wbr}จอง{\wbr}หน่วยความจำ{\wbr}เมื่อ{\wbr}เรา{\wbr}สร้าง{\wbr}วัตถุ เรา{\wbr}จะ{\wbr}ต้อง{\wbr}คืน{\wbr}หน่วยความจำ{\wbr}ก่อน{\wbr}ที่{\wbr}วัตถุ{\wbr}นั้น{\wbr}ถูก{\wbr}ทำลาย{\wbr}
เรา{\wbr}จะ{\wbr}ทำ{\wbr}โดย{\wbr}เขียน{\wbr}ฟังก์ชัน{\wbr}พิเศษ{\wbr}ที่{\wbr}เรียก{\wbr}ว่า{\wbr}ตัว{\wbr}ทำลาย{\wbr}

\subsection{ตัว{\wbr}ทำลาย (destructor), ตัว{\wbr}สร้าง{\wbr}สำหรับ{\wbr}การ{\wbr}คัดลอก (copy constructor), และ{\wbr}ฟังก์ชัน{\wbr}กำหนด{\wbr}ค่า (assignment operator)}
ค{\wbr}ลา{\wbr}ส{\wbr}ใน{\wbr}ภาษา C++ สามารถ{\wbr}ระบุ{\wbr}ฟังก์ชัน{\wbr}พิเศษ{\wbr}เรียก{\wbr}ว่า{\em ตัว{\wbr}ทำลาย} ที่{\wbr}ทำ{\wbr}หน้าที่{\wbr}เก็บกวาด{\wbr}
เช่น คือ{\wbr}ทรัพยากร{\wbr}ที่{\wbr}ได้{\wbr}จอง{\wbr}ไว้ ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}จะ{\wbr}ถูก{\wbr}เรียก{\wbr}โดย{\wbr}อัตโนมัติ{\wbr}ก่อน{\wbr}ที่{\wbr}วัตถุ{\wbr}จะ{\wbr}ถูก{\wbr}ทำลาย{\wbr}
ตัว{\wbr}ทำลาย จะ{\wbr}มี{\wbr}ชื่อ{\wbr}เหมือน{\wbr}กับ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}แต่{\wbr}ขึ้นต้น{\wbr}ด้วย {\ct\char`\~} (เครื่องหมาย tilde
$\sim$) เช่น {\ct list::\char`\~list}

เรา{\wbr}จะ{\wbr}ประกาศ{\wbr}ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}ใน{\wbr}นิยาม{\wbr}ค{\wbr}ลา{\wbr}ส
และ{\wbr}เขียน{\wbr}ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}ได้{\wbr}ดัง{\wbr}โปรแกรม~\ref{code:abs-list-destructor}

\begin{figure}
\latintext
\begin{codelist}{C++}{caption={\thaitext ตัว{\wbr}ทำลาย{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส {\ct list}\latintext},label=code:abs-list-destructor}
class list {
public:
  //...
  list(int max_size=default_max_list_size);
  ~list();
  //...
};

list::~list()
{
  delete [] items_;
}
\end{codelist}
\thaitext
\end{figure}

อย่างไรก็ตาม ค{\wbr}ลา{\wbr}ส {\ct list} ที่{\wbr}เรา{\wbr}เขียน{\wbr}ขึ้น ยัง{\wbr}มี{\wbr}การ{\wbr}ทำงาน{\wbr}ที่{\wbr}ผิดพลาด{\wbr}อยู่{\wbr}
ทั้งนี้{\wbr}เนื่องมาจาก{\wbr}พฤติกรรม{\wbr}มาตรฐาน{\wbr}ของ{\wbr}การ{\wbr}คัดลอก{\wbr}วัตถุ เพื่อให้{\wbr}เห็น{\wbr}การ{\wbr}ทำงาน{\wbr}ชัดเจน{\wbr}
เรา{\wbr}จะ{\wbr}ปรับ{\wbr}ตัว{\wbr}สร้าง{\wbr}และ{\wbr}ตัว{\wbr}ทำลาย{\wbr}ให้{\wbr}พิมพ์{\wbr}ข้อความ{\wbr}ว่า {\ct "Constructor called"} และ{\wbr}
{\ct "Destructor called"} ตาม{\wbr}ด้วย{\wbr}ตำแหน่ง{\wbr}ใน{\wbr}หน่วยความจำ{\wbr}ของ{\wbr}สมาชิก {\ct items}

พิจารณา{\wbr}โปรแกรม{\wbr}ด้าน{\wbr}ล่าง{\wbr}นี้{\wbr}
\latintext
\begin{codelist}{C++}{}
int main()
{
  list a, b;

  a.append(1);
  b = a;
  b.append(2);
}
\end{codelist}
\thaitext

เมื่อ{\wbr}โปรแกรม{\wbr}ทำงาน ให้{\wbr}ผลลัพธ์{\wbr}ดัง{\wbr}ด้าน{\wbr}ล่าง{\wbr}
{\latintext
\begin{verbatim}
Constructor called 0x9786008
Constructor called 0x9786fb0
Destructor called 0x9786008
Destructor called 0x9786008
\end{verbatim}
}
ใน{\wbr}หลาย ๆ ระบบปฏิบัติการ{\wbr}โปรแกรม{\wbr}จะ{\wbr}ถูก{\wbr}ปิด{\wbr}ลง{\wbr}เพราะ{\wbr}เกิด{\wbr}ข้อผิดพลาด{\wbr}

\begin{quiz}{}
ปัญหา{\wbr}ดังกล่าว{\wbr}เกิด{\wbr}ขึ้น{\wbr}เนื่องจาก{\wbr}อะไร?

(คำ{\wbr}ใบ้: พิจารณา{\wbr}ตำแหน่ง{\wbr}ของ{\wbr}หน่วยความจำ{\wbr}ของ {\ct items\_} เมื่อ{\wbr}มี{\wbr}การ{\wbr}เรียก{\wbr}ตัว{\wbr}ทำลาย{\wbr}
\end{quiz}

ค{\wbr}ลา{\wbr}ส{\wbr}ใน C++ มี{\wbr}ฟังก์ชัน{\wbr}พิเศษ{\wbr}สำหรับ{\wbr}จัดการ{\wbr}กับ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}มากมาย เช่น การ{\wbr}กำหนด{\wbr}ค่า{\wbr}เริ่มต้น การ{\wbr}ทำลาย{\wbr}
และ{\wbr}การ{\wbr}กำหนด{\wbr}ค่า{\wbr}ผ่าน{\wbr}ทาง{\wbr}เครื่องหมาย{\wbr}เท่า{\wbr}กับ เป็นต้น ถ้า{\wbr}เรา{\wbr}ไม่{\wbr}ระบุ{\wbr}ฟังก์ชัน{\wbr}เล่า{\wbr}นี้ C++
จะ{\wbr}จัดการ{\wbr}ดำเนินการ{\wbr}ให้{\wbr}เรา{\wbr}อัตโนมัติ ซึ่ง{\wbr}โดยมาก{\wbr}แล้ว{\wbr}ก็{\wbr}จะ{\wbr}ทำงาน{\wbr}ได้{\wbr}ถูกต้อง อย่างไรก็ตาม{\wbr}
ผล{\wbr}ที่{\wbr}ได้{\wbr}ก็{\wbr}ไม่{\wbr}ตรง{\wbr}กับ{\wbr}ที่{\wbr}เรา{\wbr}ต้องการ{\wbr}

โดย{\wbr}ทั่วไป{\wbr}แล้ว ถ้า{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ของ{\wbr}เรา{\wbr}มี{\wbr}สมาชิก{\wbr}ที่{\wbr}จอง{\wbr}ทรัพยากร เช่น{\wbr}จอง{\wbr}หน่วยความจำ{\wbr}
หรือ{\wbr}เปิด{\wbr}ปิด{\wbr}แฟ้มข้อมูล เมื่อ{\wbr}มี{\wbr}การ{\wbr}สร้าง{\wbr}หรือ{\wbr}ใช้{\wbr}งาน และ{\wbr}ใน{\wbr}ตัว{\wbr}ทำลาย{\wbr}มี{\wbr}การ{\wbr}คืน{\wbr}ทรัพยากร{\wbr}เหล่านั้น{\wbr}
มี{\wbr}ฟังก์ชัน{\wbr}พิเศษ{\wbr}สอง{\wbr}ฟังก์ชัน{\wbr}ที่{\wbr}เรา{\wbr}ต้อง{\wbr}เขียน เพื่อให้{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ทำงาน{\wbr}ได้{\wbr}ถูกต้อง{\wbr}

พิจารณา{\wbr}กรณี{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส {\ct counter} สมมติ{\wbr}เรา{\wbr}มี{\wbr}ตัวแปร {\ct a} และ {\ct b}
เป็น{\wbr}ข้อมูล{\wbr}ประเภท{\wbr}ดังกล่าว เมื่อ{\wbr}เรา{\wbr}สั่ง{\wbr}
\begin{center}
{\ct a = b;}
\end{center}
สิ่ง{\wbr}ที่{\wbr}เกิด{\wbr}ขึ้น{\wbr}ก็{\wbr}คือ{\wbr}มี{\wbr}ความ{\wbr}พยายาม{\wbr}จะ{\wbr}กำหนด{\wbr}ค่า{\wbr}ให้{\wbr}กับ{\wbr}วัตถุ {\ct a} ด้วย{\wbr}วัตถุ {\ct b}
เนื่องจาก{\wbr}ไม่{\wbr}มี{\wbr}ข้อมูล{\wbr}ระบุ{\wbr}ว่า{\wbr}ต้อง{\wbr}ดำเนินการ{\wbr}เช่น{\wbr}ใด ระบบ{\wbr}จะ{\wbr}คัดลอก{\wbr}ข้อมูล{\wbr}ของ{\wbr}ทุก ๆ สมาชิก{\wbr}ของ{\wbr}
{\ct b} ไป{\wbr}ยัง{\wbr}วัตถุ {\ct a}  สิ่ง{\wbr}ที่{\wbr}เกิด{\wbr}ขึ้น{\wbr}เหมือน{\wbr}กับ{\wbr}เรา{\wbr}สั่ง {\ct a.c = b.c}

\begin{quiz}{}
พิจารณา{\wbr}การ{\wbr}สั่ง {\ct a = b;} ใน{\wbr}กรณี{\wbr}ที่{\wbr}ตัวแปร{\wbr}ทั้ง{\wbr}สอง{\wbr}เป็น{\wbr}วัตถุ{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส {\ct list}
อะไร{\wbr}จะ{\wbr}เกิด{\wbr}ขึ้น?
\end{quiz}

เรา{\wbr}สามารถ{\wbr}เปลี่ยน{\wbr}การ{\wbr}ทำงาน{\wbr}ของ{\wbr}คำสั่ง{\wbr}ดังกล่าว{\wbr}ให้{\wbr}คัดลอก{\wbr}ข้อมูล{\wbr}ให้{\wbr}ถูกต้อง{\wbr}
ได้{\wbr}โดย{\wbr}เขียน{\wbr}ฟังก์ชัน{\wbr}กำหนด{\wbr}ค่า (assignment) ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}คือ{\wbr}ฟังก์ชัน{\wbr}โอ{\wbr}เปอเรเตอร์{\wbr}เท่า{\wbr}กับ{\wbr}
{\ct operator=}) นี่{\wbr}คือ{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}แรก{\wbr}ที่{\wbr}เรา{\wbr}ต้อง{\wbr}เขียน{\wbr}

พิจารณา{\wbr}โปรแกรม{\wbr}ตัวอย่าง{\wbr}ด้าน{\wbr}ล่าง{\wbr}นี้{\wbr}

\latintext
\begin{codelist}{C++}{}
void m(list a) { cout << a.size() << endl; }

main()
{
  list b;
  m(b);
  cout << "endding" << endl;
}
\end{codelist}
\thaitext

ผลลัพธ์{\wbr}ของ{\wbr}โปรแกรม{\wbr}ดังกล่าว{\wbr}เป็น{\wbr}ดัง{\wbr}ด้าน{\wbr}ล่าง{\wbr}
{\latintext
\begin{verbatim}
Constructor called0x839b008
0
Destructor called0x839b008
endding
Destructor called0x839b008
\end{verbatim}
}
จากนั้น{\wbr}โปรแกรม{\wbr}ก็{\wbr}เกิด{\wbr}ปัญหา{\wbr}และ{\wbr}ถูก{\wbr}ระบบปฏิบัติการ{\wbr}ปิด{\wbr}ไป{\wbr}โดย{\wbr}อัตโนมัติ (crash)

\begin{quiz}{ความผิด{\wbr}พลาด{\wbr}ใน{\wbr}การ{\wbr}ส่ง{\wbr}พารามิเตอร์}
อธิบาย{\wbr}คร่าว ๆ ว่าความ{\wbr}ผิดพลาด{\wbr}ดังกล่าว{\wbr}เกิด{\wbr}ขึ้น{\wbr}ได้{\wbr}เพราะ{\wbr}อะไร?
\end{quiz}

เมื่อ{\wbr}เรา{\wbr}เรียก{\wbr}ฟังก์ชัน {\ct m} เรา{\wbr}ส่ง{\wbr}ตัวแปร {\ct b} เป็น{\wbr}อาร์กิวเมนท์ อย่างไรก็ตาม{\wbr}
เนื่องจาก{\wbr}พารามิเตอร์ {\ct a} เป็น{\wbr}การ{\wbr}ส่ง{\wbr}พารามิเตอร์{\wbr}แบบ by value ทำ{\wbr}ให้{\wbr}มี{\wbr}การ{\wbr}
`{\wbr}`{\wbr}สร้าง'' วัตถุ {\ct a} ขึ้น{\wbr}มา{\wbr}ใหม่{\wbr}จาก{\wbr}วัตถุ {\ct b}
โดย{\wbr}ใช้{\wbr}ตัว{\wbr}สร้าง{\wbr}ที่{\wbr}นิยม{\wbr}เรียก{\wbr}ว่า{\wbr}ตัว{\wbr}สร้าง{\wbr}สำหรับ{\wbr}การ{\wbr}คัดลอก (copy constructor)

เนื่องจาก{\wbr}เรา{\wbr}ไม่{\wbr}ได้{\wbr}เขียน{\wbr}วิธีการ{\wbr}สร้าง{\wbr}ดังกล่าว{\wbr}ไว้ ระบบ{\wbr}จึง{\wbr}สร้าง {\ct list}
ใหม่{\wbr}โดย{\wbr}การ{\wbr}คัดลอก{\wbr}ข้อมูล{\wbr}จาก{\wbr}ทุก ๆ สมาชิก{\wbr}ของ {\ct b} ไป{\wbr}ให้{\wbr}กับ{\wbr}วัตถุ{\wbr}ใหม่ 
ซึ่ง{\wbr}จะ{\wbr}ทำ{\wbr}ให้{\wbr}เกิด{\wbr}ปัญหา{\wbr}เช่นเดียวกับ{\wbr}กรณี{\wbr}ฟังก์ชัน{\wbr}โอ{\wbr}เปอเรเตอร์{\wbr}เท่า{\wbr}กับ{\wbr}

ดังนั้น{\wbr}เพื่อให้{\wbr}การ{\wbr}คัดลอก{\wbr}เป็น{\wbr}ไป{\wbr}ได้ เรา{\wbr}จะ{\wbr}ต้อง{\wbr}เขียน{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}
\begin{center}
{\ct list\& list::list(const list\& lst)}
\end{center}
เพื่อ{\wbr}สร้าง {\ct list} ใหม่{\wbr}จาก {\ct lst}
\ \ สังเกต{\wbr}ว่า{\wbr}การ{\wbr}ประกาศ{\wbr}ของ{\wbr}ตัว{\wbr}สร้าง{\wbr}สำหรับ{\wbr}การ{\wbr}คัดลอก{\wbr}จะ{\wbr}ต้อง{\wbr}อยู่{\wbr}ใน{\wbr}รูปแบบ{\wbr}เช่นนี้ นั่น{\wbr}คือ{\wbr}
รับ{\wbr}พารามิเตอร์{\wbr}แบบ reference (เพื่อ{\wbr}ไม่{\wbr}ให้{\wbr}เกิด{\wbr}การ{\wbr}คัดลอก{\wbr}ซ้อน) และ{\wbr}เป็น{\wbr}ข้อมูล{\wbr}ชนิด{\wbr}ค่าคงที่{\wbr}
เพื่อ{\wbr}รับประกัน{\wbr}ว่า{\wbr}จะ{\wbr}เกิด{\wbr}การ{\wbr}คัดลอก{\wbr}อย่างเดียว{\wbr}เท่านั้น{\wbr}ไม่{\wbr}มี{\wbr}การ{\wbr}แก้ไข{\wbr}ข้อ{\wbr}มุ{\wbr}ล{\wbr}ของ {\ct lst}
นี่{\wbr}คือ{\wbr}ฟังก์ชัน{\wbr}อีก{\wbr}ฟังก์ชัน{\wbr}ที่{\wbr}เรา{\wbr}ต้อง{\wbr}เขียน{\wbr}

ใน{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-list-copy-cons}
เรา{\wbr}จะ{\wbr}ประกาศ{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ทั้ง{\wbr}สอง ซึ่ง{\wbr}จะ{\wbr}เรียก{\wbr}ใช้{\wbr}งาน{\wbr}ฟังก์ชัน{\wbr}ส่วนตัว {\ct
  list::copy\_from} พร้อมกับ{\wbr}นิยาม{\wbr}ฟังก์ชัน{\wbr}ตัว{\wbr}สร้าง{\wbr}สำหรับ{\wbr}การ{\wbr}คัดลอก{\wbr}

\begin{figure}
\latintext
\begin{codelist}{C++}{caption={\thaitext การ{\wbr}ประกาศ{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}ที่{\wbr}เกี่ยวกับ{\wbr}การ{\wbr}คัดลอก\latintext},label=code:abs-list-copy-cons}
class list {
public:
  // ...
  list(const list& lst);
  list& operator=(const list& lst);
  // ...
private:
  // ...
  void copy_from(const list& lst);
};

void list::copy_from(const list& lst)
{
  size_ = lst.size_;
  max_size_ = lst.max_size_;
  items_ = new int[max_size_];
  for(int i=0; i<size_; ++i)
    items_[i] = lst.items_[i];
}

list::list(const list& lst)
{
  copy_from(lst);
}
\end{codelist}
\thaitext
\end{figure}

สำหรับ{\wbr}ฟังก์ชัน{\wbr}กำหนด{\wbr}ค่า{\wbr}นั้น{\wbr}จะ{\wbr}ซับซ้อน{\wbr}กว่า{\wbr}เล็กน้อย{\wbr}
ทั้งนี้เพราะ{\wbr}ว่า{\wbr}ผู้ใช้{\wbr}สามารถ{\wbr}สั่ง{\wbr}งาน{\wbr}คำสั่ง{\wbr}เช่น {\ct a=a;} ได้{\wbr}
\ เรา{\wbr}จึง{\wbr}ต้อง{\wbr}ระวัง{\wbr}ไม่{\wbr}คัดลอก{\wbr}ข้อมูล{\wbr}ใน{\wbr}กรณี{\wbr}ดังกล่าว{\wbr}

\begin{quiz}{}
สังเกต{\wbr}ว่า{\wbr}ฟังก์ชัน{\wbr}กำหนด{\wbr}ค่า{\wbr}จะ{\wbr}ต้อง{\wbr}คืน{\wbr}หน่วยความจำ{\wbr}ของ{\wbr}อาร์เรย์{\wbr}ที่{\wbr}จอง{\wbr}ไว้{\wbr}ก่อน{\wbr}
ถ้า{\wbr}เขียน{\wbr}โอ{\wbr}เปอเรเตอร์{\wbr}เท่า{\wbr}กับ{\wbr}ให้{\wbr}ทำงาน{\wbr}ใน{\wbr}ลักษณะ{\wbr}เดียวกับ{\wbr}ตัว{\wbr}สร้าง{\wbr}สำหรับ{\wbr}การ{\wbr}ค้{\wbr}ดล{\wbr}อก{\wbr}
จะ{\wbr}มี{\wbr}ผล{\wbr}อย่างไร{\wbr}ถ้า{\wbr}ผู้ใช้{\wbr}สั่ง {\ct a=a;} ?
\end{quiz}

เรา{\wbr}จะ{\wbr}ตรวจสอบ{\wbr}ได้{\wbr}อย่างไร?  ค{\wbr}ลา{\wbr}ส{\wbr}ใน{\wbr}ภาษา C++ จะ{\wbr}มี{\wbr}สมาชิกพิเศษ{\wbr}ชื่อ {\ct this}
ซึ่ง{\wbr}จะ{\wbr}เป็น{\wbr}พอยน์เตอร์{\wbr}ชี้{\wbr}ไป{\wbr}ที่{\wbr}วัตถุ{\wbr}ที่{\wbr}ฟังก์ชัน{\wbr}กำลัง{\wbr}ทำงาน{\wbr}อยู่ \ สมาชิก{\wbr}นี้{\wbr}มี{\wbr}ประโยชน์{\wbr}มาก{\wbr}ใน{\wbr}หลาย ๆ
กรณี แต่{\wbr}ใน{\wbr}ที่นี้{\wbr}เรา{\wbr}จะ{\wbr}ใช้{\wbr}เพื่อ{\wbr}ตรวจสอบ{\wbr}ว่า{\wbr}พารามิเตอร์ {\ct lst} เป็น{\wbr}วัตถุ{\wbr}เดียวกับ {\ct
  this} หรือเปล่า \ นอกจากนี้{\wbr}เรา{\wbr}ยัง{\wbr}ใช้ {\ct this}
ใน{\wbr}การ{\wbr}คืนตัว{\wbr}วัตถุ{\wbr}เอง{\wbr}เป็น{\wbr}ผลลัพธ์{\wbr}ของ{\wbr}โอ{\wbr}เปอเรเตอร์{\wbr}ด้วย{\wbr}
โปรแกรม{\wbr}แสดง{\wbr}ใน{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-list-assignment}

\begin{figure}
\latintext
\begin{codelist}{C++}{caption={\thaitext ฟังก์ชัน{\wbr}สำหรับ{\wbr}โอ{\wbr}เปอเรเตอร์{\wbr}เท่า{\wbr}กับ\latintext},label=code:abs-list-assignment}
list& list::operator=(const list& l)
{
  if(this == &l)
    return *this;

  delete [] items_;
  copy_from(l);
  return *this;
}
\end{codelist}
\thaitext
\end{figure}

สังเกต{\wbr}ว่า{\wbr}ฟังก์ชัน{\wbr}กำหนด{\wbr}ค่า{\wbr}คืน{\wbr}ค่า{\wbr}เป็น{\wbr}ข้อมูล{\wbr}ชนิด {\ct list\&} และ{\wbr}เรา{\wbr}คืน{\wbr}ค่า {\ct
  *this} แทน{\wbr}วัตถุ{\wbr}ที่{\wbr}ได้{\wbr}รับ{\wbr}ค่า{\wbr}ออก{\wbr}ไป เพื่อให้{\wbr}เรา{\wbr}สั่ง{\wbr}คำสั่ง{\wbr}เช่น {\ct
  (a=b).append(10); } ได้{\wbr}


\section{โครงสร้าง{\wbr}ข้อมูล{\wbr}สำหรับ{\wbr}ข้อมูล{\wbr}ชนิด{\wbr}ใด{\wbr}ก็ได้: แม่แบบ}
ที่{\wbr}ผ่าน{\wbr}มา{\wbr}เรา{\wbr}ได้{\wbr}พัฒนา{\wbr}โครงสร้าง{\wbr}ข้อมูล{\wbr}สำหรับ{\wbr}จัดการ{\wbr}กับ{\wbr}รายการ{\wbr}ที่{\wbr}มี{\wbr}ข้อมูล{\wbr}เป็น{\wbr}จำนวนเต็ม{\wbr}
โดย{\wbr}เก็บ{\wbr}ข้อมูล{\wbr}บน{\wbr}อาร์เรย์ อย่างไรก็ตาม{\wbr}ถ้า{\wbr}พิจารณา{\wbr}ให้{\wbr}ดี{\wbr}เรา{\wbr}จะ{\wbr}พบ{\wbr}ว่า{\wbr}โปรแกรม{\wbr}ที่{\wbr}เรา{\wbr}เขียน{\wbr}
ไม่{\wbr}จำเป็น{\wbr}ต้อง{\wbr}ทำงาน{\wbr}กับ {\ct int} เท่านั้น แต่{\wbr}สามารถ{\wbr}ทำงาน{\wbr}กับ{\wbr}ข้อมูล{\wbr}ชนิด{\wbr}อื่น ๆ ได้{\wbr}ด้วย{\wbr}

จาก{\wbr}โปรแกรม{\wbr}ที่{\wbr}เรา{\wbr}เขียน เรา{\wbr}จะ{\wbr}พิจารณา{\wbr}ว่า{\wbr}เรา{\wbr}ดำเนินการ{\wbr}อะไร{\wbr}กับ{\wbr}ข้อมูล{\wbr}ประเภท {\ct int}
ที่{\wbr}เรา{\wbr}เก็บ{\wbr}ใน{\wbr}รายการ{\wbr}บ้าง{\wbr}
\begin{itemize}
\item เรา{\wbr}สามารถ{\wbr}อาร์เรย์{\wbr}ของ {\ct int}
\item เรา{\wbr}กำหนด{\wbr}ค่า{\wbr}ให้{\wbr}กับ {\ct items\_}
\item เรา{\wbr}เปรียบเทียบ{\wbr}ข้อมูล{\wbr}ด้วย{\wbr}โอ{\wbr}เปอเรเตอร์ {\ct ==} (ใน{\wbr}ฟังก์ชัน {\ct list::find}
\end{itemize}
กระบวนการ{\wbr}เหล่านี้{\wbr}เป็น{\wbr}อิน{\wbr}เทอร์เฟส{\wbr}ของ{\wbr}วัตถุ{\wbr}ที่{\wbr}เรา{\wbr}จะ{\wbr}เก็บ{\wbr}ใน {\ct list} ที่{\wbr}โปรแกรม{\wbr}ของ{\wbr}
{\ct list} เรียก{\wbr}ใช้ ดังนั้น ถ้า{\wbr}เรา{\wbr}มี{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ใด ๆ ที่{\wbr}รองรับ{\wbr}กระบวนการ{\wbr}เหล่านี้{\wbr}
โปรแกรม{\wbr}ที่{\wbr}เรา{\wbr}เขียน{\wbr}ก็{\wbr}ควร{\wbr}จะ{\wbr}ทำงาน{\wbr}ด้วย{\wbr}ได้{\wbr}โดย{\wbr}ไม่{\wbr}เกิด{\wbr}ข้อผิดพลาด{\wbr}ระหว่าง{\wbr}การ{\wbr}คอมไพล์{\wbr}และ{\wbr}การ{\wbr}ทำงาน{\wbr}
แต่{\wbr}ผล{\wbr}ของ{\wbr}การ{\wbr}ทำงาน{\wbr}จะ{\wbr}ถูกต้อง{\wbr}หรือ{\wbr}ไม่{\wbr}ก็{\wbr}ขึ้น{\wbr}กับ{\wbr}ว่า{\wbr}กระบวนการ{\wbr}ต่าง ๆ ข้างต้น{\wbr}นี้{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}นั้น ๆ
ทำงาน{\wbr}ด้วย{\wbr}ความหมาย{\wbr}ตรง{\wbr}ตาม{\wbr}ที่{\wbr}เรา{\wbr}คาด{\wbr}ไว้{\wbr}หรือ{\wbr}ไม่{\wbr}

ภาษา C++ รองรับ{\wbr}การ{\wbr}เขียน{\wbr}โปรแกรม{\wbr}ที่ทำงาน{\wbr}ได้{\wbr}กับ{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ใด ๆ ก็ได้{\wbr}ผ่าน{\wbr}ทาง{\em แม่แบบ}
({\em template})
\ การ{\wbr}เขียน{\wbr}โปรแกรม{\wbr}ใน{\wbr}ลักษณะ{\wbr}ดังกล่าว{\wbr}นิยม{\wbr}เรียก{\wbr}ว่า{\wbr}การ{\wbr}โปรแกรม{\wbr}เชิง{\wbr}เจ{\wbr}เน{\wbr}อริ{\wbr}ค (generic
programming)

พิจารณา{\wbr}ตัวอย่าง{\wbr}ฟังก์ชัน {\ct my\_swap} ที่{\wbr}ทำ{\wbr}หน้าที่{\wbr}สลับ{\wbr}ค่า{\wbr}ของ {\ct
  int} แสดง{\wbr}ดัง{\wbr}ด้าน{\wbr}ล่าง{\wbr}นี้\footnote{เรา{\wbr}ตั้ง{\wbr}ชื่อ{\wbr}ฟังก์ชัน{\wbr}ว่า {\ct my\_swap}
  เพื่อ{\wbr}จะ{\wbr}ได้{\wbr}ไม่{\wbr}ซ้ำ{\wbr}กับ{\wbr}ฟังก์ชัน {\ct std::swap} ใน{\wbr}ไลบ{\wbr}รา{\wbr}รี{\wbr}มาตรฐาน}

\latintext
\begin{codelist}{C++}{}
void my_swap(int& a, int& b)
{
  int temp = a;  a = b;  b = temp;
}
\end{codelist}
\thaitext

เรา{\wbr}สามารถ{\wbr}เขียน{\wbr}ใหม่{\wbr}โดย{\wbr}ใช้{\wbr}แม่แบบ เพื่อให้{\wbr}ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}ทำงาน{\wbr}กับ{\wbr}ข้อมูล{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ใด ๆ ก็ได้{\wbr}
โดย{\wbr}เพิ่ม{\wbr}การ{\wbr}ระบุ{\wbr}ให้{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ของ{\wbr}ข้อมูล{\wbr}เป็น{\wbr}พารามิเตอร์{\wbr}ของ{\wbr}แม่แบบ ดัง{\wbr}แสดง{\wbr}ด้าน{\wbr}ล่าง{\wbr}

\latintext
\begin{codelist}{C++}{}
template <class T> 
void my_swap(T& a, T& b)
{
  T temp = a;  a = b;  b = temp;
}
\end{codelist}
\thaitext

ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}สามารถ{\wbr}ทำงาน{\wbr}กับ{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ใด ๆ ก็ได้ ที่{\wbr}รองรับ{\wbr}ฟังก์ชัน{\wbr}กำหนด{\wbr}ค่า{\wbr}
(นั่น{\wbr}รวม{\wbr}ไป{\wbr}ถึง{\wbr}ค{\wbr}ลา{\wbr}ส list ที่{\wbr}เรา{\wbr}เขียน{\wbr}ไว้{\wbr}ใน{\wbr}ส่วน{\wbr}ที่แล้ว)
สังเกต{\wbr}ว่า{\wbr}ฟังก์ชัน{\wbr}ดังกล่าว{\wbr}ถูก{\wbr}นิยาม{\wbr}โดย{\wbr}มี{\wbr}ชนิด{\wbr}ข้อมูล {\ct T} เป็น{\wbr}พารามิเตอร์{\wbr}ของ{\wbr}แม่แบบ{\wbr}
ใน{\wbr}การ{\wbr}เรียก{\wbr}ใช้{\wbr}งาน C++ จะ{\wbr}เลือก{\wbr}พารามิเตอร์ {\ct T} ให้{\wbr}โดย{\wbr}อัตโนมัติ ดัง{\wbr}แสดง{\wbr}ด้าน{\wbr}ล่าง{\wbr}

\latintext
\begin{codelist}{C++}{}
  int a = 10; int b = 100;
  my_swap(a,b);
  double ad = 10.7; double bd = 112.233;
  my_swap(ad,bd);
\end{codelist}
\thaitext

สิ่ง{\wbr}ที่{\wbr}เกิด{\wbr}ขึ้น{\wbr}เมื่อ{\wbr}เรา{\wbr}เรียก{\wbr}ใช้{\wbr}งาน{\wbr}แม่แบบ{\wbr}ก็{\wbr}คือ{\wbr}คอมไพล์{\wbr}เลอร์{\wbr}จะ{\wbr}สร้าง{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}หรือ{\wbr}ฟังก์ชัน{\wbr}เฉพาะเจาะจง{\wbr}
สำหรับ{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ที่{\wbr}เรา{\wbr}ระบุ{\wbr}เป็น{\wbr}พารามิเตอร์ จาก{\wbr}ตัวอย่าง{\wbr}ข้างต้น{\wbr}คอม{\wbr}ไพ{\wbr}เลอร์{\wbr}จะ{\wbr}สร้าง{\wbr}ฟังก์ชัน{\wbr}
{\ct my\_swap(int\&, int\&)} และ {\ct my\_swap(double\&, double\&)}
เพื่อ{\wbr}รองรับ{\wbr}การ{\wbr}เรียก{\wbr}ใช้{\wbr}งาน{\wbr}ฟังก์ชัน{\wbr}แม่แบบ{\wbr}แต่ละ{\wbr}ครั้ง{\wbr}

ค{\wbr}ลา{\wbr}ส {\ct list} สามารถ{\wbr}ปรับ{\wbr}เปลี่ยน{\wbr}ให้{\wbr}เป็น{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}แม่แบบ {\ct list}
ที่{\wbr}มี{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ของ{\wbr}ข้อมูล{\wbr}ใน{\wbr}รายการ{\wbr}เป็น{\wbr}พารามิเตอร์ ได้{\wbr}ไม่{\wbr}ยาก{\wbr}
ส่วน{\wbr}นิยาม{\wbr}แม่แบบ{\wbr}แสดง{\wbr}ใน{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-list-template-decl}
\ ฟังก์ชัน{\wbr}สมาชิก{\wbr}บาง{\wbr}ส่วน{\wbr}แสดง{\wbr}ใน{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-list-template-def}

\begin{figure}
\latintext
\begin{codelist}{C++}{caption={\thaitext ค{\wbr}ลา{\wbr}ส{\wbr}แม่แบบ {\ct list}\latintext},label=code:abs-list-template-decl}
const int default_max_list_size = 1000;

template<class T>
class list {
public:
  typedef T* iterator;

  list(int max_size=default_max_list_size);
  ~list();

  list(const list& lst);
  list& operator=(const list& lst);

  int size() { return size_; }
  iterator begin() { return &items_[0]; }
  iterator end() { return &items_[size_]; }

  iterator find(T x);
  iterator append(T x);
  void del(iterator p);
  void insert_after(iterator p, T x);

private:
  T* items_;
  int size_;
  int max_size_;

  void copy_from(const list& lst);
};
\end{codelist}
\thaitext
\end{figure}

ฟังก์ชัน{\wbr}สมาชิก{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}แม่แบบ{\wbr}สามารถ{\wbr}นิยาม{\wbr}ได้{\wbr}ไม่{\wbr}ต่าง{\wbr}จาก{\wbr}ฟังก์ชัน{\wbr}แม่แบบ {\ct my\_swap}
ที่{\wbr}เรา{\wbr}ได้{\wbr}เขียน{\wbr}มา{\wbr}แล้ว สังเกต{\wbr}ว่า{\wbr}เรา{\wbr}จะ{\wbr}นิยาม{\wbr}ฟังก์ชัน{\wbr}ไว้{\wbr}ภายใน{\wbr}ขอบเขต{\wbr}ของ {\ct
  template<class T>} และ{\wbr}ภายใน{\wbr}นั้น{\wbr}ก็{\wbr}จะ{\wbr}ใช้ {\ct T} ได้{\wbr}เหมือน{\wbr}เป็น{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ทั่วไป{\wbr}
นิยาม{\wbr}ของ{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}บาง{\wbr}ฟังก์ชัน{\wbr}แสดง{\wbr}ใน{\wbr}โปรแกรม{\wbr}ที่~\ref{code:abs-list-template-def}

ใน{\wbr}การ{\wbr}เขียน{\wbr}ดังกล่าว มี{\wbr}รายละเอียด{\wbr}เชิง{\wbr}เทคนิค{\wbr}เกี่ยวกับ การ{\wbr}ใช้{\wbr}งาน{\wbr}ชนิด{\wbr}ข้อมูล {\ct
  iterator} ที่{\wbr}เรา{\wbr}นิยาม{\wbr}ขึ้น{\wbr}ภายใน{\wbr}แม่แบบ {\ct list} \ ใน{\wbr}การ{\wbr}อ้าง{\wbr}ถึง {\ct
  list<T>::iterator} นั้น เรา{\wbr}จะ{\wbr}ต้อง{\wbr}ระบุ{\wbr}คีย์{\wbr}เวิร์ด {\ct typename}
นำหน้า{\wbr}เพื่อ{\wbr}บอก{\wbr}กับ{\wbr}คอม{\wbr}ไพ{\wbr}เลอร์{\wbr}ว่า{\wbr}สิ่ง{\wbr}ที่{\wbr}เรา{\wbr}อ้าง{\wbr}ถึง{\wbr}นั้น{\wbr}คือ{\wbr}แบบ{\wbr}ชนิด{\wbr}ข้อมูล ดัง{\wbr}แสดง{\wbr}ใน{\wbr}ฟังก์ชัน{\wbr}สมาชิก{\wbr}
{\ct append} ของ{\wbr}แม่แบบ {\ct list}
\ ผู้{\wbr}ที่{\wbr}สนใจ{\wbr}สามารถ{\wbr}อ่าน{\wbr}รายละเอียด{\wbr}เพิ่มเติม{\wbr}ได้{\wbr}ใน{\wbr}ส่วน{\wbr}ที่~\ref{section:abs-typename}


\begin{figure}
\latintext
\begin{codelist}{C++}{caption={\thaitext นิยาม{\wbr}ของ{\wbr}สมาชิก{\wbr}บาง{\wbr}ฟังก์ชัน{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}แม่แบบ {\ct list}\latintext},label=code:abs-list-template-def}
template<class T>
list<T>::list(int max_size)
  : size_(0), max_size_(max_size) 
{
  items_ = new T[max_size_];
}

template<class T>
list<T>::~list()
{
  delete [] items_;
}

template<class T>
typename list<T>::iterator list<T>::append(T v)
{
  if(size_ >= max_size_)
    throw "List overflow";
  items_[size_] = v;
  ++size_;
  return &items_[size_ - 1];
}
\end{codelist}
\thaitext
\end{figure}

\section{รายละเอียด{\wbr}เพิ่มเติม{\wbr}เกี่ยวกับ{\wbr}ภาษา C++}

ภาษา C++ มี{\wbr}รายละเอียด{\wbr}ปลีกย่อย{\wbr}เชิง{\wbr}เทคนิค{\wbr}มาก{\wbr}พอสมควร ใน{\wbr}ส่วน{\wbr}นี้{\wbr}เรา{\wbr}จะ{\wbr}สรุป{\wbr}บาง{\wbr}ประเด็น{\wbr}ที่{\wbr}สำคัญ{\wbr}ไว้{\wbr}

\subsection{สรุป{\wbr}ฟังก์ชัน{\wbr}สมาชิกพิเศษ}

ค{\wbr}ลา{\wbr}ส{\wbr}ใน{\wbr}ภาษา C++ มี{\wbr}ฟังก์ชัน{\wbr}สมาชิกพิเศษ{\wbr}หลาย{\wbr}ฟังก์ชัน{\wbr}ที่ทำงาน{\wbr}พิเศษ ใน{\wbr}บท{\wbr}นี้{\wbr}เรา{\wbr}ได้{\wbr}พิจารณา{\wbr}ฟังก์ชัน{\wbr}ดัง{\wbr}รายการ{\wbr}ต่อไปนี้ (เรา{\wbr}จะ{\wbr}เขียน{\wbr}ชื่อ{\wbr}ฟังก์ชัน{\wbr}โดย{\wbr}สมมติ{\wbr}ว่า{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ชื่อ {\ct myclass})
\begin{itemize}
\item {\ct myclass::myclass(...)} \\ ตัว{\wbr}สร้าง (constructor)
  ทำ{\wbr}หน้าที่{\wbr}ใน{\wbr}การ{\wbr}กำหนด{\wbr}ค่า{\wbr}เริ่มต้น{\wbr}ให้{\wbr}กับ{\wbr}วัตถุ จะ{\wbr}ถูก{\wbr}เรียก{\wbr}เมื่อ{\wbr}มี{\wbr}การ{\wbr}ประกาศ{\wbr}วัตถุ{\wbr}
  ตัว{\wbr}สร้าง{\wbr}อาจ{\wbr}จะ{\wbr}รับ{\wbr}พารามิเตอร์{\wbr}ที่{\wbr}จำเป็น แต่{\wbr}จะ{\wbr}ไม่{\wbr}คืน{\wbr}ค่า{\wbr}ใด ๆ
\item {\ct myclass::\char`\~myclass()} \\ ตัว{\wbr}ทำลาย (destructor)
  ทำ{\wbr}หน้าที่{\wbr}ใน{\wbr}การ{\wbr}จัดการ{\wbr}ก่อน{\wbr}ที่{\wbr}วัตถุ{\wbr}จะ{\wbr}ถูก{\wbr}ทำลาย เช่น คืน{\wbr}ทรัพยากร{\wbr}ที่{\wbr}วัตถุ{\wbr}ขอ{\wbr}มา{\wbr}จาก{\wbr}ระบบ เป็นต้น{\wbr}
\item {\ct myclass::myclass(const myclass\& obj)} \\ ตัว{\wbr}สร้าง{\wbr}สำหรับ{\wbr}คัดลอก{\wbr}
  ตัว{\wbr}สร้าง{\wbr}นี้{\wbr}จะ{\wbr}รับ{\wbr}พารามิเตอร์{\wbr}แบบ{\wbr}อ้างอิง{\wbr}ไป{\wbr}ยัง{\wbr}วัตถุ{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}เดียวกัน{\wbr}
  ตัว{\wbr}สร้าง{\wbr}นี้{\wbr}สามารถ{\wbr}เรียก{\wbr}ใช้ได้{\wbr}โดย{\wbr}ตรง{\wbr}หรือ{\wbr}อาจ{\wbr}จะ{\wbr}โดน{\wbr}เรียก{\wbr}เมื่อ{\wbr}มี{\wbr}การ{\wbr}ส่ง{\wbr}ค่า{\wbr}ไป{\wbr}ยัง{\wbr}ฟังก์ชัน{\wbr}แบบ{\wbr}
  pass by value \ โดย{\wbr}ทั่วไป{\wbr}แล้ว ค{\wbr}ลา{\wbr}ส{\wbr}ที่{\wbr}มี{\wbr}การ{\wbr}จอง{\wbr}และ{\wbr}คืน{\wbr}ทรัพยากร{\wbr}เมื่อ{\wbr}ถูก{\wbr}ทำลาย เช่น{\wbr}
  มี{\wbr}การ{\wbr}จอง{\wbr}หน่วยความจำ และ{\wbr}ต้องการ{\wbr}รองรับ{\wbr}การ{\wbr}ส่ง{\wbr}ค่า{\wbr}ไป{\wbr}ยัง{\wbr}ฟังก์ชัน{\wbr}แบบ pass by value
  จะ{\wbr}ต้อง{\wbr}เขียน{\wbr}ฟังก์ชัน{\wbr}นี้{\wbr}
\item {\ct myclass\& myclass::operator(const myclass\& obj)}
  \\ ฟังก์ชัน{\wbr}โอ{\wbr}เปอเรเตอร์{\wbr}กำหนด{\wbr}ค่า ถูก{\wbr}เรียก{\wbr}ใช้{\wbr}เมื่อ{\wbr}มี{\wbr}การ{\wbr}ให้{\wbr}ค่า{\wbr}วัตถุ{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ดังกล่าว{\wbr}
  \ เช่นเดียวกับ{\wbr}ตัว{\wbr}สร้าง{\wbr}สำหรับ{\wbr}คัดลอก{\wbr}
  ค{\wbr}ลา{\wbr}ส{\wbr}ที่{\wbr}มี{\wbr}การ{\wbr}จอง{\wbr}ทรัพยากร{\wbr}และ{\wbr}คืน{\wbr}ทรัพยากร{\wbr}มัก{\wbr}จำเป็น{\wbr}ต้อง{\wbr}เขียน{\wbr}ฟังก์ชัน{\wbr}เหล่านี้{\wbr}
\end{itemize}

อย่างไรก็ตาม ถ้า{\wbr}โดยมาก{\wbr}เรา{\wbr}ใช้{\wbr}งาน{\wbr}วัตถุ{\wbr}โดย{\wbr}ไม่{\wbr}มี{\wbr}การ{\wbr}คัดลอก{\wbr}
และ{\wbr}เมื่อ{\wbr}มี{\wbr}การ{\wbr}ส่ง{\wbr}ค่า{\wbr}ไป{\wbr}ยัง{\wbr}ฟังก์ชัน{\wbr}จะ{\wbr}ใช้{\wbr}การ{\wbr}ส่ง{\wbr}ค่า{\wbr}แบบ{\wbr}อ้างอิง{\wbr}หรือ{\wbr}ส่ง{\wbr}ด้วย{\wbr}พอยน์เตอร์{\wbr}เท่านั้น เช่น{\wbr}
ใน{\wbr}กรณี{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}ที่{\wbr}ใช้{\wbr}งาน{\wbr}แบบ{\wbr}อ้างอิง{\wbr}เท่านั้น{\wbr}
(ดู{\wbr}ส่วน~\ref{section:abs-value-ref-semantics})
เรา{\wbr}ก็{\wbr}ไม่{\wbr}จำเป็น{\wbr}ต้อง{\wbr}เขียน{\wbr}ตัว{\wbr}สร้าง{\wbr}สำหรับ{\wbr}คัดลอก และ{\wbr}โอ{\wbr}เปอเรเตอร์{\wbr}กำหนด{\wbr}ค่า \ อย่างไรก็ตาม{\wbr}
เพื่อ{\wbr}ป้องกัน{\wbr}การ{\wbr}คัดลอก{\wbr}โดย{\wbr}ไม่{\wbr}ได้{\wbr}ตั้งใจ เรา{\wbr}อาจ{\wbr}จะ{\wbr}ประกาศ{\wbr}ฟังก์ชัน{\wbr}ทั้ง{\wbr}สอง{\wbr}เป็น{\wbr}สมาชิก{\wbr}ส่วนตัว{\wbr}
โดย{\wbr}ไม่{\wbr}ต้อง{\wbr}นิยาม{\wbr}ฟังก์ชัน เพื่อให้{\wbr}คอม{\wbr}ไพ{\wbr}เลอร์{\wbr}ตรวจสอบ{\wbr}ว่า{\wbr}ไม่{\wbr}มี{\wbr}การ{\wbr}คัดลอก{\wbr}วัตถุ{\wbr}เกิด{\wbr}ขึ้น{\wbr}ได้{\wbr}
ยก{\wbr}ตัวอย่าง{\wbr}เช่น{\wbr}ดัง{\wbr}โปรแกรม{\wbr}ด้าน{\wbr}ล่าง{\wbr}นี้{\wbr}

\latintext
\begin{codelist}{C++}{}
class myclass {
  // ...
private:
  myclass(const myclass& obj);
  myclass& operator=(const myclass& obj);
};
\end{codelist}
\thaitext

\subsection{การ{\wbr}ใช้{\wbr}วัตถุ{\wbr}แบบ value และ{\wbr}แบบ reference}
\label{section:abs-value-ref-semantics}

\subsection{การ{\wbr}ประกาศ{\wbr}ฟังก์ชัน{\wbr}หลาย{\wbr}ฟังก์ชัน{\wbr}โดย{\wbr}ใช้{\wbr}ชื่อ{\wbr}เดียวกัน: การ{\wbr}โอ{\wbr}เวอร์{\wbr}โหลด}

\subsection{ค{\wbr}ลา{\wbr}ส{\wbr}สืบต่อ}

\subsection{ความจำ{\wbr}เป็น{\wbr}ที่{\wbr}ต้อง{\wbr}ระบุ {\ct typename} เมื่อ{\wbr}ใช้{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ที่{\wbr}ขึ้น{\wbr}กับ{\wbr}ตัวแปร{\wbr}แม่แบบ}
\label{section:abs-typename}

ส่วน{\wbr}นี้{\wbr}อธิบาย{\wbr}และ{\wbr}ยก{\wbr}ตัวอย่าง{\wbr}แสดง{\wbr}ความจำ{\wbr}เป็น{\wbr}ต้อง{\wbr}ระบุ{\wbr}คีย์{\wbr}เวิร์ด {\ct typename}
แต่{\wbr}ไม่{\wbr}จำเป็น{\wbr}มาก{\wbr}ต่อ{\wbr}เนื้อหา{\wbr}หลัก{\wbr}
ผู้อ่าน{\wbr}สามารถ{\wbr}ข้าม{\wbr}ไป{\wbr}ได้\footnote{เนื้อหา{\wbr}และ{\wbr}ตัวอย่าง{\wbr}นำมา{\wbr}จาก{\wbr}ส่วน C.13.5 ของ{\wbr}หนังสือ{\wbr}ของ{\wbr}
  Stroustrup}

เมื่อ{\wbr}ถูก{\wbr}นิยาม เรา{\wbr}ไม่{\wbr}ทราบ{\wbr}ว่า{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ที่{\wbr}ถูก{\wbr}ส่ง{\wbr}เป็น{\wbr}พารามิเตอร์{\wbr}เป็น{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ใด{\wbr}
ทำ{\wbr}ให้{\wbr}เมื่อ{\wbr}มี{\wbr}การ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก{\wbr}ของ{\wbr}แบบ{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}นั้น{\wbr}
คอม{\wbr}ไพ{\wbr}เลอร์{\wbr}จะ{\wbr}ไม่{\wbr}สามารถ{\wbr}แยกแยะ{\wbr}ได้{\wbr}ว่า{\wbr}สมาชิก{\wbr}นั้น{\wbr}คือ{\wbr}อะไร{\wbr}

พิจารณา{\wbr}ตัวอย่าง{\wbr}เช่น{\wbr}โปรแกรม{\wbr}ถัด{\wbr}ไป{\wbr}

\latintext
\begin{codelist}{C++}{}
template <class C> void f()
{
  C::t(a);
}
\end{codelist}
\thaitext

ถ้า{\wbr}พิจารณา{\wbr}เพียง{\wbr}ผ่าน ๆ เรา{\wbr}อาจ{\wbr}จะ{\wbr}คิด{\wbr}ว่า {\ct t} เป็น{\wbr}ฟังก์ชัน{\wbr}แบบ{\wbr}สถิตย์{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส (static
function) ซึ่ง{\wbr}เรา{\wbr}จะ{\wbr}ได้{\wbr}กล่าว{\wbr}ถึง{\wbr}ต่อไป แต่{\wbr}ก็{\wbr}เป็น{\wbr}ไป{\wbr}ได้{\wbr}ที่ {\ct t} จะ{\wbr}เป็น{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}
และ{\wbr}การ{\wbr}นิยาม{\wbr}ดังกล่าว{\wbr}ก็{\wbr}เหมือน{\wbr}กับ{\wbr}การ{\wbr}นิยาม{\wbr}ตัวแปร{\wbr}แต่{\wbr}มี{\wbr}การ{\wbr}ใส่{\wbr}วงเล็บ{\wbr}เกิน เช่น {\ct int (a);}

ดังนั้น ภาษา C++ จึง{\wbr}ได้{\wbr}กำหนด{\wbr}ว่า{\wbr}ถ้า{\wbr}มี{\wbr}การ{\wbr}อ้าง{\wbr}ถึง{\wbr}สมาชิก{\wbr}ของ{\wbr}ค{\wbr}ลา{\wbr}ส{\wbr}แม่แบบ{\wbr}
คอม{\wbr}ไพ{\wbr}เลอร์{\wbr}จะ{\wbr}พิจารณา{\wbr}ให้{\wbr}สมาชิก{\wbr}นั้น{\wbr}ไม่{\wbr}เป็น{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}
นอก{\wbr}เสีย{\wbr}จาก{\wbr}เรา{\wbr}จะ{\wbr}ระบุ{\wbr}ว่า{\wbr}สมาชิก{\wbr}นั้น{\wbr}เป็น{\wbr}ชนิด{\wbr}ของ{\wbr}ข้อมูล โดย{\wbr}การ{\wbr}เขียน{\wbr}คีย์{\wbr}เวิร์ด {\ct
  typename} นำหน้า{\wbr}

ข้อกำหนด{\wbr}ดังกล่าว{\wbr}เป็นจริง{\wbr}สำหรับ{\wbr}การ{\wbr}อ้าง{\wbr}ถึง {\ct list<T>::iterator} ด้วย ดังนั้น{\wbr}
เรา{\wbr}จึง{\wbr}ต้อง{\wbr}ระบุ{\wbr}ว่า{\wbr}ชื่อดัง{\wbr}กล่าว{\wbr}หมายถึง{\wbr}ชนิด{\wbr}ข้อมูล{\wbr}ด้วย {\ct typename}

