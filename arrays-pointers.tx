\chapter{อาร์เรย์ พอยน์เตอร์ และการวิเคราะห์ความซับซ้อน}

ในบทนี้เราจะพิจารณาโครงสร้างข้อมูลพื้นฐานสำหรับจัดเก็บและประมวลผลข้อมูลจำนวนมากที่เรียกว่า{\em
อาร์เรย์} (array) รวมไปถึงข้อมูลประเภท{\em พอยน์เตอร์} (pointer)
ซึ่งเก็บตำแหน่งภายในหน่วยความจำ
โดยเราจะเริ่มพิจารณาแนวคิดของโครงสร้างข้อมูลและชนิดข้อมูลดังกล่าวโดยไม่ขึ้นกับภาษาโปรแกรมที่ใช้
จากนั้นเราจะศึกษาวิธีการเขียนในภาษา C++
และศึกษาความสัมพันธ์ระหว่างพอยน์เตอร์และอาร์เรย์ซึ่งเป็นคุณลักษณะเฉพาะที่มีในภาษาตระกูล C และ C++

ในบทนี้ เราจะเริ่มศึกษาการวิเคราะห์เวลาการทำงานของอัลกอริทึมอย่างง่าย ก่อนที่จะไปพิจารณาอย่างเป็นทางการในบทที่~\ref{chapter:analysis}

\section{อาร์เรย์}
อาร์เรย์เป็นโครงสร้างข้อมูลที่เก็บกลุ่มของข้อมูลเป็นรายการ
โดยที่ข้อมูลแต่ละตัวจะถูกเก็บต่อเนื่องกันในหน่วยความจำ และถูกอ้างถึงโดยใช้ดัชนี (index)
ตัวอย่างง่าย ๆ ของอาร์เรย์คือรายการข้อมูลด้านล่างนี้

\begin{center}
2, 3, 5, 7, 11, 13, 17, 19, 23
\end{center}

ถ้าเราเรียกรายการดังกล่าวว่ารายการ $A$ และอ้างถึงข้อมูลแต่ละตัวด้วยดัชนีที่เริ่มต้นด้วย 0
ข้อมูลแต่ละตัวในรายการจะถูกอ้างถึงได้ดังตารางในรูปที่~\ref{fig:array-array-access}

\begin{figure}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
\hline
$A[0]$ & $A[1]$ & $A[2]$ & $A[3]$ & $A[4]$ & $A[5]$ & $A[6]$ & $A[7]$ & $A[8]$ \\
\hline
2 & 3 & 5 & 7 & 11 & 13 & 17 & 19 & 23\\
\hline
\end{tabular}
\end{center}
\caption{การอ้างถึงข้อมูลแต่ละตัวในอาร์เรย์ $A$}
\label{fig:array-array-access}
\end{figure}


---q การคำนวณค่า
จงหาผลลัพธ์ของนิพจน์เหล่านี้ (1) $A[4]$, (2) $A[7]$, (3) $A[A[0]]$, 
(4) $A[A[A[0]]]$, (5) $A[200]$
===
(1) 11, (2) 19, (3) 5, (4) 13, (5) ไม่มีค่า (ดูอธิบายเพิ่มเติม)
---

การหาคำตอบของคำถามที่ (3) นั้น จำเป็นต้องเข้าใจขั้นตอนการคำนวณค่าของนิพจน์
เราต้องการหาค่า $A[A[0]]$ ดังนั้นเราต้องหาค่า $A[0]$ ก่อน
เมื่อพิจารณาในอาร์เรย์เราพบว่า $A[0]$ คือ $2$ ดังนั้น จากนั้นเราจึงพิจารณาข้อมูล
$A[2]$ ในอารเรย์ ซึ่งจะได้ค่า $5$

ในการทำงานจริง อาร์เรย์จะเก็บในหน่วยความจำที่ต่อเนื่องกัน
และมักจะมีขอบเขตที่จำกัดและต้องระบุเมื่อเริ่มใช้ เช่น อาร์เรย์จำนวน 100 ช่อง หรือ
100000 ช่องเป็นต้น รูปที่~\ref{fig:array-array-in-mem}
แสดงตัวอย่างของการเก็บข้อมูลของอาร์เรย์ในหน่วยความจำ

\begin{figure}
TODO: ใส่รูป
\caption{การเก็บข้อมูลของอาร์เรย์ในหน่วยความจำ}
\label{fig:array-array-in-mem}
\end{figure}

คำถามที่ (5) เป็นการอ้างถึงข้อมูลที่อยู่นอกขอบเขตของอาร์เรย์
ซึ่งผลลัพธ์ที่ได้จะขึ้นกับภาษาโปรแกรมที่ใช้ สำหรับภาษา C หรือ C++
ผลลัพธ์ที่ได้จะขึ้นกับข้อมูลในหน่วยความจำในตำแหน่งที่ $A[200]$ ควรจะอยู่
เราจะได้ศึกษารายละเอียดนี้ต่อไป อย่างไรก็ตาม ปกติแล้ว ในการใช้งานอาร์เรย์
เราจะไม่อ้างถึงข้อมูลที่อยู่นอกขอบเขตของอาร์เรย์

การระบุดัชนีของข้อมูลในอาร์เรย์ในหนังสือเล่มนี้จะอ้างอิงจากภาษาตระกูลภาษา C
นั่นคือเริ่มต้นที่ 0 \ \ สำหรับบางภาษา เราสามารถระบุค่าเริ่มต้นของดัชนีได้และมักเริ่มที่ 1
เช่นภาษาปาสคาล (Pascal) เป็นต้น
อย่างไรก็ตามแนวคิดในการพัฒนาโปรแกรมนั้นจะไม่ต่างกัน

เมื่อเราสามารถอ้างถึงข้อมูลได้ด้วยดัชนี
เราสามารถใช้ตัวแปรเพื่อแทนค่าดัชนีของข้อมูลที่เราต้องการใช้งานได้
ความสามารถนี้ทำให้เราสามารถเขียนโปรแกรมที่มีลักษณะดังด้านล่างได้

---algt[alg:array-sum1] *
* ให้ $x\leftarrow 0$
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,8$
** ให้ $x \leftarrow x + A[i]$
---

---q *
อัลกอริทึมดังกล่าวคำนวณค่าบางอย่างในตัวแปร $x$ ค่านั้นคืออะไร?
===
ผลรวมของข้อมูลทั้งหมดในอาร์เรย์ $A$
---

สังเกตว่าอัลกอริทึม~\ref{alg:array-sum1} เขียนให้ทำงานกับอาร์เรย์ $A$
ที่มีดัชนีมากที่สุดคือ 8 เท่านั้น ในการพัฒนาอัลกอริทึมทั่วไปเรามักเขียนให้ทำงานได้กับข้อมูลทั่วไป
ซึ่งในกรณีนี้ การจะปรับให้ทำงานได้กับอาร์เรย์ใด ๆ เราจะต้องระบุขนาดของอาร์เรย์ด้วย
เราสามารถเขียนอัลกอริทึมดังกล่าวโดยระบุพารามิเตอร์ให้ชัดเจนขึ้นได้ดังด้านล่าง

---algt[alg:array-sum2] คำนวณค่าบางอย่างของอาร์เรย์ $A$ ที่มีข้อมูลจำนวน $n$ ตัว
* ให้ $x\leftarrow 0$
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,n-1$
** ให้ $x \leftarrow x + A[i]$
* คืนค่า $x$ เป็นคำตอบ
---

\subsection{เวลาที่ใช้ในการทำงาน}

ค่าพารามิเตอร์ $n$ ที่เราส่งให้กับโปรแกรมย่อย ระบุจำนวนรอบของการทำงาน
ซึ่งจะเป็นตัวกำหนดเวลาที่โปรแกรมย่อยใช้ในการทำงานด้วย อย่างไรก็ตาม
เพียงแค่พิจารณาโปรแกรมย่อยดังกล่าว เราไม่สามารถระบุเวลาจริง ๆ
ที่โปรแกรมย่อยจะทำงานได้เนื่องจากเราไม่ทราบปัจจัยหลาย ๆ อย่าง

---q เวลาการทำงานจริงบนคอมพิวเตอร์
ปัจจัยอะไรบ้างที่กำหนดเวลาทำงานบนคอมพิวเตอร์จริง ๆ ของโปรแกรมย่อยข้างต้น
===
เวลาในการทำงานจริง ขึ้นกับ (1) โปรแกรมภาษาคอมพิวเตอร์ที่เขียนจากโปรแกรมย่อย (2)
คอมไพเลอร์ที่ใช้ (3) เครื่องคอมพิวเตอร์ที่นำโปรแกรมไปทำงาน
และสถานะของเครื่องในขณะที่โปรแกรมทำงาน  
---

สังเกตว่าการพิจารณาแค่อัลกอริทึมเพียงอย่างเดียว
หรือกระทั่งจะพิจารณาโปรแกรมในภาษาเครื่องที่ถูกคอมไพล์แล้วร่วมด้วย
ก็ไม่สามารถทำให้เราระบุเวลาการทำงานบนคอมพิวเตอร์จริงได้อย่างแม่นยำ
ยิ่งในปัจจุบันที่คอมพิวเตอร์สามารถทำงานหลาย ๆ งานในเวลาเดียวกัน
การทำนายเวลาการทำงานจริงยิ่งกระทำได้ยากขึ้นด้วย

อย่างไรก็ตาม แม้การระบุเวลาการทำงานจริง ๆ ทำได้ยาก
การทำนายเวลาการทำงานของอัลกอริทึมก่อนที่จะนำไปพัฒนาเป็นโปรแกรมก็ยังเป็นสิ่งจำเป็นมาก
เนื่องจากในหลาย ๆ เราสามารถเลือกใช้อัลกอริทึมได้หลากหลาย
และอัลกอริทึมเหล่านั้นก็มีความซับซ้อนในการนำไปพัฒนาเป็นโปรแกรมที่แตกต่างกัน
โปรแกรมเมอร์จึงต้องเลือกใช้อัลกอริทึมให้เหมาะสม นั่นคือเป็นอัลกอริทึมที่เมื่อนำไปพัฒนาแล้ว
มีประสิทธิภาพพอ (ทำงานได้ทันเวลา)
และมีความซับซ้อนในการเขียนในระดับที่โปรแกรมเมอร์สามารถจัดการได้
การเลือกนำอัลกอริทึมที่ทราบว่ามีประสิทธิภาพดีที่สุดไปพัฒนานั้น
อาจไม่ใช่ทางเลือกที่ดีที่สุดก็เป็นได้

ดังนั้น เราจะพยายามวิเคราะห์เวลาการทำงานของโปรแกรมย่อย
ที่อยู่ในรูปของโปรแกรมลำลองด้านบน ให้ละเอียดเท่าที่เราพอจะทำได้
แน่นอนเราจำเป็นต้องเพิ่มข้อสมมติหลายอย่างเพื่อให้การวิเคราะห์เป็นไปได้

ข้อสมมติข้อแรก (ที่เราจะใช้ตลอดในหนังสือเล่มนี้) คือ
เราจะสมมติว่าคอมพิวเตอร์นั้นทำงานทีละคำสั่ง นั่นคือไม่ใช่คอมพิวเตอร์แบบขนาน
หรือเป็นคอมพิวเตอร์ที่มีหน่วยประมวลผลหลายตัวทำงานพร้อมกัน\footnote{TODO:
  ระบุว่าถึงจะเป็นกรณีดังกล่าว การวิเคราะห์ก็ยังเป็นไปได้}

ถ้าพิจารณาต่อไป เราจะพบว่าโปรแกรมย่อย~\ref{alg:array-sum2}
ทำงานโดยใช้เวลาในการทำงานที่แปรผันตามค่าพารามิเตอร์ $n$
เพื่อจะให้เราสามารถวิเคราะห์เวลาการทำงานออกมาได้
เราจะสมมติว่าคอมพิวเตอร์เมื่อทำงานตามโปรแกรมดังกล่าว ใช้เวลา 1
หน่วยในการประมวลผลคำสั่งแต่ละบรรทัด
เราจะสามารถคำนวณเวลาที่โปรแกรมดังกล่าวใช้โดยพิจารณาจำนวนครั้งที่คำสั่งในแต่ละบรรทัดทำงาน
ดังด้านล่าง

---algt *
* ให้ $x\leftarrow 0$   \ \ \ \ $\rhd\rhd\rhd$ ทำงาน 1 ครั้ง
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,n-1$  \ \ \ \ $\rhd\rhd\rhd$ ทำงาน $n$ ครั้ง
** ให้ $x \leftarrow x + A[i]$  \ \ \ \ $\rhd\rhd\rhd$ ทำงาน $n$ ครั้ง
* คืนค่า $x$ เป็นคำตอบ  \ \ \ \ $\rhd\rhd\rhd$ ทำงาน 1 ครั้ง
---

ดังนั้นเราจะได้ว่าเวลารวมคือ $2n + 2$ หน่วย คำถามที่ตามมาก็คือ
ผลลัพธ์จากการวิเคราะห์ดังกล่าวมีความแม่นยำ
และสามารถนำไปใช้วิเคราะห์และตัดสินใจต่อไปได้เพียงใด
เราจะพิจารณาผลจากการสมมติและความถูกต้องที่ใช้ได้ในบทที่~\ref{chapter:analysis}

\subsection{การประมวลผลรายการด้วยอาร์เรย์}

ในส่วนนี้เราจะพัฒนาโปรแกรมลำลองเพื่อประมวลผลข้อมูลในรายการที่เก็บในอาร์เรย์
พร้อมกับวิเคราะห์เวลาการทำงาน

---q *
สมมติว่าเรามีรายการของข้อมูล ลองนึกตัวอย่างการประมวลผลที่เราสามารถกระทำกับข้อมูลในรายการนี้
---

ก่อนที่เราจะประมวลผลได้ เราต้องพิจารณาวิธีการจัดเก็บข้อมูลแบบรายการลงในอาร์เรย์ก่อน
สังเกตว่าโครงสร้างข้อมูลแบบอาร์เรย์มีลักษณะเป็นรายการอยู่แล้ว
อย่างไรก็ตามในการจัดการกับรายการที่มีจำนวนข้อมูลเปลี่ยนแปลงได้
การใช้อาร์เรย์เพียงอย่างเดียวนั้นไม่เพียงพอ

---q *
อะไรคือสิ่งที่ขาดหายไป ถ้าเราใช้แค่อาร์เรย์ในการจัดเก็บรายการที่จำนวนข้อมูลในรายการเปลี่ยนแปลงได้
---

ดังนั้น เราจะใช้ตัวแปรอีกหนึ่งตัวในการเก็บจำนวนข้อมูลที่มีในอาร์เรย์
โปรแกรมลำลองที่เราจะพัฒนาจะเปลี่ยนค่าของตัวแปรนี้โดยตรงเพื่อปรับให้มีค่าที่ถูกต้องภายหลังการประมวลผล
ในการพัฒนาโปรแกรมลำลองให้เป็นโปรแกรมภาษา C++
การทำงานดังกล่าวจะต้องใช้การส่งรับพารามิเตอร์เป็นพอยน์เตอร์หรือส่งแบบ pass by
reference ซึ่งเราจะได้พิจารณาในส่วน~\ref{sect:array-pointer-c}
นอกจากนี้ในบทที่~\ref{chapter:classes} เราจะได้ศึกษาวิธีการที่จะ ``ประกอบรวม''
อาร์เรย์และตัวแปรที่เก็บจำนวนข้อมูลที่อยู่ในอาร์เรย์เข้าด้วยกัน
เพื่อสร้างเป็นชนิดข้อมูลใหม่ที่นำไปใช้งานได้สะดวกต่อไป

เราจะพิจารณาการประมวลผลกับอาร์เรย์ในรูปแบบต่าง ๆ ดังนี้ (1) การค้นข้อมูลในรายการ, (2) การเพิ่มข้อมูลลงไปตอนท้ายของรายการ, (3) การลบข้อมูลในรายการ, และ (4) การแทรกข้อมูลในรายการ

\subsubsection{การค้นข้อมูล} 
สำหรับการค้นข้อมูลในรายการ
เป้าหมายของการทำงานคือทราบว่ามีข้อมูลที่เราต้องการหาหรือไม่ และถ้ามีอยู่ที่ตำแหน่งใด
ในกรณีนี้เราจะต้องพิจารณาข้อมูลทุกตัวในรายการ
โปรแกรมลำลองมีลักษณะไม่ต่างจากที่เราเคยเขียนเท่าใดนัก

---algt ค้นหาข้อมูล $x$ ในอาร์เรย์ $A$ ที่มีข้อมูลจำนวน $n$ ตัว
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots, n-1$
** ถ้า $A[i] = x$
*** คืนค่า $i$ เป็นผลลัพธ์
* ตอบว่าไม่พบค่าที่ต้องการ
---

ในการพัฒนาโปรแกรมจริง ๆ
เราจะต้องจัดการในกรณีที่จะต้องตอบว่าไม่พบค่าที่ต้องการให้ชัดเจนกว่านี้
แต่ในขณะนี้เราจะสมมติว่าโปรแกรมย่อยสามารถตอบแบบนี้ได้

---q *
ในกรณีของโปรแกรมย่อยสำหรับหาผลรวม เราพบว่าโปรแกรมทำงานในเวลาที่แปรผันกับค่า $n$
เสมอ เป็นไปได้หรือไม่ ที่โปรแกรมย่อยสำหรับจะทำงานโดยวนรอบเป็นจำนวนครั้งที่น้อยกว่าค่า $n$ มาก? และเป็นในกรณีใด?
---

---q *
สำหรับอาร์เรย์ที่มีข้อมูล $n$ ตัว เมื่อใดที่โปรแกรมย่อยจะทำงานโดยวนรอบมากที่สุด
---

โปรแกรมย่อยข้างต้นอาจจะทำงานได้รวดเร็วมาก ถ้าข้อมูลที่ต้องการค้นหาอยู่ตอนต้นของอาร์เรย์
โปรแกรมย่อยลักษณะนี้เป็นตัวอย่างที่ดีของโปรแกรมย่อยที่เวลาการทำงานขึ้นกับข้อมูลป้อนเข้า
ทำให้ในการวิเคราะห์เวลาการทำงานนั้น เราจำเป็นจะต้องพิจารณาข้อมูลป้อนเข้าด้วย
อย่างไรก็ตามเราไม่สามารถที่จะวิเคราะห์เวลาการทำงานของโปรแกรมลำลองบนข้อมูลป้อนเข้าทุกรูปแบบได้
เพราะว่าจำนวนของข้อมูลป้อนเข้านั้นมีไม่จำกัด

ในทางปฏิบัติแล้ว เราจึงจะแบ่งวิเคราะห์เวลาการทำงานเป็นกรณีย่อย ๆ สามกรณีคือ
\begin{itemize}
\item การวิเคราะห์ในกรณีที่ดีที่สุด (best-case analysis),
\item การวิเคราะห์ในกรณีที่เลวร้ายที่สุด (worst-case analysis), และ
\item การวิเคราะห์ในกรณีเฉลี่ย (average-case analysis)
\end{itemize}

สำหรับการวิเคราะห์ในกรณีเฉลี่ยนั้น เป็นการวิเคราะห์เชิงความน่าจะเป็น
เราจำเป็นจะต้องนิยามลักษณะการกระจายของข้อมูลป้อนเข้าให้ชัดเจน จึงจะสามารถกระทำได้
เราจะได้ศึกษาตัวอย่างการวิเคราะห์นี้ในบทที่~\ref{chapter:analysis} (TODO:
เพิ่มหรือลบ) ในที่นี้เราจะสนใจเฉพาะการวิเคราะห์กรณีที่ดีที่สุด
และการวิเคราะห์ในกรณีที่เลวร้ายที่สุดเท่านั้น

กรณีที่ดีที่สุดคือกรณีที่มีการวนรอบเพียงรอบเดียว นั้นคือเป็นกรณีที่ $A[0] = x$
สังเกตว่าถ้าเราสมมติให้การประมวลผลแต่ละบรรทัดใช้เวลา 1 หน่วย ในกรณีที่ดีที่สุด
โปรแกรมลำลองดังกล่าวจะใช้เวลาทำงาน $4$ หน่วย

กรณีที่เลวร้ายที่สุดเกิดขึ้นเมื่อไม่พบข้อมูลที่ต้องการหา
สังเกตว่าโปรแกรมจะทำงานวนอยู่ที่สองบรรทัดแรกเป็นจำนวน $n$ ครั้ง และคืนคำตอบ
ดังนั้นโปรแกรมจะใช้เวลาทำงาน $2n + 1$ หน่วย

เช่นเดียวกับการวิเคราะห์อย่างง่ายในส่วนที่แล้ว
เราจะพิจารณาแนวคิดการวิเคราะห์ทั้งสามแบบอย่างละเอียดในบทที่~\ref{chapter:analysis}

\subsubsection{การเพิ่มข้อมูลลงไปท้ายรายการ}

เราจะเพิ่มข้อมูลลงไปตอนท้ายของข้อมูลในอาร์เรย์
นั่นคือใส่ข้อมูลในอาร์เรย์ที่มีดัชนีมากกว่าดัชนีตัวสุดท้าย
โปรแกรมลำลองที่น่าจะทำงานได้เขียนดังนี้

---algt เพิ่มข้อมูล $x$ ในตอนท้ายอาร์เรย์ $A$ ที่มีข้อมูล $n$ ตัว
* $A[n] \leftarrow x$
* $n \leftarrow n + 1$
---

อย่างไรก็ตาม ในการนำไปใช้จริง โปรแกรมลำลองดังกล่าวอาจจะทำให้เกิดข้อผิดพลาดขึ้นระหว่างการทำงานได้

---q *
กรณีใดที่โปรแกรมลำลองข้างต้นอาจทำให้เกิดข้อผิดพลาดขึ้นระหว่างการทำงาน
===
จากที่เราได้เคยเกริ่นบ้างแล้วว่า ในการใช้งานอาร์เรย์
โดยมากจะต้องระบุขอบเขตหรือจำนวนข้อมูลมากที่สุดที่เก็บในอาร์เรย์ได้
ในกรณีของโปรแกรมลำลองนี้ถ้าเราเรียกใช้เมื่อ $n$
มีขนาดมากกว่าหรือเท่ากับจำนวนข้อมูลที่อาร์เรย์เก็บได้ คำสั่ง $A[n]\leftarrow x$
ก็อาจจะเขียนข้อมูลลงในหน่วยความจำบริเวณที่อยู่นอกขอบเขตของอาร์เรย์ $A$ ได้
---

ดังนั้นเพื่อความไม่ประมาท
โปรแกรมย่อยควรจะต้องตรวจสอบขนาดของอาร์เรย์เพื่อป้องกันความผิดพลาดนี้ด้วย
ในการเขียนต่อไปเราจะให้ $MAXLEN$ เป็นค่าคงที่แทนขนาดมากที่สุดของอาร์เรย์ $A$
เราปรับแก้โปรแกรมย่อยได้ดังด้านล่าง

---algt เพิ่มข้อมูล $x$ ในตอนท้ายอาร์เรย์ $A$ ที่มีข้อมูล $n$ ตัว (แก้ไข)
* ถ้า $n < MAXLEN$ แล้ว
** $A[n] \leftarrow x$
** $n \leftarrow n + 1$
* ไม่เช่นนั้น
** รายงานว่าไม่สามารถเพิ่มข้อมูลได้
---

โปรแกรมย่อยนี้ ในการวิเคราะห์เวลาการทำงานมีสองกรณีให้เราพิจารณา สังเกตว่า
จะใช้เวลาในการทำงานไม่เกิน $3$ หน่วยไม่ว่าในกรณีใด 

ในกรณีแรก (กรณีที่ $n<MAXLEN$) โปรแกรมย่อยจะใช้เวลาการทำงาน $3$ หน่วย
และในอีกกรณีจะใช้เวลาการทำงาน $2$ หน่วย อย่างไรก็ตาม
ผู้อ่านอย่าเพิ่งรีบสรุปว่ากรณีแรกทำงานจริง ๆ ได้เร็วกว่า เพราะว่าความแตกต่างนี้จริง ๆ
แล้วเกิดจากข้อสมมติว่าการทำงานในทุกคำสั่งมีความเร็วเท่ากันคือ 1 หน่วย
ดังนั้นประเด็นสำคัญของการวิเคราะห์นี้คือโปรแกรมย่อยนี้ทำงานในเวลาที่ไม่ขึ้นกับค่า $n$

\subsubsection{การลบข้อมูลในรายการและการแทรกข้อมูลในรายการ}

สำหรับการลบข้อมูลและแทรกข้อมูลในรายการ
โปรแกรมย่อยที่ประมวลผลนั้นจะรับดัชนีของข้อมูลที่ต้องการลบ
และดัชนีที่ต้องการให้นำข้อมูลไปแทรกต่อจากตำแหน่งนั้น
ถ้าอาร์เรย์เริ่มต้นของเรามีข้อมูล 9 ตัว ดังด้านล่าง

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
ดัชนี & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\\
\hline
ข้อมูล & 2 & 3 & 5 & 7 & 11 & 13 & 17 & 19 & 23 & ?\\
\hline
\end{tabular}

จำนวนข้อมูล $n = 9$
\end{center}

สังเกตว่าเราละข้อมูลที่ในอาร์เรย์ที่มีดัชนีอยู่นอกขอบเขตของข้อมูลในรายการไป
(โดยแสดงด้วยเครื่องหมาย ?)

การลบข้อมูลที่มีดัชนีเป็น 3 ให้ผลดังนี้

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
ดัชนี & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\\
\hline
ข้อมูล & 2 & 3 & 5 & 11 & 13 & 17 & 19 & 23 & ? & ? \\
\hline
\end{tabular}

จำนวนข้อมูล $n = 8$
\end{center}

จากอาร์เรย์ดังกล่าวส การแทรกข้อมูล 99 เข้าไปหลังข้อมูลที่มีดัชนีเป็น 1 ให้ผลดังนี้

\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|c|c|c|c|}
\hline
ดัชนี & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9\\
\hline
ข้อมูล & 2 & 3 & 99 & 5 & 11 & 13 & 17 & 19 & 23 & ? \\
\hline
\end{tabular}

จำนวนข้อมูล $n = 9$
\end{center}

---q *
การประมวลผลทั้งสองแบบมีกระบวนการหนึ่งที่ต้องดำเนินการคล้าย ๆ กัน คืออะไร
---

การประมวลผลทั้งสองแบบนี้แสดงให้เห็นข้อจำกัดของการเก็บข้อมูลแบบรายการด้วยอาร์เรย์
(ยกเว้นจะมีเทคนิคพิเศษอื่น ๆ ประกอบ)
ที่โครงสร้างข้อมูลเช่นลิงก์ลิสต์ที่เราจะพิจารณาในบทที่~\ref{chapter:linked-lists}
สามารถจัดการได้เป็นอย่างดี

โปรแกรมลำลองด้านล่างแสดงการลบข้อมูลที่มีดัชนี $i$ ในรายการในอาร์เรย์

---algt[algo:array-deletion1] ลบข้อมูลที่มีดัชนี $i$ ในรายการที่เก็บในอาร์เรย์ $A$ ที่มีขนาด $n$ (แก้ไข)
* พิจารณาให้ ตัวแปร $i\leftarrow i,i+1,\ldots,n-1$
** $A[i]\leftarrow A[i+1]$
* $n\leftarrow n-1$
---

---q *
โปรแกรมลำลอง~\ref{algo:array-deletion1}
อาจทำให้เกิดความผิดพลาดระหว่างการทำงานได้ในบางกรณีเพราะว่าไม่ได้ตรวจสอบเงื่อนไขบางอย่าง
เงื่อนไขนั้นคืออะไร?
---

สังเกตว่าถ้าดัชนีอยู่นอกของเขตของรายการ
หรือในกรณีที่ไม่มีข้อมูลโปรแกรมลำลองอาจเกิดปัญหาระหว่างทำงาน
โปรแกรมลำลองด้านล่างเพิ่มเงื่อนไขในการตรวจสอบนี้ สำหรับในกรณีเช่นในตัวอย่างนี้ ภาษา
C++ จะมีวิธีการจัดการรายงานความผิดพลาดกลับไปยังโปรแกรมหลักที่เรียกใช้อย่างเป็นระบบ
โดยใช้แนวคิดที่เรียกว่า exception ซึ่งเราจะได้พิจารณาต่อไปในบทที่ XXXX (TODO:
เพิ่มหรือลบ)

---algt[algo:array-deletion2] ลบข้อมูลที่มีดัชนี $i$ ในรายการที่เก็บในอาร์เรย์ $A$ ที่มีขนาด $n$ (แก้ไข)
* ถ้า $i > n-1$ หรือ $i < 0$
** รายงานความผิดพลาดว่าดัชนีอยู่นอกขอบเขต แล้วจบการทำงาน
* พิจารณาให้ ตัวแปร $i\leftarrow i,i+1,\ldots,n-1$
** $A[i]\leftarrow A[i+1]$
* $n\leftarrow n-1$
---

สังเกตว่าเวลาที่โปรแกรมลำลองข้างต้นใช้การทำงาน ขึ้นกับตำแหน่งของข้อมูล
เช่นเดียวกับการวิเคราะห์ในส่วนของการค้นข้อมูล เราสามารถพิจารณากรณีต่าง ๆ ได้สามแบบ

---q *
กรณีใดที่ทำให้โปรแกรมลำลอง~\ref{algo:array-deletion2}
ใช้เวลาในการทำงานน้อยที่สุด (best case) และใช้เวลาเป็นเท่าใด?
---

---q *
กรณีใดที่ทำให้โปรแกรมลำลอง~\ref{algo:array-deletion2} ทำงานโดยใช้เวลามากที่สุด (worst case)  และใช้เวลาเป็นเท่าใด
---

เราจะละการเขียนโปรแกรมลำลองของการแทรกข้อมูลในรายการไว้เป็นแบบฝึกหัดท้ายบท

\section{การประกาศและใช้งานอาร์เรย์ในภาษา C++}
ในส่วนนี้เราจะศึกษาการใช้งานอาร์เรย์ในภาษา C++ เพื่อเป็นพื้นฐานในการเขียนโปรแกรมสำหรับโครงสร้างข้อมูลอื่น ๆ 
ในทางปฏิบัติจริง ในไลบรารีมาตรฐานของ C++ มีโครงสร้างข้อมูลแบบ {\ct vector}
ที่ใช้งานได้สะดวกกว่าอาร์เรย์มาก
เราจะได้พิจารณาวิธีการใช้งานเทคโนโลยีที่มีประโยชน์เหล่านี้ในบทที่~\ref{chapter:stl}

ในภาษา C++
เราสามารถประกาศและจองเนื้อที่สำหรับตัวแปรประเภทอาร์เรย์ได้โดยใช้รูปแบบดังนี้

\begin{center}
ชนิดข้อมูล ชื่อตัวแปร[ขนาด];
\end{center}

ตัวอย่างแสดงการประกาศตัวแปรอาร์เรย์ของจำนวนเต็ม ({\ct int})
และอาร์เรย์ของอักขระ ({\ct char})

---src[cpp]
int a[100];
char buf[1000];
---

ภายหลังการประกาศ ระบบจะจองเนื้อที่ในหน่วยความจำสำหรับอาร์เรย์ที่เราประกาศไว้
ทำให้เราสามารถใช้อาร์เรย์ในการเก็บข้อมูลได้
ขนาดของเนื้อที่ที่จองจะขึ้นกับขนาดของอาร์เรย์และขนาดของข้อมูลชนิดนั้น ยกตัวอย่างเช่น
โดยทั่วไปแล้ว ตัวแปรประเภท {\ct int} ใช้เนื้อที่ในหน่วยความจำ 4 ไบท์ อาร์เรย์ {\ct
  a} ก็จะมีขนาดเท่ากับ 400 ไบท์ หรือในกรณีของตัวแปรประเภท {\ct char}
ที่โดยทั่วไปใช้เนื้อที่ 1 ไบท์ในการจัดเก็บ อาร์เรย์ {\ct buf} ก็จะถูกกันเนื้อที่ไว้ 1000
ไบท์\footnote{ในการทำงานจริง ระบบอาจจะกันที่ไว้เกินกว่าขนาดที่ต้องใช้จริงก็ได้}

ในการระบุขนาดของอาร์เรย์ เราไม่จำเป็นต้องระบุขนาดของอาร์เรย์เป็นค่าคงที่ก็ได้ ดังตัวอย่างด้านล่าง

---src[cpp]
int m = 1000;
int x[m * 2];
---

อย่างไรก็ตาม หลายครั้งเราไม่ทราบขนาดที่แน่นอนของอาร์เรย์ในขณะที่เราต้องประกาศ
ตัวอย่างเช่นในกรณีของการจัดเก็บรายการด้วยอาร์เรย์
ในที่นี้เราจะประกาศอาร์เรย์ให้มีขนาดใหญ่ระดับหนึ่งไว้ก่อน
และคอยตรวจสอบว่าข้อมูลล้นอาร์เรย์แล้วหรือยัง
เราจะพิจารณาและวิเคราะห์วิธีการการขยายขนาดอาร์เรย์ระหว่างการทำงาน
ในบทที่~\ref{chapter:analysis} นอกจากนี้ การใช้งานโครงสร้างข้อมูลแบบ {\ct
  vector} ก็สามารถแก้ปัญหานี้ได้เช่นกัน

เราจะเขียนโปรแกรมที่เกี่ยวข้องกับการเก็บรายการในอาร์เรย์ที่ได้กล่าวถึงในส่วนก่อนหน้าของบทนี้
สำหรับตัวอย่างนี้ เราจะเก็บรายการของจำนวนเต็ม (ข้อมูลประเภท {\ct int})

เนื่องจากเราจะต้องจองอาร์เรย์ให้มีขนาดใหญ่พอไว้ก่อนเริ่มต้นใช้งาน เราจะประกาศค่าคงที่
{\ct max\_size} เพื่อเก็บขนาดมากสุดของอาร์เรย์ สังเกตว่าเราใช้ keyword {\ct
  const} เพื่อระบุว่าค่านี้จะไม่มีการเปลี่ยนแปลง
ในการเขียนฟังก์ชันในการประมวลผลรายการ
เราจะใช้ค่าคงทีนี้ในลักษณะที่เป็นตัวแปรแบบโกลบอล (global) นั่นคือเราจะพิจารณาว่าทุก ๆ
อาร์เรย์ที่จัดเก็บรายการที่เราจะประมวลผลจะมีขนาดมากที่สุดเท่ากันคือ {\ct max\_size}

---src[cpp]
const int max_size = 10000;
---

เราจะประกาศอาร์เรย์และตัวแปรที่ใช้เก็บขนาดของรายการดังด้านล่าง 

---src[cpp]
int list[max_size];
int list_size;
---

จริง ๆ แล้ว โครงสร้างข้อมูลของเราจะใช้ตัวแปรทั้งสองด้วยกันตลอด
การประกาศในลักษณะข้างต้นทำให้เมื่อเราเรียกใช้ฟังก์ชันต่าง ๆ เราต้องส่งตัวแปรสองตัวเสมอ
ซึ่งเป็นเรื่องที่ไม่สะดวก \ \  ในบทที่~\ref{chapter:classes}
เราจะศึกษาวิธีการจับตัวแปรทั้งสองให้อยู่รวมกันเป็นเสมือนตัวแปรเดียว

---q *
ภายหลังที่เราประกาศตัวแปร {\ct list} และ {\ct list\_size}
ตามตัวอย่างข้างต้นแล้ว เราสามารถนำไปใช้งาน (เช่นเพิ่มข้อมูลลงในรายการ)
ได้ทันทีหรือไม่?
---

สังเกตว่า โครงสร้างข้อมูลที่เราจะใช้เก็บรายการนั้น ต้องมีการกำหนดค่าเริ่มต้นก่อน
เพราะว่าเมื่อประกาศ ตัวแปร {\ct list\_size}
อาจจะมีค่าเป็นอะไรก็ได้\footnote{อย่างไรก็ตาม ถ้าเราประกาศตัวแปรแบบโกลบอล
  ตัวแปรจะถูกกำหนดค่าเริ่มต้นให้โดยอัตโนมัติตามกฎของ C++}
ด้านล่างเป็นฟังก์ชันสำหรับกำหนดค่าเริ่มต้นให้กับโครงสร้างข้อมูลของเรา

---src[cpp]
void init_list(int list[], int& size)
{
  size = 0;
}
---

การเก็บข้อมูลรายการลง


\subsection{การเก็บรายการด้วยอาร์เรย์}



\subsection{อาร์เรย์หลายมิติ}

\section{พอยน์เตอร์และการใช้งานในภาษา C++}
\label{sect:array-pointer-c}

เนื่องจากพอยน์เตอร์เป็นชนิดข้อมูลที่ใกล้ชิดกับสถาปัตยกรรมของคอมพิวเตอร์มากที่สุดในภาษา
C++ เราจะเริ่มโดยศึกษาโครงสร้างการเก็บข้อมูลในหน่วยความจำคอมพิวเตอร์กันก่อน

คอมพิวเตอร์เก็บข้อมูลแบบดิจิทัล หน่วยย่อยที่สุดของข้อมูลแบบดิจิทัลคือบิต (bit ย่อมาจาก
binary digit) ซึ่งเป็นข้อมูลที่มีสองสถานะ โดยมากจะแทนด้วย 0 และ 1 หรือปิดกับเปิด
แต่อาจจะเป็นอย่างอื่นก็ได้เช่น มีแสง ไม่มีแสง, ศักย์ไฟฟ้าสูง ศักย์ไฟฟ้าต่ำเป็นต้น

หน่วยความจำคอมพิวเตอร์ในปัจจุบันเก็บข้อมูลหลายล้านบิต
การอ้างถึงข้อมูลจำนวนมากเหล่านั้นกระทำผ่านทางระบบเรียกที่อยู่ (address)
กล่าวคือข้อมูลที่อ้างถึงได้ทุกหน่วยจะมีที่อยู่เฉพาะใช้สำหรับอ้างถึง
ลักษณะการอ้างถึงข้อมูลเช่นนี้ก็ไม่ต่างจากการที่เราใช้ดัชนีในการอ้างถึงข้อมูลในอาร์เรย์นั่นเอง

อย่างไรก็ตาม ในการกำหนดที่อยู่นั้น จะไม่ได้กำหนดให้กับข้อมูลทุกบิตโดยตรง
เนื่องจากบิตเป็นหน่วยที่เล็กเกินไปในหลาย ๆ กรณี แต่จะกำหนดให้กับกลุ่มของบิตที่เรียงกัน
กลุ่มละ 8 บิต ซึ่งเรียกว่าไบท์ (byte) ซึ่งสามารถพิจารณาเป็นเลขฐานสอง 8 หลักก็ได้
ตัวอย่างของการเก็บข้อมูลแสดงดังรูปที่~\ref{fig:array-memory-as-array}

\begin{figure}
\begin{center}\begin{tabular}{|c|c|c|}
\hline
\hline
ตำแหน่ง & ข้อมูลเป็นบิต & ข้อมูลถ้าพิจารณาเป็นตัวเลข\\
\hline
\hline
0 & 0000 0000 & 0 \\
\hline
1 & 0000 1111 & 15 \\
\hline
$\vdots$ & $\vdots$ & $\vdots$ \\
\hline
1000000 & 1001 0010 & 146 \\
\hline
1000001 & 1111 1111 & 255 \\
\hline
1000002 & 0001 0000 & 16 \\
\hline
1000003 & 1010 1010 & 170 \\
\hline
$\vdots$ & $\vdots$ & $\vdots$ \\
\hline
\end{tabular}\end{center}
\caption{ตัวอย่างการเก็บข้อมูลในหน่วยความจำพร้อมด้วยที่อยู่}
\label{fig:array-memory-as-array}
\end{figure}

ข้อมูลที่เก็บในหน่วยความจำหลายชนิดอาจจะมีขนาดใหญ่เกินกว่าจะเก็บได้ใน 1 ไบท์
เช่นข้อมูลประเภท {\ct int} ในภาษา C++
โดยมากข้อมูลเหล่านั้นก็จะถูกจัดเก็บอยู่ในหลายไบท์เรียงต่อกัน
รูปแบบและวิธีการจัดเก็บเหล่านี้อยู่นอกขอบเขตของหนังสือเล่มนี้
ผู้อ่านที่สนใจสามารถอ่านเพิ่มเติมได้ในหนังสือสถาปัตยกรรมคอมพิวเตอร์ทั่วไป

ข้อมูลประเภทพอยน์เตอร์เป็นข้อมูลสำหรับเก็บตำแหน่งของหน่วยความจำ
เพื่อใช้อ้างถึงข้อมูลที่อยู่ในตำแหน่งดังกล่าว ในบางภาษาเช่น Java หรือ C\#
ก็มีการใช้งานข้อมูลชนิดนี้ในการอ้างถึงข้อมูลที่เป็นวัตถุแต่เรียกว่าเป็นการอ้างถึง (reference)

วิธีการประกาศและใช้ข้อมูลประเภทนี้ขึ้นกับภาษาโปรแกรมที่ใช้
สำหรับการทำความเข้าใจทั่วไป ข้อมูลประเภทนี้มักเขียนแทนด้วยช่องที่มีลูกศร
เพื่อแสดงการชี้ไปยังตำแหน่งของข้อมูลอื่น ๆ
ดังตัวอย่างในรูป~\ref{fig:array-example-pointer}

\begin{figure}
TODO: เพิ่มรูปนี้
\caption{ตัวอย่างการเขียนพอยน์เตอร์}
\label{fig:array-example-pointer}
\end{figure}

\section{อาร์เรย์และพอยน์เตอร์ในภาษา C/C++}
\label{sect:array-array-pointer-c}

\section{แบบฝึกหัด}

\begin{enumerate}
\item เขียนโปรแกรมลำลองสำหรับการแทรกข้อมูลในรายการ
\end{enumerate}
