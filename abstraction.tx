\chapter{การซ่อนรายละเอียด: คลาสและเท็มเพลต}

ในบทนี้เราจะศึกษาเครื่องมือของภาษา C++ ที่เราจะใช้พัฒนาโครงสร้างข้อมูล
เราจะศึกษาบางส่วนของแนวคิดการโปรแกรมเชิงวัตถุ (object-oriented programming)
และการโปรแกรมเชิงเจนเนอริก (generic programming)
ผ่านทางการปรับปรุงโครงสร้างข้อมูลสำหรับจัดเก็บรายการด้วยอาร์เรย์ที่เราได้อิมพลีเมนท์ในบทก่อน ๆ

เป้าหมายของเนื้อหาในบทนี้เพื่อที่จะปูพื้นฐานภาษา C++
ให้กับผู้อ่านให้มากพอที่จะศึกษาการเขียนโครงสร้างข้อมูลในบทต่อ ๆ ไปได้เท่านั้น
ดังนั้นรายละเอียดหลาย ๆ อย่างของการเขียนจะถูกละไว้หรือเอ่ยถึงคร่าว ๆ
\ ผู้อ่านที่สนใจจึงควรหาแหล่งอ้างอิงเพิ่มเติมด้วย

\section{การรวมกลุ่มข้อมูลและกระบวนการจัดการ}

ในส่วนนี้ เราจะปรับปรุงรูปแบบการใช้งานโครงสร้างข้อมูลให้สะดวกขึ้น
โดยการรวมตัวแปรที่เกี่ยวข้องหลายตัวเข้าด้วยกันเป็นชนิดข้อมูลใหม่
จากนั้นเราจะรวมกระบวนการจัดการเข้าไว้ดว้ย

\subsection{การรวมกลุ่มข้อมูล: {\ct struct}}

ถ้าเราพิจารณาฟังก์ชันต่าง ๆ ที่เราอิมพลีเมนท์
เราจะพบว่าทุกครั้งในการเรียกใช้เราจำเป็นจะต้องส่งพารามิเตอร์ {\ct list} ที่เก็บข้อมูล
และ {\ct size} ที่ระบุจำนวนข้อมูลในรายการไปพร้อม ๆ กันตลอด
ข้อสังเกตนี้แสดงว่าข้อมูลทั้งสองมีความเกี่ยวข้องกันมาก
ในกรณีนี้เพราะว่าเป็นข้อมูลพื้นฐานของการจัดการเกี่ยวกับรายการของเรา

สิ่งแรกที่เราสามารถปรับปรุงได้คือการรวมกลุ่มข้อมูลนี้เข้าด้วยกัน ในภาษา C++
เราสามารถประกาศชนิดข้อมูลแบบโครงสร้างโดยใช้คีย์เวิร์ด {\ct struct}
เพื่อรวมกลุ่มข้อมูลหลาย ๆ ชนิดเข้าด้วยกัน

---src[cpp]
const int max_list_size = 1000;

struct list {
  int items[max_list_size];
  int size;
};
---

ในการประกาศนั้นเราจะระบุสมาชิก (member) ของโครงสร้างที่เราประกาศ
เราสามารถประกาศชนิดข้อมูล {\ct list} ที่มีสมาชิกคืออาร์เรย์ {\ct items}
และจำนวนเต็ม {\ct size} ดังโปรแกรมด้านล่าง
(สังเกตว่าเราประกาศขนาดของอาร์เรย์ไว้ที่ค่าคงที่ {\ct max\_list\_size}
โดยให้มีขนาด 1000 ช่อง)

สังเกตว่าเราจะต้องใช้เครื่องหมาย {\ct ;} ในการปิดการประกาศ {\ct struct} ด้วย

เราสามารถประกาศตัวแปรที่มีชนิดข้อมูลเป็น {\ct list} ได้ ตัวแปรนี้จะมีสมาชิกชื่อ {\ct
  items} และ {\ct size} ซึ่งสามารถอ้างถึงได้โดยใช้โอเปอเรเตอร์ {\ct .}
ยกตัวอย่างเช่น ถ้าเราประกาศ
\begin{center}
{\ct list lst;}
\end{center}
เราจะสามารถอ้างถึง {\ct lst.items} และ {\ct lst.size} ได้

เราสามารถปรับฟังก์ชันต่าง ๆ ที่เคยต้องรับพารามิเตอร์สองตัวให้รับโครงสร้าง {\ct list}
เพียงพารามิเตอร์เดียวได้ บางฟังก์ชันที่สำคัญแสดงในโปรแกรมที่~\ref{code:abs-struct-list}

\begin{figure}
---src[cpp,บางฟังก์ชันที่ทำงานกับ {\ct list},code:abs-struct-list]
typedef int* list_itr;

void list_init(list& l)
{
  l.size = 0;
}

list_itr list_itr_end(list& l)
{
  return &l.items[l.size];
}

list_itr list_find(list& l, int x)
{
  for(int i = 0; i < l.size; ++i)
    if(l.items[i] == x)
      return &l.items[i];
  return list_itr_end(l);
}

list_itr list_append(list& l, int x)
{
  if(l.size >= max_list_size)
    throw "List overflow";
  l.items[l.size] = x;
  ++l.size;
  return &l.items[l.size-1];
}
---
\end{figure}

สังเกตว่าฟังก์ชัน {\ct list\_append}
คืนค่าเป็นตัววิ่งที่ชี้ไปที่ข้อมูลที่เพิ่งเพิ่มเข้าไปในรายการ ค่านี้โดยมากจะไม่ได้ใช้
อย่างไรก็ตามอาจจะเป็นประโยชน์ในการอ้างถึงต่อไปได้ เราจึงให้ฟังก์ชันดังกล่าวคืนค่ามา

อย่างไรก็ตาม เราต้องระวังวิธีการผ่านพารามิเตอร์ เนื่องจากโดยปกติ C++
จะส่งค่าพารามิเตอร์แบบ pass by value ดังนั้น ถ้าเราส่งค่าโครงสร้าง {\ct list}
โดยตรง จะทำให้ระบบสร้างตัวแปรประเภท {\ct list}
อีกตัวหนึ่งและคัดลอกข้อมูลจากอาร์กิวเมนท์ที่เราส่งไปยังตัวแปรชั่วคราวนี้
ซึ่งในกรณีของโครงสร้าง {\ct list} นอกจากจะทำให้โปรแกรมทำงานไม่ถูกต้องแล้ว
(เช่นในกรณีของฟังก์ชัน {\ct list\_init})
ยังเป็นการทำให้โปรแกรมมีประสิทธิภาพการทำงานต่ำลงโดยไม่จำเป็นด้วย

ตัวอย่างการเรียกใช้งานฟังก์ชันดังกล่าวแสดงในโปรแกรมต่อไปนี้

---src[cpp]
  list lst;
  list_init(lst);
  list_append(lst,10);  list_append(lst,30);  list_append(lst,20);
  if(list_find(lst,5) != list_itr_end(lst))  // find 5 in list
    cout << "found" << endl;
  else
    cout << "not found" << endl;
---

\subsection{การรวมกระบวนการเข้าเป็นฟังก์ชันสมาชิก} 

สังเกตว่าฟังก์ชันต่าง ๆ ที่ทำงานกับรายการที่เราเขียนนั้น โดยมากจะทำงานกับโครงสร้าง
{\ct list} ที่รับพารามิเตอร์มา เนื่องจากฟังก์ชันเหล่านี้ประมวลผลกับข้อมูลโดยตรง
เราจะรวมฟังก์ชันเหล่านั้นเข้าเป็นสมาชิกของโครงสร้าง {\ct list}
เพื่อให้การใช้งานทำได้สะดวกขึ้น ตัวอย่างการใช้งานฟังก์ชันเหล่านี้ผ่านทางตัวแปร {\ct
  list} แสดงในโปรแกรมถัดไป เราจะสังเกตว่าการเรียกใช้งานดูกระชับขึ้น

---src[cpp]
  list lst;
  lst.init();
  lst.append(10);  lst.append(30);  lst.append(20);
  if(lst.find(5) != lst.end())  // find 5 in list
    cout << "found" << endl;
  else
    cout << "not found" << endl;
---

เราจะเพิ่มการประกาศฟังก์ชันสมาชิกเข้าไปในการประกาศ {\ct struct}
ดังแสดงในโปรแกรมที่~\ref{code:abs-struct-list-functions}
ฟังก์ชันเหล่านี้เรียกว่า{\em ฟังก์ชันสมาชิก} ({\em member function})

นอกจากนี้ เรายังนำชนิดข้อมูล {\ct list\_itr} ย้ายไปประกาศไว้ภายในโครงสร้าง {\ct
  list} ด้วย โดยใช้ชื่อชนิดข้อมูลเป็น {\ct iterator} (สังเกตว่าเราตัดคำขึ้นต้น {\ct
  list} ทิ้งไปหมด เพื่อไม่ให้ชื่อซ้ำซ้อน) นอกจากนี้เรายังหลีกเลี่ยงการตั้งชื่อฟังก์ชันสมาชิกว่า
{\ct delete} โดยใช้ชื่อว่า {\ct del} แทน เพราะจะซ้ำกับชื่อโอเปอเรเตอร์ {\ct
  delete}

\begin{figure}
---src[cpp,การประกาศโครงสร้าง {\ct list} ที่ระบุฟังก์ชันสมาชิก,code:abs-struct-list-functions]
struct list {
  // members
  int items[max_list_size];
  int size;

  typedef int* iterator;

  // member functions
  void init();
  iterator begin();
  iterator end();
  iterator find(int x);
  iterator append(int x);
  void del(iterator p);
  void insert_after(iterator p, int x);
};
---
\end{figure}

ฟังก์ชันสมาชิกเหล่านี้ จะทำงานกับตัวแปรโครงสร้าง {\ct list}
และสามารถอ้างถึงสมาชิกที่เป็นตัวแปรเช่น {\ct size} และ {\ct items} ได้โดยตรง
รูปที่~\ref{fig:abs-member-functions}

\begin{figure}
TODO: add this
\caption{แสดงลักษณะการทำงานของฟังก์ชันสมาชิก}
\label{fig:abs-member-functions}
\end{figure}

หลังจากประกาศฟังก์ชันสมาชิกต่าง ๆ เหล่านี้ ในโครงสร้าง {\ct list} แล้ว
เราจะนิยามฟังก์ชันดังกล่าว โปรแกรมที่~\ref{code:abs-list-init-find}
แสดงการนิยามฟังก์ชัน {\ct list::init}, {\ct list::end}, และ {\ct list:find}

\begin{figure}
---src[cpp,ฟังก์ชันสมาชิก {\ct list::init}, {\ct list::end }, และ {\ct list::find},code:abs-list-init-find]
void list::init()
{
  size = 0;
}

list::iterator list::end()
{
  return &items[size];
}

list::iterator list::find(int x)
{
  for(int i = 0; i < size; ++i)
    if(items[i] == x)
      return &items[i];
  return end(l);
}
---
\end{figure}

เช่นเดียวกับการอ้างถึงสมาชิก {\ct size} และ {\ct items} ของตัวแปร {\ct l} ด้วย
{\ct l.size} และ {\ct l.items} ในการอ้างถึงฟังก์ชันสมาชิกของตัวแปรต่าง ๆ
เราจะใช้โอเปอเรเตอร์จุด ({\ct .})  ส่วนในกรณีที่เราจะอ้างถึงสมาชิกของโครงสร้างเอง
เราจะใช้โอเปอเรเตอร์ {\ct ::} เช่น {\ct list::init} และ {\ct
  list::iterator}

สังเกตว่าภายในฟังก์ชันสมาชิก {\ct list::init} เราสามารถอ้างถึงสมาชิก {\ct size}
ได้โดยตรง ตัวแปรดังกล่าวจะอ้างถึงสมาชิก {\ct size}
ของตัวแปรที่เราเรียกฟังก์ชันเหล่านี้ผ่าน เช่น ถ้าเราเรียก {\ct lst.init()} ตัวแปร
{\ct size} ในฟังก์ชันสมาชิกที่เราเขียนจะหมายถึง {\ct lst.size}

---q ฟังก์ชันสมาชิกอื่น ๆ
เขียนฟังก์ชันสมาชิกอื่น ๆ ของโครงสร้าง {\ct list} และทดสอบกับโปรแกรมตัวอย่าง
---

\section{การซ่อนรายละเอียด: {\ct class}}

ในส่วนที่แล้วเราพัฒนาชนิดข้อมูล {\ct list}
ที่รวมข้อมูลและกระบวนการที่ทำงานกับข้อมูลไว้ด้วยกัน ทำให้การใช้งานต่าง ๆ
สะดวกขึ้นและเขียนโปรแกรมได้อย่างกระชับขึ้น การสร้างชนิดข้อมูล {\ct list} ที่เราทำนี้
เป็นส่วนหนึ่งของการจัดการกับความซับซ้อนของซอฟต์แวร์ โดยการแบ่งงานเป็นส่วนย่อย ๆ
และพัฒนาโปรแกรมเพื่อรับผิดชอบงานแต่ละส่วนแยกกันไป

อย่างไรก็ตาม สังเกตว่าในการเขียนที่ผ่านมา
เราไม่สามารถรับประกันว่างานที่แบ่งออกมาพัฒนาเป็นส่วน ๆ นั้น
จะถูกแบ่งไปดูแลแยกขาดจากกัน ยกตัวอย่างเช่น
อาจมีส่วนหนึ่งของระบบที่ต้องการแทรกข้อมูลในรายการเพื่อเป็นรายการแรก ซึ่งโครงสร้าง
{\ct list} ที่เราได้พัฒนาไว้ ยังไม่ได้รองรับ
โปรแกรมเมอร์ผู้รับผิดชอบในส่วนนั้นก็อาจจะเปิดดูส่วนของโปรแกรมที่เราเขียนขึ้น
และเขียนโปรแกรมในลักษณะด้านล่างขึ้นมาเพื่อทำงานดังกล่าว

---src[cpp]
for(int i = lst.size-1; i >= 0; --i)
  lst.items[i+1] = lst.items[i];
lst.items[0] = x;
++lst.size;
---

โปรแกรมดังกล่าวสามารถทำงานได้ถูกต้อง
อย่างไรก็ตามโปรแกรมไม่มีการตรวจสอบขอบเขตของอาร์เรย์เลย
ทำให้โปรแกรมอาจจะเกิดความผิดพลาดได้ในภายหลัง สังเกตว่า
ถ้าโปรแกรมเมอร์คนที่เขียนโปรแกรมดังกล่าว เขียนผิดพลาด (เช่น ลืมเพิ่มค่า {\ct
  lst.size} ก็อาจจะมีผลกระทบไปกับทุกส่วนของระบบที่มีการใช้งานรายการนี้)

อย่างไรก็ตาม
ความยากของการพัฒนาซอฟต์แวร์ขนาดใหญ่ไม่ได้เกิดจากความซับซ้อนเพียงอย่างเดียว
แต่ระบบขนาดใหญ่ยังมีความต้องการในการปรับเปลี่ยนตลอดเวลา
เพื่อให้สามารถรองรับความต้องการของผู้ใช้ได้

สมมติว่าในอนาคต มีความจำเป็นต้องเปลี่ยนรูปแบบในการเก็บข้อมูลรายการใหม่
จากที่เคยใช้อาร์เรย์ มาใช้โครงสร้างข้อมูลแบบอื่นที่มีประสิทธิภาพมากกว่า
ถ้าเรายอมให้โปรแกรมในส่วนต่าง ๆ พัฒนากระบวนการจัดการรายการได้โดยเป็นอิสระ
เราจะต้องเข้าไปแก้ไขโปรแกรมต่าง ๆ
เหล่านั้นเพื่อให้การเปลี่ยนแปลงโครงสร้างภายในของรายการเป็นไปได้

ยิ่งไปกว่านั้น ถ้าเราเปลี่ยนแปลงโปรแกรมโดยที่ยังใช้ตัวแปรสมาชิก {\ct items} หรือ {\ct
  size} อยู่แต่ใช้ในความหมายอื่น โปรแกรมในส่วนอื่น ๆ
ที่เรียกใช้ข้อมูลจากรายการผ่านทางสมาชิกดังกล่าวโดยตรงก็จะยังสามารถคอมไพล์ได้
รวมถึงอาจจะทำงานได้โดยที่เราไม่ทราบว่ามีความผิดพลาดซ่อนอยู่
ความผิดพลาดพวกนี้ก็เป็นเสมือนระเบิดเวลารอการระเบิดเท่านั้นเอง

ภาษา C++ ได้พัฒนามาจากภาษา C
โดยมีเป้าหมายที่จะทำให้ภาษาโปรแกรมช่วยจัดการกับความซับซ้อนได้ดีขึ้น
หนึ่งในความสามารถที่เพิ่มเข้ามาคือการรวมกระบวนการเข้ากับข้อมูล ดังที่เราได้ทดลองใช้แล้ว
อีกหนึ่งความสามารถที่สำคัญไม่แพ้กัน
ก็คือความสามารถในการกำหนดขอบเขตการเข้าใช้สมาชิกของชนิดข้อมูลที่เราได้สร้างขึ้น เช่น
ในกรณีนี้ เราสามารถระบุได้ว่าสมาชิก {\ct items} และ {\ct size}
เป็นสมาชิกภายในของส่วนนี้ และไม่ยอมให้โปรแกรมในส่วนอื่น ๆ เข้าถึงได้โดยตรง

เราจะศึกษาความสามารถดังกล่าวโดยการพัฒนาคลาส ({\ct class})
สำหรับจัดการกับรายการ  

ในภาษา C++ คลาส เป็นการสร้างชนิดข้อมูลใหม่ ในลักษณะเดียวกันกับ {\ct struct} จริง
ๆ แล้ว โครงสร้างสองแบบนี้มีการใช้งานเหมือนกันทุกประการ
ยกเว้นเกณฑ์มาตรฐานในการควบคุมการอ้างถึงสมาชิก
สำหรับตัวแปรที่ประกาศขึ้นจากคลาสหรือโครงสร้าง เรานิยมเรียกว่า{\em วัตถุ}

เราจะนิยามคลาสได้ในลักษณะเดียวกับการนิยาม {\ct struct} แต่สมาชิกต่าง ๆ
ที่เรานิยามในคลาสจะไม่สามารถถูกอ้างถึงได้จากโปรแกรมที่อยู่ ``ภายนอก'' คลาส
ยกเว้นจะเป็นส่วนที่เราระบุไว้ พิจารณาตัวอย่างโปรแกรมด้านล่างเพื่อเปรียบเทียบ

---src[cpp]
struct test1 { int a;  int f() { return a+1; } };
class test2 { int a; int f() { return a+1; } };

test1 s1;  test2 s2;
cout << s1.a << endl;       // works
cout << s2.a << endl;       // compilation error
cout << s1.f() << endl;     // works
cout << s2.f() << endl;     // compilation error
---

สังเกตว่าฟังก์ชันสมาชิก {\ct test2::f } สามารถอ้างถึงสมาชิก {\ct a} ได้
แต่โปรแกรมภายนอกไม่สามารถอ้างถึงได้

ในการระบุขอบเขตการอ้างถึงสมาชิกในคลาส เราจะใช้คีย์เวิร์ด {\ct private} และ {\ct
  public} สมาชิกที่อยู่หลักการระบุ {\ct public}
เป็นส่วนสาธารณะจะถูกอ้างถึงจากส่วนใด ๆ ของโปรแกรมก็ได้ ส่วนที่ถูกระบุว่าเป็น {\ct
  private} จะเป็นสมาชิกส่วนตัวและถูกอ้างถึงได้จากสมาชิกของคลาสเท่านั้น
ในกรณีที่เราไม่ได้ระบุอะไร สมาชิกของคลาสจะเป็นสมาชิกส่วนตัว \ \ \ ในทางกลับกัน
สำหรับการนิยามโครงสร้างนั้น สมาชิกที่ไม่ได้ระบุขอบเขตการเข้าถึง
จะถูกพิจารณาเป็นสมาชิกสาธารณะ

พิจารณาคลาส {\ct test2}
ที่แก้ไขแล้วด้านล่างที่เปิดให้ฟังก์ชัน {\ct test2::f} สามารถเข้าถึงได้จากทุก ๆ ที่
สังเกตว่าเราเพิ่มฟังก์ชัน {\ct set\_a} เพื่อให้เราสามารถกำหนดค่าให้กับ {\ct a}
ได้ด้วย (ไม่เช่นนั้นเราจะไม่มีทางกำหนดค่าให้กับ {\ct a} ได้เลย)

---src[cpp]
class test2 { 
  int a; 
public: 
  void set_a(int aa) { a = aa; }
  int f() { return a+1; } 
};
---

\subsection{คลาสสำหรับตัวนับ}
เราจะเขียนคลาส {\ct counter} สำหรับใช้เป็นตัวนับ
คลาสดังกล่าวไม่ได้มีความซับซ้อนในการเขียนจึงเป็นตัวอย่างที่ดีในการเริ่มต้น

ในการออกแบบคลาสนั้น เราจำเป็นจะต้องพิจารณาส่วนที่ผู้ใช้จะเรียกใช้งานก่อน
ฟังก์ชันสมาชิกในกลุ่มนี้จะเป็นอินเทอร์เฟสของวัตถุในคลาส ที่ผู้ใช้งานจะเรียกใช้
อินเทอร์เฟสของตัวนับนั้นไม่ซับซ้อน ดังแสดงในรายการด้านล่าง
\begin{itemize}
\item Init($z$) -- กำหนดค่าเริ่มต้นใหักับตัวนับ โดยให้มีค่าเท่ากับ $z$
\item Inc() -- เพิ่มค่าตัวนับขึ้น 1
\item Get() -- คืนค่าปัจจุบันของตัวนับ
\end{itemize}

สังเกตว่าโดยทั่วไปแล้ว เรามักกำหนดให้ตัวนับมีค่าเริ่มต้นเป็น 0
จึงเป็นการเหมาะสมที่จะเพิ่มฟังก์ชันสมาชิกที่ทำงานดังกล่าวไว้ด้วย
\begin{itemize}
\item Init --- กำหนดค่าเริ่มต้นให้กับตัวนับ โดยให้มีค่าเท่ากับ 0
\end{itemize}

เราจะนิยามคลาสดังกล่าวในโปรแกรมที่~\ref{code:abs-counter} สมาชิกข้อมูลของคลาส
{\ct counter} มีเพียงแค่ค่าตัวนับที่นับได้ {\ct c} เนื่องจากฟังก์ชันสมาชิกของคลาสนี้สั้น
เราจึงนิยามฟังก์ชันสมาชิกเหล่านี้ไว้ภายในการนิยามคลาส
สำหรับฟังก์ชันที่นิยามภายในคลาสเหล่านี้ คอมไพลเลอร์ภาษา C++ จะแปลงให้เป็นฟังก์ชันแบบ
inline โดยอัตโนมัติ

สังเกตการประกาศอาร์กิวเมนท์ปริยายในฟังก์ชันสมาชิก {\ct counter::init}
ถ้ามีการเรียกคำสั่งที่ไม่ได้ระบุค่าพารามิเตอร์ {\ct z} จะเปรียบเสมือนส่งค่า {\ct 0}
เป็นอาร์กิวเมนท์  

ในคลาส เรานิยมประกาศสมาชิกที่เป็นสาธารณะก่อน
เพราะข้อมูลส่วนอินเทอร์เฟสจะเป็นสิ่งสำคัญกว่าสำหรับผู้ที่นำคลาสของเราไปใช้

---src[cpp,นิยามของคลาส {\ct counter},code:abs-counter]
class counter {
public:
  void init(int z=0) { c = z; }
  void inc() { ++c; }
  int get() { return c; }
private:
  int c;
};
---

\subsection{ตัวสร้าง: constructor}
ฟังก์ชันสมาชิก {\ct counter::init} ทำหน้าที่เฉพาะ คือกำหนดค่าเริ่มต้นให้กับวัตถุในคลาส
{\ct counter}

---q *
ถ้าเราลืมเรียกฟังก์ชัน {\ct init} ก่อนการใช้งานตัวนับจะเกิดอะไรขึ้น?
---

สังเกตว่า ระหว่างที่เราประกาศตัวแปร จนถึงก่อนที่จะเรียกใช้ฟังก์ชัน {\ct init} นั้น
สถานะของวัตถุนั้นเป็นสถานะที่ไม่มีความหมาย เนื่องจากยังไม่มีการกำหนดค่า \ \ ในภาษา
C++ เราสามารถกำหนดฟังก์ชันสมาชิกพิเศษให้ทำงานทันที
เมื่อมีการประกาศใช้งานวัตถุของคลาสนั้น ๆ  ฟังก์ชันนี้จะทำหน้าที่เหมือนกับฟังก์ชัน {\ct init}  แต่เราจะสามารถรับประกันได้ว่าเมื่อเรานิยามวัตถุแล้ว วัตถุนั้นจะอยู่ในสภาพที่ ``พร้อมใช้งาน'' ทันที

ฟังก์ชันดังกล่าว เรียกว่า{\em ตัวสร้าง} ({\em constructor})
โดยเราสามารถระบุฟังก์ชันดังกล่าวโดยตั้งชื่อให้เหมือนกับชื่อคลาส
ตัวอย่างของการประกาศตัวสร้าง
และการใช้งานแสดงในโปรแกรมที่~\ref{code:abs-counter-cons} \ ในโปรแกรมดังกล่าว
เมื่อเราประกาศวัตถุ {\ct a} และ {\ct b} ฟังก์ชันสมาชิก {\ct counter::counter}
จะถูกเรียกใช้งาน

---src[cpp,นิยามของคลาส {\ct counter} ที่ใช้ตัวสร้าง และตัวอย่างการใช้งาน,code:abs-counter-cons]
class counter {
public:
  counter(int z=0) { c = z; }
  void inc() { ++c; }
  int get() { return c; }
private:
  int c;
};

  //...
  counter a, b(10);
  cout << a.get() << endl;    // outputs 0
  b.inc(); a.inc();
  cout << b.get() << endl;    // outputs 11
  cout << a.get() << endl;    // outputs 1
---

สังเกตว่าภายในตัวสร้าง {\ct counter::counter} จริง ๆ
แล้วสิ่งที่เราทำก็เป็นการสร้างตัวแปร {\ct c} นั่นเอง
เราสามารถระบุความตั้งใจดังกล่าวให้ชัดเจนโดยระบุคำสั่งดังกล่าวให้เป็นการเรียกตัวสร้างของ
{\ct c} ดังส่วนของโปรแกรมด้านล่างนี้ \ เราจะได้เห็นการใช้งานในลักษณะนี้ต่อ ๆ ไป

---src[cpp]
  //...
  counter(z=0) : c(z) {}
---

ข้อควรระวังในการใช้การกำหนดค่าลักษณะนี้คือ
สมาชิกจะได้รับการกำหนดค่า{\bf ตามลำดับที่นิยาม}ในคลาส
ไม่ใช่ตามลำดับที่เราเขียนในรายการกำหนดค่าเริ่มต้น

\subsection{คลาส {\ct list}}

เราสามารถปรับการนิยามโครงสร้าง {\ct list} ให้ซ่อนสมาชิก {\ct items} และ {\ct
  size} ได้ดังโปรแกรมที่~\ref{code:abs-class-list}
สังเกตว่าเราเปลี่ยนไปนิยามคลาส และประกาศฟังก์ชันสมาชิกต่าง ๆ แบบ {\ct public}

เราต้องการให้ผู้ใช้สามารถเข้าถึงขนาดของรายการได้ เราจึงสร้างฟังก์ชันสมาชิก {\ct
  list::size} สังเกตว่าชื่อดังกล่าวตรงกับชื่อของตัวแปรที่เราเคยใช้
เพื่อแก้ปัญหาดังกล่าวเราอาจจะใช้ฟังก์ชันสมาชิกเป็น {\ct list::get\_size}
อย่างไรก็ตาม เราต้องการทำให้อินเทอร์เฟสเรียบง่าย ดังนั้นเราจะคงอินเทอร์เฟสเป็น {\ct
  list::size} ไว้ แต่จะเปลี่ยนชื่อสมาชิกส่วนตัวแทน

หนังสือเล่มนี้จะทำตามคำแนะนำในการตั้งชื่อสมาชิกส่วนตัว โดยจะตามชื่อด้วยเครื่องหมายขีดล่าง
นั่นคือเราจะเปลี่ยนชื่อจาก {\ct items} และ {\ct size} เป็น {\ct items\_} และ
{\ct size\_}

สังเกตการใช้งานตัวสร้างเพื่อกำหนดค่าเริ่มต้นให้กับตัวแปร {\ct size\_}
เราได้ย้ายนิยามของฟังก์ชันสมาชิกที่เกี่ยวกับตัววิ่งมานิยามภายในการนิยามคลาสเพราะว่าเป็นฟังก์ชันที่สั้น
\ ส่วนการนิยามฟังก์ชันสมาชิกอื่น ๆ ของโครงสร้างนั้นไม่มีการเปลี่ยนแปลง
ยกเว้นการอ้างสมาชิก {\ct items\_} และ {\ct size\_}

\begin{figure}
---src[cpp,นิยามคลาส {\ct list},code:abs-class-list]
class list {
public:
  typedef int* iterator;

  list() : size_(0) {}

  int size() { return size_; }
  iterator begin() { return &items_[0]; }
  iterator end() { return &items_[size_]; }

  iterator find(int x);
  iterator append(int x);
  void del(iterator p);
  void insert_after(iterator p, int x);

private:
  int items_[max_list_size];
  int size_;
};
---
\end{figure}

\section{รายการบนอาร์เรย์ที่เปลี่ยนขนาดได้}
คลาส {\ct list} ที่เราพัฒนาขึ้นเก็บข้อมูลบนอาร์เรย์ที่มีขนาดเท่ากับค่าคงที่ {\ct
  max\_list\_size} ในส่วนนี้เราจะปรับปรุงคลาสดังกล่าว
ให้ผู้ใช้สามารถระบุขนาดของอาร์เรย์ที่ต้องการใช้ได้เมื่อเริ่มสร้าง
\ \ การปรับปรุงนี้จะทำให้เราได้ศึกษาความสามารถอื่น ๆ ของภาษา C++

---q *
เราจะต้องปรับตัวสร้างของคลาส list อย่างไร?
---

แทนที่เราจะใช้อาร์เรย์ เราจะใช้พอยน์เตอร์ไปยัง {\ct int}
ชี้ไปยังอาร์เรย์ที่เราจะจองให้มีขนาดตามที่ผู้ใช้ระบุ
เราจะปรับสมาชิกส่วนตัวของคลาสและตัวสร้างเป็นดังโปรแกรมที่~\ref{code:abs-list-adj-array}
สังเกตว่าฟังก์ชัน {\ct list:list} ที่เป็นตัวสร้างจะรับพารามิเตอร์ {\ct max\_size}
เพื่อนำมาจองอาร์เรย์ เราใส่ค่าปริยายของขนาดของอาร์เรย์ไว้เท่ากับค่าคงที่ {\ct
  default\_max\_list\_size}

\begin{figure}
---src[cpp,นิยามสมาชิกส่วนตัว และตัวสร้างของรายการที่เลือกขนาดอาร์เรย์ได้,code:abs-list-adj-array]
const int default_max_list_size = 1000;

class list {
public:
  list(int max_size=default_max_list_size);
  // ... 
private:
  int* items_;
  int size_;
  int max_size_;
};

list::~list(int max_size)
  : size_(0), max_size_(max_size) 
{
  items_ = new int[max_size_];
}
---
\end{figure}

---q *
สังเกตว่าเรากำหนดค่าคงที่ {\ct default\_max\_list\_size} ไว้ก่อนการนิยามคลาส
ถ้าเราประกาศค่าคงที่ดังกล่าวไว้ภายในคลาสจะเป็นอย่างไร?
ทดลองปรับโปรแกรมและพิจารณาข้อผิดพลาดที่คอมไพเลอร์แจ้ง ทำไมจึงเกิดปัญหานั้น?
---

ในโปรแกรมที่เราเขียนขึ้น เมื่อเราประกาศวัตถุของคลาส {\ct list}
ตัวสร้างจะจองเนื้อที่หน่วยความจำเป็นเนื้อที่อาร์เรย์และกำหนดให้พอยน์เตอร์ {\ct items\_}
ชี้ไปที่อาร์เรย์นั้น \ อย่างไรก็ตามเมื่อวัตถุนั้นหมดขอบเขตการใช้งานแล้ว
ถ้าเราไม่ได้ดำเนินการอะไร จะไม่มีการคืนหน่วยความจำคืนกลับให้ระบบ
ทำให้เกิดสภาวะที่เรียกว่าหน่วยความจำรั่ว (memory leak) \ เพื่อหลีกเลี่ยงปัญหาดังกล่าว
ถ้าเราจองหน่วยความจำเมื่อเราสร้างวัตถุ เราจะต้องคืนหน่วยความจำก่อนที่วัตถุนั้นถูกทำลาย
เราจะทำโดยเขียนฟังก์ชันพิเศษที่เรียกว่าตัวทำลาย

\subsection{ตัวทำลาย (destructor), ตัวสร้างสำหรับการคัดลอก (copy constructor), และฟังก์ชันกำหนดค่า (assignment operator)}
คลาสในภาษา C++ สามารถระบุฟังก์ชันพิเศษเรียกว่า{\em ตัวทำลาย} ที่ทำหน้าที่เก็บกวาด
เช่น คือทรัพยากรที่ได้จองไว้ ฟังก์ชันดังกล่าวจะถูกเรียกโดยอัตโนมัติก่อนที่วัตถุจะถูกทำลาย
ตัวทำลาย จะมีชื่อเหมือนกับคลาสแต่ขึ้นต้นด้วย {\ct\char`\~} (เครื่องหมาย tilde
$\sim$) เช่น {\ct list::\char`\~list}

เราจะประกาศฟังก์ชันดังกล่าวในนิยามคลาส
และเขียนฟังก์ชันดังกล่าวได้ดังโปรแกรม~\ref{code:abs-list-destructor}

\begin{figure}
---src[cpp,ตัวทำลายของคลาส {\ct list},code:abs-list-destructor]
class list {
public:
  //...
  list(int max_size=default_max_list_size);
  ~list();
  //...
};

list::~list()
{
  delete [] items_;
}
---
\end{figure}

อย่างไรก็ตาม คลาส {\ct list} ที่เราเขียนขึ้น ยังมีการทำงานที่ผิดพลาดอยู่
ทั้งนี้เนื่องมาจากพฤติกรรมมาตรฐานของการคัดลอกวัตถุ เพื่อให้เห็นการทำงานชัดเจน
เราจะปรับตัวสร้างและตัวทำลายให้พิมพ์ข้อความว่า {\ct "Constructor called"} และ
{\ct "Destructor called"} ตามด้วยตำแหน่งในหน่วยความจำของสมาชิก {\ct items}

พิจารณาโปรแกรมด้านล่างนี้
---src[cpp]
int main()
{
  list a, b;

  a.append(1);
  b = a;
  b.append(2);
}
---

เมื่อโปรแกรมทำงาน ให้ผลลัพธ์ดังด้านล่าง
{\latintext
\begin{verbatim}
Constructor called 0x9786008
Constructor called 0x9786fb0
Destructor called 0x9786008
Destructor called 0x9786008
\end{verbatim}
}
ในหลาย ๆ ระบบปฏิบัติการโปรแกรมจะถูกปิดลงเพราะเกิดข้อผิดพลาด

---q *
ปัญหาดังกล่าวเกิดขึ้นเนื่องจากอะไร?

(คำใบ้: พิจารณาตำแหน่งของหน่วยความจำของ {\ct items\_} เมื่อมีการเรียกตัวทำลาย
---

คลาสใน C++ มีฟังก์ชันพิเศษสำหรับจัดการกับคลาสมากมาย เช่น การกำหนดค่าเริ่มต้น การทำลาย
และการกำหนดค่าผ่านทางเครื่องหมายเท่ากับ เป็นต้น ถ้าเราไม่ระบุฟังก์ชันเล่านี้ C++
จะจัดการดำเนินการให้เราอัตโนมัติ ซึ่งโดยมากแล้วก็จะทำงานได้ถูกต้อง อย่างไรก็ตาม
ผลที่ได้ก็ไม่ตรงกับที่เราต้องการ

โดยทั่วไปแล้ว ถ้าคลาสของเรามีสมาชิกที่จองทรัพยากร เช่นจองหน่วยความจำ
หรือเปิดปิดแฟ้มข้อมูล เมื่อมีการสร้างหรือใช้งาน และในตัวทำลายมีการคืนทรัพยากรเหล่านั้น
มีฟังก์ชันพิเศษสองฟังก์ชันที่เราต้องเขียน เพื่อให้คลาสทำงานได้ถูกต้อง

พิจารณากรณีของคลาส {\ct counter} สมมติเรามีตัวแปร {\ct a} และ {\ct b}
เป็นข้อมูลประเภทดังกล่าว เมื่อเราสั่ง
\begin{center}
{\ct a = b;}
\end{center}
สิ่งที่เกิดขึ้นก็คือมีความพยายามจะกำหนดค่าให้กับวัตถุ {\ct a} ด้วยวัตถุ {\ct b}
เนื่องจากไม่มีข้อมูลระบุว่าต้องดำเนินการเช่นใด ระบบจะคัดลอกข้อมูลของทุก ๆ สมาชิกของ
{\ct b} ไปยังวัตถุ {\ct a}  สิ่งที่เกิดขึ้นเหมือนกับเราสั่ง {\ct a.c = b.c}

---q *
พิจารณาการสั่ง {\ct a = b;} ในกรณีที่ตัวแปรทั้งสองเป็นวัตถุของคลาส {\ct list}
อะไรจะเกิดขึ้น?
---

เราสามารถเปลี่ยนการทำงานของคำสั่งดังกล่าวให้คัดลอกข้อมูลให้ถูกต้อง
ได้โดยเขียนฟังก์ชันกำหนดค่า (assignment) ฟังก์ชันดังกล่าวคือฟังก์ชันโอเปอเรเตอร์เท่ากับ
{\ct operator=}) นี่คือฟังก์ชันสมาชิกแรกที่เราต้องเขียน

พิจารณาโปรแกรมตัวอย่างด้านล่างนี้

---src[cpp]
void m(list a) { cout << a.size() << endl; }

main()
{
  list b;
  m(b);
  cout << "endding" << endl;
}
---

ผลลัพธ์ของโปรแกรมดังกล่าวเป็นดังด้านล่าง
{\latintext
\begin{verbatim}
Constructor called0x839b008
0
Destructor called0x839b008
endding
Destructor called0x839b008
\end{verbatim}
}
จากนั้นโปรแกรมก็เกิดปัญหาและถูกระบบปฏิบัติการปิดไปโดยอัตโนมัติ (crash)

---q ความผิดพลาดในการส่งพารามิเตอร์
อธิบายคร่าว ๆ ว่าความผิดพลาดดังกล่าวเกิดขึ้นได้เพราะอะไร?
---

เมื่อเราเรียกฟังก์ชัน {\ct m} เราส่งตัวแปร {\ct b} เป็นอาร์กิวเมนท์ อย่างไรก็ตาม
เนื่องจากพารามิเตอร์ {\ct a} เป็นการส่งพารามิเตอร์แบบ by value ทำให้มีการ
``สร้าง'' วัตถุ {\ct a} ขึ้นมาใหม่จากวัตถุ {\ct b}
โดยใช้ตัวสร้างที่นิยมเรียกว่าตัวสร้างสำหรับการคัดลอก (copy constructor)

เนื่องจากเราไม่ได้เขียนวิธีการสร้างดังกล่าวไว้ ระบบจึงสร้าง {\ct list}
ใหม่โดยการคัดลอกข้อมูลจากทุก ๆ สมาชิกของ {\ct b} ไปให้กับวัตถุใหม่ 
ซึ่งจะทำให้เกิดปัญหาเช่นเดียวกับกรณีฟังก์ชันโอเปอเรเตอร์เท่ากับ

ดังนั้นเพื่อให้การคัดลอกเป็นไปได้ เราจะต้องเขียนฟังก์ชันสมาชิก
\begin{center}
{\ct list\& list::list(const list\& lst)}
\end{center}
เพื่อสร้าง {\ct list} ใหม่จาก {\ct lst}
\ \ สังเกตว่าการประกาศของตัวสร้างสำหรับการคัดลอกจะต้องอยู่ในรูปแบบเช่นนี้ นั่นคือ
รับพารามิเตอร์แบบ reference (เพื่อไม่ให้เกิดการคัดลอกซ้อน) และเป็นข้อมูลชนิดค่าคงที่
เพื่อรับประกันว่าจะเกิดการคัดลอกอย่างเดียวเท่านั้นไม่มีการแก้ไขข้อมุลของ {\ct lst}
นี่คือฟังก์ชันอีกฟังก์ชันที่เราต้องเขียน

ในโปรแกรมที่~\ref{code:abs-list-copy-cons}
เราจะประกาศฟังก์ชันสมาชิกทั้งสอง ซึ่งจะเรียกใช้งานฟังก์ชันส่วนตัว {\ct
  list::copy\_from} พร้อมกับนิยามฟังก์ชันตัวสร้างสำหรับการคัดลอก

\begin{figure}
---src[cpp,การประกาศฟังก์ชันสมาชิกที่เกี่ยวกับการคัดลอก,code:abs-list-copy-cons]
class list {
public:
  // ...
  list(const list& lst);
  list& operator=(const list& lst);
  // ...
private:
  // ...
  void copy_from(const list& lst);
};

void list::copy_from(const list& lst)
{
  size_ = lst.size_;
  max_size_ = lst.max_size_;
  items_ = new int[max_size_];
  for(int i=0; i<size_; ++i)
    items_[i] = lst.items_[i];
}

list::list(const list& lst)
{
  copy_from(lst);
}
---
\end{figure}

สำหรับฟังก์ชันกำหนดค่านั้นจะซับซ้อนกว่าเล็กน้อย
ทั้งนี้เพราะว่าผู้ใช้สามารถสั่งงานคำสั่งเช่น {\ct a=a;} ได้
\ เราจึงต้องระวังไม่คัดลอกข้อมูลในกรณีดังกล่าว

---q *
สังเกตว่าฟังก์ชันกำหนดค่าจะต้องคืนหน่วยความจำของอาร์เรย์ที่จองไว้ก่อน
ถ้าเขียนโอเปอเรเตอร์เท่ากับให้ทำงานในลักษณะเดียวกับตัวสร้างสำหรับการค้ดลอก
จะมีผลอย่างไรถ้าผู้ใช้สั่ง {\ct a=a;} ?
---

เราจะตรวจสอบได้อย่างไร?  คลาสในภาษา C++ จะมีสมาชิกพิเศษชื่อ {\ct this}
ซึ่งจะเป็นพอยน์เตอร์ชี้ไปที่วัตถุที่ฟังก์ชันกำลังทำงานอยู่ \ สมาชิกนี้มีประโยชน์มากในหลาย ๆ
กรณี แต่ในที่นี้เราจะใช้เพื่อตรวจสอบว่าพารามิเตอร์ {\ct lst} เป็นวัตถุเดียวกับ {\ct
  this} หรือเปล่า \ นอกจากนี้เรายังใช้ {\ct this}
ในการคืนตัววัตถุเองเป็นผลลัพธ์ของโอเปอเรเตอร์ด้วย
โปรแกรมแสดงในโปรแกรมที่~\ref{code:abs-list-assignment}

\begin{figure}
---src[cpp,ฟังก์ชันสำหรับโอเปอเรเตอร์เท่ากับ,code:abs-list-assignment]
list& list::operator=(const list& l)
{
  if(this == &l)
    return *this;

  delete [] items_;
  copy_from(l);
  return *this;
}
---
\end{figure}

สังเกตว่าฟังก์ชันกำหนดค่าคืนค่าเป็นข้อมูลชนิด {\ct list\&} และเราคืนค่า {\ct
  *this} แทนวัตถุที่ได้รับค่าออกไป เพื่อให้เราสั่งคำสั่งเช่น {\ct
  (a=b).append(10); } ได้


\section{โครงสร้างข้อมูลสำหรับข้อมูลชนิดใดก็ได้: แม่แบบ}
ที่ผ่านมาเราได้พัฒนาโครงสร้างข้อมูลสำหรับจัดการกับรายการที่มีข้อมูลเป็นจำนวนเต็ม
โดยเก็บข้อมูลบนอาร์เรย์ อย่างไรก็ตามถ้าพิจารณาให้ดีเราจะพบว่าโปรแกรมที่เราเขียน
ไม่จำเป็นต้องทำงานกับ {\ct int} เท่านั้น แต่สามารถทำงานกับข้อมูลชนิดอื่น ๆ ได้ด้วย

จากโปรแกรมที่เราเขียน เราจะพิจารณาว่าเราดำเนินการอะไรกับข้อมูลประเภท {\ct int}
ที่เราเก็บในรายการบ้าง
\begin{itemize}
\item เราสามารถอาร์เรย์ของ {\ct int}
\item เรากำหนดค่าให้กับ {\ct items\_}
\item เราเปรียบเทียบข้อมูลด้วยโอเปอเรเตอร์ {\ct ==} (ในฟังก์ชัน {\ct list::find}
\end{itemize}
กระบวนการเหล่านี้เป็นอินเทอร์เฟสของวัตถุที่เราจะเก็บใน {\ct list} ที่โปรแกรมของ
{\ct list} เรียกใช้ ดังนั้น ถ้าเรามีคลาสใด ๆ ที่รองรับกระบวนการเหล่านี้
โปรแกรมที่เราเขียนก็ควรจะทำงานด้วยได้โดยไม่เกิดข้อผิดพลาดระหว่างการคอมไพล์และการทำงาน
แต่ผลของการทำงานจะถูกต้องหรือไม่ก็ขึ้นกับว่ากระบวนการต่าง ๆ ข้างต้นนี้ของคลาสนั้น ๆ
ทำงานด้วยความหมายตรงตามที่เราคาดไว้หรือไม่

ภาษา C++ รองรับการเขียนโปรแกรมที่ทำงานได้กับชนิดข้อมูลใด ๆ ก็ได้ผ่านทาง{\em แม่แบบ}
({\em template})
\ การเขียนโปรแกรมในลักษณะดังกล่าวนิยมเรียกว่าการโปรแกรมเชิงเจเนอริค (generic
programming)

พิจารณาตัวอย่างฟังก์ชัน {\ct my\_swap} ที่ทำหน้าที่สลับค่าของ {\ct
  int} แสดงดังด้านล่างนี้\footnote{เราตั้งชื่อฟังก์ชันว่า {\ct my\_swap}
  เพื่อจะได้ไม่ซ้ำกับฟังก์ชัน {\ct std::swap} ในไลบรารีมาตรฐาน}

---src[cpp]
void my_swap(int& a, int& b)
{
  int temp = a;  a = b;  b = temp;
}
---

เราสามารถเขียนใหม่โดยใช้แม่แบบ เพื่อให้ฟังก์ชันดังกล่าวทำงานกับข้อมูลคลาสใด ๆ ก็ได้
โดยเพิ่มการระบุให้คลาสของข้อมูลเป็นพารามิเตอร์ของแม่แบบ ดังแสดงด้านล่าง

---src[cpp]
template <class T> 
void my_swap(T& a, T& b)
{
  T temp = a;  a = b;  b = temp;
}
---

ฟังก์ชันดังกล่าวสามารถทำงานกับชนิดข้อมูลใด ๆ ก็ได้ ที่รองรับฟังก์ชันกำหนดค่า
(นั่นรวมไปถึงคลาส list ที่เราเขียนไว้ในส่วนที่แล้ว)
สังเกตว่าฟังก์ชันดังกล่าวถูกนิยามโดยมีชนิดข้อมูล {\ct T} เป็นพารามิเตอร์ของแม่แบบ
ในการเรียกใช้งาน C++ จะเลือกพารามิเตอร์ {\ct T} ให้โดยอัตโนมัติ ดังแสดงด้านล่าง

---src[cpp]
  int a = 10; int b = 100;
  my_swap(a,b);
  double ad = 10.7; double bd = 112.233;
  my_swap(ad,bd);
---

สิ่งที่เกิดขึ้นเมื่อเราเรียกใช้งานแม่แบบก็คือคอมไพล์เลอร์จะสร้างคลาสหรือฟังก์ชันเฉพาะเจาะจง
สำหรับชนิดข้อมูลที่เราระบุเป็นพารามิเตอร์ จากตัวอย่างข้างต้นคอมไพเลอร์จะสร้างฟังก์ชัน
{\ct my\_swap(int\&, int\&)} และ {\ct my\_swap(double\&, double\&)}
เพื่อรองรับการเรียกใช้งานฟังก์ชันแม่แบบแต่ละครั้ง

คลาส {\ct list} สามารถปรับเปลี่ยนให้เป็นคลาสแม่แบบ {\ct list}
ที่มีชนิดข้อมูลของข้อมูลในรายการเป็นพารามิเตอร์ ได้ไม่ยาก
ส่วนนิยามแม่แบบแสดงในโปรแกรมที่~\ref{code:abs-list-template-decl}
\ ฟังก์ชันสมาชิกบางส่วนแสดงในโปรแกรมที่~\ref{code:abs-list-template-def}

\begin{figure}
---src[cpp,คลาสแม่แบบ {\ct list},code:abs-list-template-decl]
const int default_max_list_size = 1000;

template<class T>
class list {
public:
  typedef T* iterator;

  list(int max_size=default_max_list_size);
  ~list();

  list(const list& lst);
  list& operator=(const list& lst);

  int size() { return size_; }
  iterator begin() { return &items_[0]; }
  iterator end() { return &items_[size_]; }

  iterator find(T x);
  iterator append(T x);
  void del(iterator p);
  void insert_after(iterator p, T x);

private:
  T* items_;
  int size_;
  int max_size_;

  void copy_from(const list& lst);
};
---
\end{figure}

ฟังก์ชันสมาชิกของคลาสแม่แบบสามารถนิยามได้ไม่ต่างจากฟังก์ชันแม่แบบ {\ct my\_swap}
ที่เราได้เขียนมาแล้ว สังเกตว่าเราจะนิยามฟังก์ชันไว้ภายในขอบเขตของ {\ct
  template<class T>} และภายในนั้นก็จะใช้ {\ct T} ได้เหมือนเป็นคลาสทั่วไป
นิยามของฟังก์ชันสมาชิกบางฟังก์ชันแสดงในโปรแกรมที่~\ref{code:abs-list-template-def}

ในการเขียนดังกล่าว มีรายละเอียดเชิงเทคนิคเกี่ยวกับ การใช้งานชนิดข้อมูล {\ct
  iterator} ที่เรานิยามขึ้นภายในแม่แบบ {\ct list} \ ในการอ้างถึง {\ct
  list<T>::iterator} นั้น เราจะต้องระบุคีย์เวิร์ด {\ct typename}
นำหน้าเพื่อบอกกับคอมไพเลอร์ว่าสิ่งที่เราอ้างถึงนั้นคือแบบชนิดข้อมูล ดังแสดงในฟังก์ชันสมาชิก
{\ct append} ของแม่แบบ {\ct list}
\ ผู้ที่สนใจสามารถอ่านรายละเอียดเพิ่มเติมได้ในส่วนที่~\ref{section:abs-typename}


\begin{figure}
---src[cpp,นิยามของสมาชิกบางฟังก์ชันของคลาสแม่แบบ {\ct list},code:abs-list-template-def]
template<class T>
list<T>::list(int max_size)
  : size_(0), max_size_(max_size) 
{
  items_ = new T[max_size_];
}

template<class T>
list<T>::~list()
{
  delete [] items_;
}

template<class T>
typename list<T>::iterator list<T>::append(T v)
{
  if(size_ >= max_size_)
    throw "List overflow";
  items_[size_] = v;
  ++size_;
  return &items_[size_ - 1];
}
---
\end{figure}

\section{รายละเอียดเพิ่มเติมเกี่ยวกับภาษา C++}

ภาษา C++ มีรายละเอียดปลีกย่อยเชิงเทคนิคมากพอสมควร ในส่วนนี้เราจะสรุปบางประเด็นที่สำคัญไว้

\subsection{สรุปฟังก์ชันสมาชิกพิเศษ}

คลาสในภาษา C++ มีฟังก์ชันสมาชิกพิเศษหลายฟังก์ชันที่ทำงานพิเศษ ในบทนี้เราได้พิจารณาฟังก์ชันดังรายการต่อไปนี้ (เราจะเขียนชื่อฟังก์ชันโดยสมมติว่าคลาสชื่อ {\ct myclass})
\begin{itemize}
\item {\ct myclass::myclass(...)} \\ ตัวสร้าง (constructor)
  ทำหน้าที่ในการกำหนดค่าเริ่มต้นให้กับวัตถุ จะถูกเรียกเมื่อมีการประกาศวัตถุ
  ตัวสร้างอาจจะรับพารามิเตอร์ที่จำเป็น แต่จะไม่คืนค่าใด ๆ
\item {\ct myclass::\char`\~myclass()} \\ ตัวทำลาย (destructor)
  ทำหน้าที่ในการจัดการก่อนที่วัตถุจะถูกทำลาย เช่น คืนทรัพยากรที่วัตถุขอมาจากระบบ เป็นต้น
\item {\ct myclass::myclass(const myclass\& obj)} \\ ตัวสร้างสำหรับคัดลอก
  ตัวสร้างนี้จะรับพารามิเตอร์แบบอ้างอิงไปยังวัตถุของคลาสเดียวกัน
  ตัวสร้างนี้สามารถเรียกใช้ได้โดยตรงหรืออาจจะโดนเรียกเมื่อมีการส่งค่าไปยังฟังก์ชันแบบ
  pass by value \ โดยทั่วไปแล้ว คลาสที่มีการจองและคืนทรัพยากรเมื่อถูกทำลาย เช่น
  มีการจองหน่วยความจำ และต้องการรองรับการส่งค่าไปยังฟังก์ชันแบบ pass by value
  จะต้องเขียนฟังก์ชันนี้
\item {\ct myclass\& myclass::operator(const myclass\& obj)}
  \\ ฟังก์ชันโอเปอเรเตอร์กำหนดค่า ถูกเรียกใช้เมื่อมีการให้ค่าวัตถุของคลาสดังกล่าว
  \ เช่นเดียวกับตัวสร้างสำหรับคัดลอก
  คลาสที่มีการจองทรัพยากรและคืนทรัพยากรมักจำเป็นต้องเขียนฟังก์ชันเหล่านี้
\end{itemize}

อย่างไรก็ตาม ถ้าโดยมากเราใช้งานวัตถุโดยไม่มีการคัดลอก
และเมื่อมีการส่งค่าไปยังฟังก์ชันจะใช้การส่งค่าแบบอ้างอิงหรือส่งด้วยพอยน์เตอร์เท่านั้น เช่น
ในกรณีของคลาสที่ใช้งานแบบอ้างอิงเท่านั้น
(ดูส่วน~\ref{section:abs-value-ref-semantics})
เราก็ไม่จำเป็นต้องเขียนตัวสร้างสำหรับคัดลอก และโอเปอเรเตอร์กำหนดค่า \ อย่างไรก็ตาม
เพื่อป้องกันการคัดลอกโดยไม่ได้ตั้งใจ เราอาจจะประกาศฟังก์ชันทั้งสองเป็นสมาชิกส่วนตัว
โดยไม่ต้องนิยามฟังก์ชัน เพื่อให้คอมไพเลอร์ตรวจสอบว่าไม่มีการคัดลอกวัตถุเกิดขึ้นได้
ยกตัวอย่างเช่นดังโปรแกรมด้านล่างนี้

---src[cpp]
class myclass {
  // ...
private:
  myclass(const myclass& obj);
  myclass& operator=(const myclass& obj);
};
---

\subsection{การใช้วัตถุแบบ value และแบบ reference}
\label{section:abs-value-ref-semantics}

\subsection{การประกาศฟังก์ชันหลายฟังก์ชันโดยใช้ชื่อเดียวกัน: การโอเวอร์โหลด}

\subsection{คลาสสืบต่อ}

\subsection{ความจำเป็นที่ต้องระบุ {\ct typename} เมื่อใช้ชนิดข้อมูลที่ขึ้นกับตัวแปรแม่แบบ}
\label{section:abs-typename}

ส่วนนี้อธิบายและยกตัวอย่างแสดงความจำเป็นต้องระบุคีย์เวิร์ด {\ct typename}
แต่ไม่จำเป็นมากต่อเนื้อหาหลัก
ผู้อ่านสามารถข้ามไปได้\footnote{เนื้อหาและตัวอย่างนำมาจากส่วน C.13.5 ของหนังสือของ
  Stroustrup}

เมื่อถูกนิยาม เราไม่ทราบว่าชนิดข้อมูลที่ถูกส่งเป็นพารามิเตอร์เป็นชนิดข้อมูลใด
ทำให้เมื่อมีการอ้างถึงสมาชิกของแบบชนิดข้อมูลนั้น
คอมไพเลอร์จะไม่สามารถแยกแยะได้ว่าสมาชิกนั้นคืออะไร

พิจารณาตัวอย่างเช่นโปรแกรมถัดไป

---src[cpp]
template <class C> void f()
{
  C::t(a);
}
---

ถ้าพิจารณาเพียงผ่าน ๆ เราอาจจะคิดว่า {\ct t} เป็นฟังก์ชันแบบสถิตย์ของคลาส (static
function) ซึ่งเราจะได้กล่าวถึงต่อไป แต่ก็เป็นไปได้ที่ {\ct t} จะเป็นชนิดข้อมูล
และการนิยามดังกล่าวก็เหมือนกับการนิยามตัวแปรแต่มีการใส่วงเล็บเกิน เช่น {\ct int (a);}

ดังนั้น ภาษา C++ จึงได้กำหนดว่าถ้ามีการอ้างถึงสมาชิกของคลาสแม่แบบ
คอมไพเลอร์จะพิจารณาให้สมาชิกนั้นไม่เป็นชนิดข้อมูล
นอกเสียจากเราจะระบุว่าสมาชิกนั้นเป็นชนิดของข้อมูล โดยการเขียนคีย์เวิร์ด {\ct
  typename} นำหน้า

ข้อกำหนดดังกล่าวเป็นจริงสำหรับการอ้างถึง {\ct list<T>::iterator} ด้วย ดังนั้น
เราจึงต้องระบุว่าชื่อดังกล่าวหมายถึงชนิดข้อมูลด้วย {\ct typename}

