\chapter{การซ่อนรายละเอียด: คลาสและเท็มเพลต}

ในบทนี้เราจะศึกษาเครื่องมือของภาษา C++ ที่เราจะใช้พัฒนาโครงสร้างข้อมูล
เราจะศึกษาบางส่วนของแนวคิดการโปรแกรมเชิงวัตถุ (object-oriented programming)
และการโปรแกรมเชิงเจนเนอริก (generic programming)
ผ่านทางการปรับปรุงโครงสร้างข้อมูลสำหรับจัดเก็บรายการด้วยอาร์เรย์ที่เราได้อิมพลีเมนท์ในบทก่อน ๆ

\section{การรวมกลุ่มข้อมูลและกระบวนการจัดการ}

ในส่วนนี้ เราจะปรับปรุงรูปแบบการใช้งานโครงสร้างข้อมูลให้สะดวกขึ้น
โดยการรวมตัวแปรที่เกี่ยวข้องหลายตัวเข้าด้วยกันเป็นชนิดข้อมูลใหม่
จากนั้นเราจะรวมกระบวนการจัดการเข้าไว้ดว้ย

\subsection{การรวมกลุ่มข้อมูล: {\ct struct}}

ถ้าเราพิจารณาฟังก์ชันต่าง ๆ ที่เราอิมพลีเมนท์
เราจะพบว่าทุกครั้งในการเรียกใช้เราจำเป็นจะต้องส่งพารามิเตอร์ {\ct list} ที่เก็บข้อมูล
และ {\ct size} ที่ระบุจำนวนข้อมูลในรายการไปพร้อม ๆ กันตลอด
ข้อสังเกตนี้แสดงว่าข้อมูลทั้งสองมีความเกี่ยวข้องกันมาก
ในกรณีนี้เพราะว่าเป็นข้อมูลพื้นฐานของการจัดการเกี่ยวกับรายการของเรา

สิ่งแรกที่เราสามารถปรับปรุงได้คือการรวมกลุ่มข้อมูลนี้เข้าด้วยกัน ในภาษา C++
เราสามารถประกาศชนิดข้อมูลแบบโครงสร้างโดยใช้คีย์เวิร์ด {\ct struct}
เพื่อรวมกลุ่มข้อมูลหลาย ๆ ชนิดเข้าด้วยกัน

---src[cpp]
const int max_list_size = 1000;

struct list {
  int items[max_list_size];
  int size;
};
---

ในการประกาศนั้นเราจะระบุสมาชิก (member) ของโครงสร้างที่เราประกาศ
เราสามารถประกาศชนิดข้อมูล {\ct list} ที่มีสมาชิกคืออาร์เรย์ {\ct items}
และจำนวนเต็ม {\ct size} ดังโปรแกรมด้านล่าง
(สังเกตว่าเราประกาศขนาดของอาร์เรย์ไว้ที่ค่าคงที่ {\ct max\_list\_size}
โดยให้มีขนาด 1000 ช่อง)

สังเกตว่าเราจะต้องใช้เครื่องหมาย {\ct ;} ในการปิดการประกาศ {\ct struct} ด้วย

เราสามารถประกาศตัวแปรที่มีชนิดข้อมูลเป็น {\ct list} ได้ ตัวแปรนี้จะมีสมาชิกชื่อ {\ct
  items} และ {\ct size} ซึ่งสามารถอ้างถึงได้โดยใช้โอเปอเรเตอร์ {\ct .}
ยกตัวอย่างเช่น ถ้าเราประกาศ
\begin{center}
{\ct list lst;}
\end{center}
เราจะสามารถอ้างถึง {\ct lst.items} และ {\ct lst.size} ได้

เราสามารถปรับฟังก์ชันต่าง ๆ ที่เคยต้องรับพารามิเตอร์สองตัวให้รับโครงสร้าง {\ct list}
เพียงพารามิเตอร์เดียวได้ บางฟังก์ชันที่สำคัญแสดงในโปรแกรมที่~\ref{code:abs-struct-list}

\begin{figure}
---src[cpp,บางฟังก์ชันที่ทำงานกับ {\ct list},code:abs-struct-list]
typedef int* list_itr;

void list_init(list& l)
{
  l.size = 0;
}

list_itr list_itr_end(list& l)
{
  return &l.items[l.size];
}

list_itr list_find(list& l, int x)
{
  for(int i = 0; i < l.size; ++i)
    if(l.items[i] == x)
      return &l.items[i];
  return list_itr_end(l);
}

list_itr list_append(list& l, int x)
{
  if(l.size >= max_list_size)
    throw "List overflow";
  l.items[l.size] = x;
  ++l.size;
  return &l.items[l.size-1];
}
---
\end{figure}

อย่างไรก็ตาม เราต้องระวังวิธีการผ่านพารามิเตอร์ เนื่องจากโดยปกติ C++
จะส่งค่าพารามิเตอร์แบบ pass by value ดังนั้น ถ้าเราส่งค่าโครงสร้าง {\ct list}
โดยตรง จะทำให้ระบบสร้างตัวแปรประเภท {\ct list}
อีกตัวหนึ่งและคัดลอกข้อมูลจากอาร์กิวเมนท์ที่เราส่งไปยังตัวแปรชั่วคราวนี้
ซึ่งในกรณีของโครงสร้าง {\ct list} นอกจากจะทำให้โปรแกรมทำงานไม่ถูกต้องแล้ว
(เช่นในกรณีของฟังก์ชัน {\ct list\_init})
ยังเป็นการทำให้โปรแกรมมีประสิทธิภาพการทำงานต่ำลงโดยไม่จำเป็นด้วย

ตัวอย่างการเรียกใช้งานฟังก์ชันดังกล่าวแสดงในโปรแกรมต่อไปนี้

---src[cpp]
  list lst;
  list_init(lst);
  list_append(lst,10);  list_append(lst,30);  list_append(lst,20);
  if(list_find(lst,5) != list_itr_end(lst))  // find 5 in list
    cout << "found" << endl;
  else
    cout << "not found" << endl;
---

\subsection{การรวมกระบวนการเข้าเป็นฟังก์ชันสมาชิก} 

สังเกตว่าฟังก์ชันต่าง ๆ ที่ทำงานกับรายการที่เราเขียนนั้น โดยมากจะทำงานกับโครงสร้าง
{\ct list} ที่รับพารามิเตอร์มา เนื่องจากฟังก์ชันเหล่านี้ประมวลผลกับข้อมูลโดยตรง
เราจะรวมฟังก์ชันเหล่านั้นเข้าเป็นสมาชิกของโครงสร้าง {\ct list}
เพื่อให้การใช้งานทำได้สะดวกขึ้น ตัวอย่างการใช้งานฟังก์ชันเหล่านี้ผ่านทางตัวแปร {\ct
  list} แสดงในโปรแกรมถัดไป เราจะสังเกตว่าการเรียกใช้งานดูกระชับขึ้น

---src[cpp]
  list lst;
  lst.init();
  lst.append(10);  lst.append(30);  lst.append(20);
  if(lst.find(5) != lst.end())  // find 5 in list
    cout << "found" << endl;
  else
    cout << "not found" << endl;
---

เราจะเพิ่มการประกาศฟังก์ชันสมาชิกเข้าไปในการประกาศ {\ct struct}
ดังแสดงในโปรแกรมที่~\ref{code:abs-struct-list-functions}
ฟังก์ชันเหล่านี้เรียกว่า{\em ฟังก์ชันสมาชิก} ({\em member function})

นอกจากนี้ เรายังนำชนิดข้อมูล {\ct list\_itr} ย้ายไปประกาศไว้ภายในโครงสร้าง {\ct
  list} ด้วย โดยใช้ชื่อชนิดข้อมูลเป็น {\ct iterator} (สังเกตว่าเราตัดคำขึ้นต้น {\ct
  list} ทิ้งไปหมด เพื่อไม่ให้ชื่อซ้ำซ้อน) นอกจากนี้เรายังหลีกเลี่ยงการตั้งชื่อฟังก์ชันสมาชิกว่า
{\ct delete} โดยใช้ชื่อว่า {\ct del} แทน เพราะจะซ้ำกับชื่อโอเปอเรเตอร์ {\ct
  delete}

\begin{figure}
---src[cpp,การประกาศโครงสร้าง {\ct list} ที่ระบุฟังก์ชันสมาชิก,code:abs-struct-list-functions]
struct list {
  // members
  int items[max_list_size];
  int size;

  typedef int* iterator;

  // member functions
  void init();
  iterator begin();
  iterator end();
  iterator find(int x);
  iterator append(int x);
  void del(iterator p);
  void insert_after(iterator p, int x);
};
---
\end{figure}

ฟังก์ชันสมาชิกเหล่านี้ จะทำงานกับตัวแปรโครงสร้าง {\ct list}
และสามารถอ้างถึงสมาชิกที่เป็นตัวแปรเช่น {\ct size} และ {\ct items} ได้โดยตรง
รูปที่~\ref{fig:abs-member-functions}

\begin{figure}
TODO: add this
\caption{แสดงลักษณะการทำงานของฟังก์ชันสมาชิก}
\label{fig:abs-member-functions}
\end{figure}

หลังจากประกาศฟังก์ชันสมาชิกต่าง ๆ เหล่านี้ ในโครงสร้าง {\ct list} แล้ว
เราจะนิยามฟังก์ชันดังกล่าว โปรแกรมที่~\ref{code:abs-list-init-find}
แสดงการนิยามฟังก์ชัน {\ct list::init} และ {\ct list:find}

\begin{figure}
---src[cpp,ฟังก์ชันสมาชิก {\ct list::init} และ {\ct list::find},code:abs-list-init-find]
void list::init()
{
  size = 0;
}

list::iterator list::find(int x)
{
  for(int i = 0; i < size; ++i)
    if(items[i] == x)
      return &items[i];
  return end(l);
}
---
\end{figure}

เช่นเดียวกับการอ้างถึงสมาชิก {\ct size} และ {\ct items} ของตัวแปร {\ct l} ด้วย
{\ct l.size} และ {\ct l.items} ในการอ้างถึงฟังก์ชันสมาชิกของตัวแปรต่าง ๆ
เราจะใช้โอเปอเรเตอร์จุด ({\ct .})  ส่วนในกรณีที่เราจะอ้างถึงสมาชิกของโครงสร้างเอง
เราจะใช้โอเปอเรเตอร์ {\ct ::} เช่น {\ct list::init} และ {\ct
  list::iterator}

สังเกตว่าภายในฟังก์ชันสมาชิก {\ct list::init} เราสามารถอ้างถึงสมาชิก {\ct size}
ได้โดยตรง ตัวแปรดังกล่าวจะอ้างถึงสมาชิก {\ct size}
ของตัวแปรที่เราเรียกฟังก์ชันเหล่านี้ผ่าน เช่น ถ้าเราเรียก {\ct lst.init()} ตัวแปร
{\ct size} ในฟังก์ชันสมาชิกที่เราเขียนจะหมายถึง {\ct lst.size}

---q ฟังก์ชันสมาชิกอื่น ๆ
เขียนฟังก์ชันสมาชิกอื่น ๆ ของโครงสร้าง {\ct list} และทดสอบกับโปรแกรมตัวอย่าง
---

\section{การซ่อนรายละเอียด: {\ct class}}

ในส่วนที่แล้วเราพัฒนาชนิดข้อมูล {\ct list}
ที่รวมข้อมูลและกระบวนการที่ทำงานกับข้อมูลไว้ด้วยกัน ทำให้การใช้งานต่าง ๆ
สะดวกขึ้นและเขียนโปรแกรมได้อย่างกระชับขึ้น การสร้างชนิดข้อมูล {\ct list} ที่เราทำนี้
เป็นส่วนหนึ่งของการจัดการกับความซับซ้อนของซอฟต์แวร์ โดยการแบ่งงานเป็นส่วนย่อย ๆ
และพัฒนาโปรแกรมเพื่อรับผิดชอบงานแต่ละส่วนแยกกันไป

อย่างไรก็ตาม สังเกตว่าในการเขียนที่ผ่านมา
เราไม่สามารถรับประกันว่างานที่แบ่งออกมาพัฒนาเป็นส่วน ๆ นั้น
จะถูกแบ่งไปดูแลแยกขาดจากกัน ยกตัวอย่างเช่น
อาจมีส่วนหนึ่งของระบบที่ต้องการแทรกข้อมูลในรายการเพื่อเป็นรายการแรก ซึ่งโครงสร้าง
{\ct list} ที่เราได้พัฒนาไว้ ยังไม่ได้รองรับ
โปรแกรมเมอร์ผู้รับผิดชอบในส่วนนั้นก็อาจจะเปิดดูส่วนของโปรแกรมที่เราเขียนขึ้น
และเขียนโปรแกรมในลักษณะด้านล่างขึ้นมาเพื่อทำงานดังกล่าว

---src[cpp]
for(int i = lst.size-1; i >= 0; --i)
  lst.items[i+1] = lst.items[i];
lst.items[0] = x;
++lst.size;
---

โปรแกรมดังกล่าวสามารถทำงานได้ถูกต้อง
อย่างไรก็ตามโปรแกรมไม่มีการตรวจสอบขอบเขตของอาร์เรย์เลย
ทำให้โปรแกรมอาจจะเกิดความผิดพลาดได้ในภายหลัง สังเกตว่า
ถ้าโปรแกรมเมอร์คนที่เขียนโปรแกรมดังกล่าว เขียนผิดพลาด (เช่น ลืมเพิ่มค่า {\ct
  lst.size} ก็อาจจะมีผลกระทบไปกับทุกส่วนของระบบที่มีการใช้งานรายการนี้)

อย่างไรก็ตาม
ความยากของการพัฒนาซอฟต์แวร์ขนาดใหญ่ไม่ได้เกิดจากความซับซ้อนเพียงอย่างเดียว
แต่ระบบขนาดใหญ่ยังมีความต้องการในการปรับเปลี่ยนตลอดเวลา
เพื่อให้สามารถรองรับความต้องการของผู้ใช้ได้

สมมติว่าในอนาคต มีความจำเป็นต้องเปลี่ยนรูปแบบในการเก็บข้อมูลรายการใหม่
จากที่เคยใช้อาร์เรย์ มาใช้โครงสร้างข้อมูลแบบอื่นที่มีประสิทธิภาพมากกว่า
ถ้าเรายอมให้โปรแกรมในส่วนต่าง ๆ พัฒนากระบวนการจัดการรายการได้โดยเป็นอิสระ
เราจะต้องเข้าไปแก้ไขโปรแกรมต่าง ๆ
เหล่านั้นเพื่อให้การเปลี่ยนแปลงโครงสร้างภายในของรายการเป็นไปได้

ยิ่งไปกว่านั้น ถ้าเราเปลี่ยนแปลงโปรแกรมโดยที่ยังใช้ตัวแปรสมาชิก {\ct items} หรือ {\ct
  size} อยู่แต่ใช้ในความหมายอื่น โปรแกรมในส่วนอื่น ๆ
ที่เรียกใช้ข้อมูลจากรายการผ่านทางสมาชิกดังกล่าวโดยตรงก็จะยังสามารถคอมไพล์ได้
รวมถึงอาจจะทำงานได้โดยที่เราไม่ทราบว่ามีความผิดพลาดซ่อนอยู่
ความผิดพลาดพวกนี้ก็เป็นเสมือนระเบิดเวลารอการระเบิดเท่านั้นเอง

ภาษา C++ ได้พัฒนามาจากภาษา C
โดยมีเป้าหมายที่จะทำให้ภาษาโปรแกรมช่วยจัดการกับความซับซ้อนได้ดีขึ้น
หนึ่งในความสามารถที่เพิ่มเข้ามาคือการรวมกระบวนการเข้ากับข้อมูล ดังที่เราได้ทดลองใช้แล้ว
อีกหนึ่งความสามารถที่สำคัญไม่แพ้กัน
ก็คือความสามารถในการกำหนดขอบเขตการเข้าใช้สมาชิกของชนิดข้อมูลที่เราได้สร้างขึ้น เช่น
ในกรณีนี้ เราสามารถระบุได้ว่าสมาชิก {\ct items} และ {\ct size}
เป็นสมาชิกภายในของส่วนนี้ และไม่ยอมให้โปรแกรมในส่วนอื่น ๆ เข้าถึงได้โดยตรง

เราจะศึกษาความสามารถดังกล่าวโดยการพัฒนาคลาส ({\ct class})
สำหรับจัดการกับรายการ  

ในภาษา C++ คลาส เป็นการสร้างชนิดข้อมูลใหม่ ในลักษณะเดียวกันกับ {\ct struct} จริง
ๆ แล้ว โครงสร้างสองแบบนี้มีการใช้งานเหมือนกันทุกประการ
ยกเว้นเกณฑ์มาตรฐานในการควบคุมการอ้างถึงสมาชิก
สำหรับตัวแปรที่ประกาศขึ้นจากคลาสหรือโครงสร้าง เรานิยมเรียกว่า{\em วัตถุ}

เราจะนิยามคลาสได้ในลักษณะเดียวกับการนิยาม {\ct struct} แต่สมาชิกต่าง ๆ
ที่เรานิยามในคลาสจะไม่สามารถถูกอ้างถึงได้จากโปรแกรมที่อยู่ ``ภายนอก'' คลาส
ยกเว้นจะเป็นส่วนที่เราระบุไว้ พิจารณาตัวอย่างโปรแกรมด้านล่างเพื่อเปรียบเทียบ

---src[cpp]
struct test1 { int a;  int f() { return a+1; } };
class test2 { int a; int f() { return a+1; } };

test1 s1;  test2 s2;
cout << s1.a << endl;       // works
cout << s2.a << endl;       // compilation error
cout << s1.f() << endl;     // works
cout << s2.f() << endl;     // compilation error
---

สังเกตว่าฟังก์ชันสมาชิก {\ct test2::f } สามารถอ้างถึงสมาชิก {\ct a} ได้
แต่โปรแกรมภายนอกไม่สามารถอ้างถึงได้

ในการระบุขอบเขตการอ้างถึงสมาชิกในคลาส เราจะใช้คีย์เวิร์ด {\ct private} และ {\ct
  public} สมาชิกที่อยู่หลักการระบุ {\ct public}
เป็นส่วนสาธารณะจะถูกอ้างถึงจากส่วนใด ๆ ของโปรแกรมก็ได้ ส่วนที่ถูกระบุว่าเป็น {\ct
  private} จะเป็นสมาชิกส่วนตัวและถูกอ้างถึงได้จากสมาชิกของคลาสเท่านั้น
ในกรณีที่เราไม่ได้ระบุอะไร สมาชิกของคลาสจะเป็นสมาชิกส่วนตัว \ \ \ ในทางกลับกัน
สำหรับการนิยามโครงสร้างนั้น สมาชิกที่ไม่ได้ระบุขอบเขตการเข้าถึง
จะถูกพิจารณาเป็นสมาชิกสาธารณะ

พิจารณาคลาส {\ct test2}
ที่แก้ไขแล้วด้านล่างที่เปิดให้ฟังก์ชัน {\ct test2::f} สามารถเข้าถึงได้จากทุก ๆ ที่
สังเกตว่าเราเพิ่มฟังก์ชัน {\ct set\_a} เพื่อให้เราสามารถกำหนดค่าให้กับ {\ct a}
ได้ด้วย (ไม่เช่นนั้นเราจะไม่มีทางกำหนดค่าให้กับ {\ct a} ได้เลย)

---src[cpp]
class test2 { 
  int a; 
public: 
  void set_a(int aa) { a = aa; }
  int f() { return a+1; } 
};
---

\subsection{คลาสสำหรับตัวนับ}
เราจะเขียนคลาส {\ct counter} สำหรับใช้เป็นตัวนับ
คลาสดังกล่าวไม่ได้มีความซับซ้อนในการเขียนจึงเป็นตัวอย่างที่ดีในการเริ่มต้น

ในการออกแบบคลาสนั้น เราจำเป็นจะต้องพิจารณาส่วนที่ผู้ใช้จะเรียกใช้งานก่อน
ฟังก์ชันสมาชิกในกลุ่มนี้จะเป็นอินเทอร์เฟสของวัตถุในคลาส ที่ผู้ใช้งานจะเรียกใช้
อินเทอร์เฟสของตัวนับนั้นไม่ซับซ้อน ดังแสดงในรายการด้านล่าง
\begin{itemize}
\item Init($z$) -- กำหนดค่าเริ่มต้นใหักับตัวนับ โดยให้มีค่าเท่ากับ $z$
\item Inc() -- เพิ่มค่าตัวนับขึ้น 1
\item Get() -- คืนค่าปัจจุบันของตัวนับ
\end{itemize}

สังเกตว่าโดยทั่วไปแล้ว เรามักกำหนดให้ตัวนับมีค่าเริ่มต้นเป็น 0
จึงเป็นการเหมาะสมที่จะเพิ่มฟังก์ชันสมาชิกที่ทำงานดังกล่าวไว้ด้วย
\begin{itemize}
\item Init --- กำหนดค่าเริ่มต้นให้กับตัวนับ โดยให้มีค่าเท่ากับ 0
\end{itemize}

เราจะนิยามส่วนสาธารณะของคลาสได้ดังนี้

---src[cpp]
class counter {
  // ... private members not shown
public:
  void init(z=0);
  void inc();
  int get();
};
---

\section{โครงสร้างข้อมูลสำหรับข้อมูลชนิดใดก็ได้: เท็มเพลต}

\section{รายการบนอาร์เรย์ที่เปลี่ยนขนาดได้}

\subsection{ตัวสร้างสำหรับการคัดลอกและเครื่องหมายให้ค่า}

\section{ข้อควรรู้เกี่ยวกับการพัฒนาโปรแกรมด้วย C++}
