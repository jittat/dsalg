\chapter{การเรียกตัวเอง}

การเรียกตัวเองเป็นแนวคิดที่ทรงพลังมาก
เราจะทำความเข้าใจกับแนวคิดดังกล่าวผ่านทางตัวอย่างและคำถาม
เราจะเริ่มจากปัญหาที่ง่ายและตรงไปตรงมาซึ่งสามารถแก้ไขได้ด้วยอัลกอริทึมแบบวนซ้ำทั่วไป
เราจะพิจารณาปัญหาที่ยากขึ้นในตอนท้ายของบทนี้
อย่างไรก็ตามแนวคิดของการเรียกตัวเองจะเป็นแนวคิดพื้นฐานในการทำความเข้าใจโครงสร้างข้อมูลที่เราจะศึกษาในบทอื่น ๆ ด้วย

เราจะเริ่มจากปัญหาเกี่ยวกับการคำนวณที่ข้อมูลป้อนเข้าเป็นจำนวนเต็ม
จากนั้นจะพิจารณาปัญหาที่ข้อมูลป้อนเข้ามีลักษณะเป็นรายการ เช่น ปัญหาการหาค่ามากที่สุด
และปัญหาการจัดเรียงข้อมูล 

\section{การคำนวณทางพีชคณิต}

สมมติว่าเราทราบวิธีการเพิ่มค่าจำนวนธรรมชาติขึ้น 1 และลดค่าจำนวนธรรมชาติลง 1
พิจารณาวิธีการบวกจำนวนธรรมชาติ $A$ เข้ากับ $B$ ดังด้านล่าง

---alg บวกจำนวนธรรมชาติ $A$ กับ $B$
* ถ้า $B=0$ ตอบ $A$
* ไม่เช่นนั้น 
** คำนวณค่า $C\leftarrow B-1$
** บวกจำนวนธรรมชาติ $A$ กับ $C$ เก็บผลลัพธ์ไว้ที่ตัวแปร $D$
** คำนวณค่า $D+1$ แล้วตอบผลลัพธ์
---

นิยามข้างต้นมีลักษณะเหมือนงูกินหาง
เพราะว่าเรากำลังนิยามการบวกจำนวนธรรมชาติด้วยการบวกจำนวนธรรมชาติ อย่างไรก็ตาม
เราจะละความสงสัยดังกล่าวไว้ก่อนแล้วทดลองบวก 10 กับ 3 ดังนี้

---ui
* เนื่องจาก $3$ ไม่เท่ากับ $0$ เราจึงคำนวณค่า $3-1 = 2$
จากนั้นเราต้องการคำนวณหาผลบวกของ $10$ กับ $2$ เมื่อได้ผลบวกแล้ว เราจะเพิ่มค่าขึ้น
$1$ เพื่อได้ผลบวกของ $10$ กับ $3$ ตามต้องการ  (ดูรูปด้านล่าง)
---

จากขั้นตอนด้านบน ถ้าเราทราบว่าผลบวกของ $10$ กับ $2$ คือ $12$ เมื่อเพิ่มค่าขึ้น $1$
เราจะได้ผลลัพธ์ของ $10$ กับ $3$ ซึ่งมีค่าเท่ากับ $13$

---q 10 + 2
เราจะหาผลลัพธ์ของการบวก $10$ กับ $2$ ได้อย่างไร?
---

เราก็จะหาผลลัพธ์ด้วยวิธีเดียวกัน ซึ่งในการผลบวก เราจะต้องหาผลลัพธ์ของการบวก $10$ กับ $1$ และจะเป็นเช่นนี้เป็นเรื่อย ๆ ดังตัวอย่างด้านล่าง

---ui
* เนื่องจาก $3$ ไม่เท่ากับ $0$ เราจึงคำนวณค่า $3-1 = 2$ จากนั้นเราต้องการคำนวณหาผลบวกของ $10$ กับ $2$ ในการคำนวณผลบวกดังกล่าว เราจะใช้วิธีการเดิม
** เนื่องจาก $2$ ไม่เท่ากับ $0$ เราจึงคำนวณค่า $2-1 = 1$ จากนั้นเราต้องการคำนวณหาผลบวกของ $10$ กับ $1$ ในการคำนวณผลบวกดังกล่าว เราจะใช้วิธีการเดิม
*** เนื่องจาก $1$ ไม่เท่ากับ $0$ เราจึงคำนวณค่า $1-1 = 0$ จากนั้นเราต้องการคำนวณหาผลบวกของ $10$ กับ $0$ ในการคำนวณผลบวกดังกล่าว เราจะใช้วิธีการเดิม
**** เนื่องจาก $0$ เท่ากับ $0$ ผลลัพธ์ของการบวก $10$ กับ $0$ คือ $10$
*** เมื่อเราได้ผลลัพธ์ของการบวก $10$ กับ $0$ แล้ว (คือ $10$) เราคำนวณ $10+1$ ได้ผลลัพธ์ $11$ ซึ่งเป็นผลลัพธ์ของการบวก $10$ กับ $1$
** เมื่อเราได้ผลลัพธ์ของการบวก $10$ กับ $1$ แล้ว (คือ $11$) เราคำนวณ $11+1$ ได้ผลลัพธ์ $12$ ซึ่งเป็นผลลัพธ์ของการบวก $10$ กับ $2$
* เมื่อเราได้ผลลัพธ์ของการบวก $10$ กับ $2$ แล้ว (คือ $12$) เราคำนวณ $12+1$ ได้ผลลัพธ์ $13$ ซึ่งเป็นผลลัพธ์ของการบวก $10$ กับ $3$
---

รูปด้านล่างแสดงลักษณะการคำนวณ สังเกตว่าผู้คำนวณแต่ละคนทำงานเป็นอิสระต่อกัน
ยกตัวอย่างเช่น แต่ละคนจะเก็บข้อมูลภายใน (เช่นตัวแปร $C$ และ $D$) แยกจากกัน

---q การลบ
เขียนขั้นตอนการลบจำนวนธรรมชาติ $A$ กับ $B$ ในรูปแบบเดียวกับการคำนวณผลบวก
---

---q การคูณ
เขียนขั้นตอนการคูณจำนวนธรรมชาติ $A$ กับ $B$ ในรูปแบบเดียวกับการคำนวณผลบวก
---

---q ศูนย์
ถ้าเราตัดบรรทัดแรกที่ระบุเงื่อนไขที่ทำงานเมื่อ $B=0$ ออก  เมื่อเราดำเนินการตามขั้นตอนวิธีดังกล่าว ผลลัพธ์จะเป็นเช่นใด
---

เราสามารถเขียนอัลกอริทึมดังกล่าวเป็นโปรแกรมได้ไม่ยากดังนี้

---src[python]
def add(a,b):
    if b==0:
        return a
    else:
        c = b-1
        return 1 + add(a,c)
---

---src[cpp]
int add(int a, int b)
{
  if(b==0)
    return a;

  int c = b-1;
  return 1 + add(a,c);
}
---

\section{ค่าสูงสุด}

เราจะออกแบบอัลกอริทึมแบบเรียกตัวเองสำหรับการคำนวณค่าสูงสุด กล่าวคือ
ให้รายการของจำนวนเต็ม $n$ จำนวน $x_1,x_2,\ldots,x_n$
เราต้องการคำนวณค่าสูงสุด

กรณีที่เราสามารถตอบคำถามได้ง่าย คือกรณีที่ $n=1$
กล่าวคือเราสามารถตอบได้ทันทีว่าค่าสูงสุดเท่ากับ $x_1$

---alg การคำนวนค่าสูงสุดของรายการ $x_1,x_2,\ldots,x_n$ (ขั้นฐาน)
* ถ้า $n=1$ ตอบ $x_1$
* ถ้าเป็นกรณีอื่น:
** _จะต้องออกแบบต่อไป_
---

สำหรับกรณีทั่วไป เราจะเริ่มโดยพิจารณาปัญหาเมื่อข้อมูลนำเข้ามีขนาดเล็กลง คือ
\[
x_1,x_2,\ldots,x_{n-1}
\]


ปัญหานี้เราจะเรียกว่า {\em ปัญหาย่อย} (subproblem)
เราจะสมมติว่าเราสามารถหาคำตอบของปัญหาได้ กล่าวคือ
ให้ $M$ คือค่าสูงสุดของรายการ $x_1,x_2,\ldots,x_{n-1}$

---q ค่าสูงที่สุดจาก $M$
สมมติว่าเราทราบว่า $M$ คือค่าสูงสุดจากรายการ 
$x_1,x_2,\ldots,x_{n-1}$
เราสามารถคำนวณค่าสูงสุดของรายการ 
$x_1,x_2,\ldots,x_n$ ได้อย่างไร?
--hints ถ้า $M$ ไม่ใช่ข้อมูลที่มีค่าสูงสุดของรายการ ค่าอื่นที่เป็นไปได้คือค่าใด?
---


เมื่อเราพิจารณาข้อมูลสูงสุดของรายการ $x_1,x_2,\ldots,x_n$
มีความเป็นไปได้สองกรณีคือ กรณีที่ข้อมูลสูงที่สุดอยู่ในรายการ $x_1,\ldots,x_{n-1}$
ในอีกกรณีหนึ่งคือข้อมูลสูงที่สุดคือ $x_n$ ถ้าเป็นในกรณีแรกค่าสูงสุดคือ $M$ ในอีกกรณีหนึ่งคือ
$x_n$ ซึ่งเราสามารถเทียบข้อมูลทั้งสองเพื่อหาค่าสูงที่สุดได้ ดังอัลกอริทึมด้านล่าง

---alg การคำนวนค่าสูงสุดของรายการ $x_1,x_2,\ldots,x_n$
* ถ้า $n=1$ ตอบ $x_1$
* ในกรณีอื่น
** ให้ $M$ คือค่าสูงสุดของรายการ $x_1,x_2,\ldots,x_{n-1}$
** ถ้า $x_n > M$ ตอบ $x_n$
** ในกรณีอื่น ตอบ $M$
---

จากแนวคิดดังกล่าว เราสามารถพัฒนาโปรแกรมที่คำนวณค่าสูงสุดได้ดังนี้

---src[python]
def listmax(ls):
    if len(ls)==1:
        return ls[0]
    else:
        m = listmax(ls[:-1])
        xn = ls[-1]
        if m > xn
            return m
        else:
            return xn
---

---src[cpp]
int listmax(int ls[], int n)
{
  if(n==1)
    return ls[0];
  else {
    int xn = ls[n-1];
    int m = listmax(ls,n-1);
    if(m > xn)
      return m;
    else
      return xn;
  }
}
---

---q ผลบวกของรายการ
ออกแบบอัลกอริทึมที่รับรายการของจำนวนเต็ม $n$ จำนวนคือ $x_1,x_2,\ldots,x_n$
แล้วคำนวณผลรวมของข้อมูลในรายการ
---

\subsection{ฟังก์ชันเรียกตัวเอง}
อัลกอริทึมดังกล่าวสามารถพิจารณาว่าเป็นการคำนวณค่าฟังก์ชัน $f$ ที่มีนิยามดังต่อไปนี้

$f(\{x_1,x_2,\ldots,x_n\}) = 
\left\{
\begin{array}{ll}
x_1, &  \mbox{ถ้า } n=1 \\
\max \{ x_n,f(\{x_1,x_2,\ldots,x_{n-1}\}) \},  & \mbox{ในกรณีอื่น ๆ}
\end{array}
\right.$

\section{การทำซ้ำกับการเรียกตัวเอง}
การคำนวณค่าสูงสุดในรายการเป็นปัญหาพื้นฐานที่เหมาะกับอัลกอริทึมแบบทำซ้ำ ด้านล่างแสดงส่วนของโปรแกรมดังกล่าว

---src[python]
def listmax(ls):
    m = ls[0]
    for x in ls:
        if x > m:
            m = x
    return m
---

---src[cpp]
int listmax(int ls[], int n)
{
  int m = ls[0];
  for(int i=0; i<n; i++)
    if(ls[i] > m)
      m = ls[i];
  return m;
}
---

ผู้อ่านที่สนใจอาจเริ่มสงสัยว่าการพัฒนาโปรแกรมแบบเรียกตัวเองมีประโยชน์อย่างไร 

อย่างไรก็ตาม ภาษาโปรแกรมภายใต้กรอบคิดที่ไม่ใช่ภาษาเชิง imperative
อาจจะไม่มีโครงสร้างควบคุมที่เป็นการวนรอบ เช่น ภาษาเชิงฟังก์ชัน เช่น Haskell หรือ ML
หรือภาษาเชิงตรรก เช่น Prolog โปรแกรมที่เขียนบนภาษาในกลุ่มนี้
จะไม่มีแนวคิดเกี่ยวกับการเปลี่ยนแปลงค่าของตัวแปร
จึงทำให้โปรแกรมที่เขียนปราศจากผลข้างเคียง (side effect)
ทั้งหมดนี้ทำให้สามารถทดสอบโปรแกรมสะดวกขึ้น ลดข้อผิดพลาด
และทำให้โปรแกรมสามารถทำงานแบบขนานได้ง่ายขึ้นด้วย

\section{การจัดเรียงข้อมูล}

เรามีจำนวนเต็ม $x_1,\ldots,x_n$ เราต้องการเรียงข้อมูล

