\chapter{คิวและสแต็ก}

ในบทนี้เราจะกล่าวถึงชนิดข้อมูลนามธรรมที่มีลักษณะเป็นรายการ
ที่มีรูปแบบในการเข้าถึงข้อมูลแบบเฉพาะเจาะจงสองโครงสร้างข้อมูลคือคิว (queue) และสแด็ก
(stack) \ \
เราจะเริ่มจากการพิจารณาปัญหาที่เกี่ยวข้องและการประยุกต์ใช้ชนิดข้อมูลนามธรรมทั้งสอง
จากนั้นจะพิจารณาการอิมพลีเมนท์ด้วยอาร์เรย์ ในบทที่~\ref{chapter:lists}
เราจะได้ศึกษาวิธีการอิมพลีเมนต์ด้วยโครงสร้างข้อมูลแบบลิงก์ลิสต์ต่อไป

\section{ปัญหาและสถานการณ์}

ปัญหาที่เราจะพิจารณาในตอนต้นอาจจะไม่ใช่ปัญหาเชิงอัลกอริทึมที่ชัดเจน แต่จะเป็นภาพของสถานการณ์ที่จำเป็นต้องมีการประมวลผลกับข้อมูลในรูปแบบต่าง ๆ 

\subsection{การกระจายงาน}

ปัญหาแรกเป็นสถานการณ์ที่เกิดขึ้นทั่วไปในระบบคอมพิวเตอร์ขนาดใหญ่

\framed\noindent
ระบบคอมพิวเตอร์สำหรับให้บริการมีเครื่องสำหรับประมวลผล $N$ เครื่อง
และมีเครื่องคอมพิวเตอร์หลักสำหรับรับงานจากผู้ใช้
งานดังกล่าวจะถูกส่งให้กับเครื่องประมวลผลที่ว่างอยู่
ตามลำดับของงานที่ส่งให้กับเครื่องคอมพิวเตอร์หลัก
\ เราจะจัดการกับข้อมูลของงานที่เข้ามาที่เครื่องคอมพิวเตอร์หลักได้อย่างไร?
\endframed


\section{การประยุกต์ใช้คิวและสแต็ก}

ชนิดข้อมูลนามธรรมคิวและสแต็กจัดการกับข้อมูลที่เป็นรายการ
โดยการเข้าถึงข้อมูลในรายการจะกระทำได้กับเฉพาะข้อมูลที่ปลายรายการเท่านั้น \
เราสามารถนิยามชนิดข้อมูลนามธรรมทั้งสองได้โดยใช้ลำดับของการใส่เข้าและนำข้อมูลออก ดังนี้
\begin{itemize}
\item คิว --- การจัดการข้อมูลจะเป็นแบบเข้าก่อน-ออกก่อน (First-In First-Out หรือ
  FIFO) ข้อมูลที่ถูกเพิ่มเข้าไปในรายการจะต่อแถวกันตามลำดับ
  และเมื่อข้อมูลถูกนำออกจากรายการ ก็จะถูกนำออกไปตามลำดับเดียวกับที่ข้อมูลเข้ามา
\item สแต็ก --- การจัดการข้อมูลจะเป็นแบบเข้าที่หลัง-ออกก่อน (Last-In First-Out
  หรือ LIFO) ข้อมูลที่ถูกเพิ่มเข้าไปในรายการจะถูกวางต่อท้าย แต่เมื่อนำข้อมูลออก
  ข้อมูลที่อยู่ท้ายสุดจะถูกนำออกไปก่อน
  ลักษณะของการใช้งานจะเหมือนกับจานที่วางเป็นกองซ้อนกัน
\end{itemize}


\section{สแต็กและการอิมพลีเมนท์ด้วยอาร์เรย์}

ในส่วนของการอิมพลีเมนท์ด้วยอาร์เรย์นั้น เราจะเริ่มด้วยสแต็กก่อน
เพราะว่ามีโครงสร้างที่ง่ายกว่า \ ในบทนี้เราจะพัฒนาคลาสแม่แบบเลยเพื่อความกระทัดรัด
อย่างไรก็ตามหลายครั้งในการพัฒนาคลาสสำหรับโครงสร้างข้อมูลจริง~ๆ
เรามักนิยมที่จะทดลองสร้างคลาสที่จัดเก็บแบบชนิดข้อมูลจริงก่อนที่จะปรับเปลี่ยนให้เป็นคลาสแม่แบบ

---q อินเทอร์เฟสของสแต็ก
ก่อนที่เราจะเริ่มเขียน ให้ลองพิจารณาก่อนว่าคลาสแม่แบบ {\ct stack} จะต้องมีอินเทอร์เฟสอะไรบ้าง
---

เราจะแสดงอินเทอร์เฟสของสแต็กที่เราจะพัฒนาด้วยโปรแกรมหลักดังแสดงในโปรแกรมที่~\ref{code:qs-stack-main}
ในโปรแกรมหลัก เราได้ใช้การสั่ง {\ct assert} เพื่อทดสอบผลลัพธ์ที่เราคาดว่าน่าจะเป็น โดยสั่ง
\begin{center}
{\ct assert(}เงื่อนไข{\ct );}
\end{center}
ถ้าแม่แบบ {\ct stack} ทำงานผิดพลาด
กล่าวคือให้ผลลัพธ์ไม่ตรงตามเงื่อนไขเมื่อโปรแกรมทำงาน จะมีการพิมพ์ข้อความเช่นด้านล่างออกมา

{\latintext
\begin{verbatim}
a.out: stack.cc:13: int main(): Assertion `s.size()==3' failed.
mainAborted
\end{verbatim}
}

\begin{figure}
---src[cpp,ตัวอย่างโปรแกรมหลักที่เรียกใช้งานคลาสแม่แบบ {\ct stack},code:qs-stack-main]
#include <cassert>

#include "stack.h"

int main()
{
  stack<int> s;
  
  s.push(10);  s.push(20);  s.push(100);
  assert(s.size()==3);
  assert(s.pop()==100);
  assert(s.size()==2);
  assert(s.top()==20);
  assert(s.pop()==20);
  s.push(1000);
  assert(s.pop()==1000);
  assert(s.empty()==false);
  assert(s.pop()==10);
  assert(s.empty()==true);
}
---
\end{figure}

\section{คิวและการอิมพลีเมนท์ด้วยอาร์เรย์}

