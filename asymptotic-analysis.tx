\chapter{การวิเคราะห์เวลาการทำงานและชนิดข้อมูลนามธรรมพื้นฐาน}
\label{chapter:analysis}

ในบทนี้เราจะศึกษาการวิเคราะห์เวลาการทำงานอย่างละเอียดขึ้น
พร้อมกับแนะนำชนิดข้อมูลนามธรรม (abstract data type) พื้นฐานบางชนิด
ซึ่งในบทนี้เราจะอิมพลีเมนท์\footnote{ในหนังสือเล่มนี้ เราจงใจทับศัพท์คำว่า implement
  ด้วย ``อิมพลีเมนท์'' และ implementation ด้วย ``อิมพลีเมนเทชัน''
  เนื่องจากไม่มีคำภาษาไทยที่มีความหมายตรงกับคำดังกล่าวในความหมายที่เราใช้}ด้วยอาร์เรย์และวิเคราะห์เวลาการทำงาน

\section{การวิเคราะห์เชิงเส้นกำกับ}
ในบทนี้เราจะศึกษาข้อจำกัดของการวิเคราะห์ดังกล่าว
และทำความเข้าใจกับเทคนิคการวิเคราะห์ที่เราจะใช้ต่อไปตลอดในหนังสือเล่มนี้

จากตัวอย่างการวิเคราะห์ในบทที่~\ref{chapter:arrays}
เราได้วิเคราะห์อัลกอริทึม~\ref{alg:array-sum2} โดยสมมติให้ทุก ๆ
คำสั่งทำงานโดยใช้เวลาเท่ากันคือ 1 หน่วย เราได้ว่าอัลกอริทึมทำงานโดยใช้เวลา $2n+2$
หน่วย

ผล $2n+2$ ที่ได้จากการวิเคราะห์นั้น มีความแม่นยำเพียงใด?
แน่นอนว่าข้อสมมติว่าทุกคำสั่งทำงานโดยใช้เวลาเท่ากันนั้นไม่เป็นความจริง
ดังนั้นเราจะลองปรับการวิเคราะห์โดยสมมติค่าคงที่ $c_1,c_2,c_3,$ และ $c_4$
เป็นเวลาที่แต่ละคำสั่งทำงานเป็นมิลลิวินาที  ดังแสดงด้านล่าง

---algt *
* ให้ $x\leftarrow 0$   \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_1$ มิลลิวินาที ทำงานรวม 1 ครั้ง
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,n-1$  \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_2$ มิลลิวินาที ทำงานรวม $n$ ครั้ง
** ให้ $x \leftarrow x + A[i]$  \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_3$ มิลลิวินาที ทำงานรวม $n$ ครั้ง
* คืนค่า $x$ เป็นคำตอบ  \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_4$ มิลลิวินาที ทำงานรวม 1 ครั้ง
---

เมื่อเราวิเคราะห์โดยละเอียดแล้ว เราจะได้ว่าเวลาการทำงานเป็นมิลลิวินาทีคือ 
\[
c_1 + c_2\cdot n + c_3\cdot n + c_4 = c_1+c_4 + (c_3+c_4)n
\]

ถ้าเราประมวลผลกับข้อมูลจำนวน 100 ตัว (นั่นคือ $n=100$) ตัวแปรทั้ง 4
ก็ทำให้ได้เวลาในการประมวลผลที่แตกต่างกันมากมาย
ดังตารางในรูป~\ref{fig:analysis-many-runtimes}

\begin{figure}
\begin{center}
\begin{tabular}{|c|r|r|r|r|r|c|}
\hline
กรณี & $c_1$ & $c_2$ & $c_3$ & $c_4$ & เวลา (มิลลิวินาที) & เวลาประมาณ (ที่เข้าใจง่ายขึ้น) \\
\hline
1& 1	& 1	& 1	& 1	& 202 & 0.2 วินาที\\
2& 100	& 1 	& 1	& 1	& 301 & 0.3 วินาที\\
3& 10,000	& 1	& 1	& 1	& 10,201 & 10 วินาที \\ 
4& 100	& 1	& 1	& 100,000	& 100,300 & 2 นาที\\
5& 100	& 1,000	& 10,000	& 100	& 1,100,200 & 18 นาที \\
6& 1	& 20,000	& 1	& 100	& 2,000,201 & ครึ่งชัวโมง \\
7& 10	& 10	& 100,000	& 100,000	& 10,101,010 & สามชั่วโมง \\
\hline
\end{tabular}
\end{center}
\caption{เวลาการทำงานหลากหลายที่เป็นไปได้เมื่อ $n=100$}
\label{fig:analysis-many-runtimes}
\end{figure}

จากนิพจน์ง่าย ๆ $2n+2$ เมื่อเราพยายามใส่รายละเอียดแล้วคำนวณเป็นเวลา
กลับกลายเป็นเวลาที่แตกต่างกันได้มากมาย เมื่อเราปรับค่าสมมติให้เป็นค่าต่าง ๆ
แน่นอนว่าหลาย ๆ กรณีในตารางอาจจะเป็นกรณีที่เป็นไปไม่ได้จริง ๆ
แต่ถ้าเราตั้งใจจะสมมติและละทิ้งรายละเอียดบางอย่างแล้ว
เราก็ต้องเตรียมตัวรับผลความคลาดเคลื่อนที่อยู่ในกรอบของการสมมติของเราเช่นเดียวกัน

แม้ตัวอย่างจะเป็นอัลกอริทึมง่าย ๆ
ผลของการวิเคราะห์แทบจะบอกอะไรเกี่ยวกับเวลาการทำงานสำหรับค่า $n$
คงที่ค่าหนึ่งไม่ได้เลย เพราะความเปลี่ยนแปลงของเครื่องคอมพิวเตอร์นำอัลกอริทึมไปใช้งาน
รวมถึงภาษาโปรแกรมที่เขียน

อย่างไรก็ตาม ค่าคงที่ $c_1,\ldots,c_4$ นั้น ไม่เปลี่ยนแปลง
ถ้าเราไม่เปลี่ยนเครื่องคอมพิวเตอร์ที่ใช้งาน ดังนั้นเราจะทดลองแทนค่าเวลาที่คำนวณได้ กับค่า
$n$ ต่าง ๆ กันแทน เราจะได้ผลดังตารางในรูปที่~\ref{fig:analysis-runtimes-by-n}

\begin{figure}
{\small
\begin{center}
\begin{tabular}{|c|r|r|r|r|r|r|r|}
\hline
กรณี & 100 & 200 & 400	& 1,000	& 10,000	& 100,000	& 1,000,000\\ \hline
1& 202	&402	&802	&2,002	&20,002	&200,002	&2,000,002\\
2& 301	&501	&901	&2,101	&20,101	&200,101	&2,000,101\\
3& 10,201	&10,401	&10,801	&12,001	&30,001	&210,001	&2,010,001\\
4& 100,300	&100,500	&100,900	&102,100	&120,100	&300,100	&2,100,100\\
5& 1,100,200	&2,200,200	&4,400,200	&11,000,200	&110,000,200    &1,100,000,200	&11,000,000,200\\
6& 2,000,201	&4,000,301	&8,000,501	&20,001,101	&200,010,101    &2,000,100,101	&20,001,000,101\\
7& 10,101,010	&20,102,010	&40,104,010	&100,110,010	&1,000,200,010	&10,001,100,010	&100,010,100,010\\
\hline
\end{tabular}
\end{center}
}
\caption{เวลาการทำงานในแต่ละกรณีเมื่อปรับค่า $n$}
\label{fig:analysis-runtimes-by-n}
\end{figure}

ถ้าเราสังเกตค่าในตารางให้ดี เราจะเห็นแนวโน้มบางอย่าง
สังเกตการเปลี่ยนแปลงของค่าในทุก ๆ มีลักษณะคล้ายกัน เพื่อให้เห็นค่าชัดเจน
เราจะคำนวณอัตราส่วนของค่าในแต่ละคอลัมน์กับค่าในคอลัมน์ก่อนหน้า
เราจะได้ตารางในรูปที่~\ref{fig:analysis-runtimes-by-n-div}

\begin{figure}
{\small
\begin{center}
\begin{tabular}{|c|r|r|r|r|r|r|r|}
\hline
กรณี & 200 & 400	& 1,000	& 10,000	& 100,000	& 1,000,000\\ \hline
อัตราการเปลี่ยนของ $n$ & 2.000	&2.000	&2.500	&10.000	&10.000	&10.000\\ \hline
1& 1.990	&1.995	&2.496	&9.991	&9.999	&10.000\\
2& 1.664	&1.798	&2.332	&9.567	&9.955	&9.995\\
3& 1.020	&1.038	&1.111	&2.500	&7.000	&9.571\\
4& 1.002	&1.004	&1.012	&1.176	&2.499	&6.998\\
5& 2.000	&2.000	&2.500	&10.000	&10.000	&10.000\\
6& 2.000	&2.000	&2.500	&10.000	&10.000	&10.000\\
7& 1.990	&1.995	&2.496	&9.991	&9.999	&10.000\\
\hline
\end{tabular}
\end{center}
}
\caption{อัตราส่วนของเวลาการทำงานเมื่อปรับค่า $n$ เทียบกับการเปลี่ยนค่า $n$}
\label{fig:analysis-runtimes-by-n-div}
\end{figure}

สังเกตว่าในทุก ๆ แถว การเปลี่ยนแปลงของเวลาใกล้เคียงกับการเปลี่ยนแปลงของ $n$
ยกเว้นแถวที่ 4 ที่นิพจน์ของเวลาคือ $2n + 10001$ มิลลิวินาที อย่างไรก็ตาม ถ้าเราเพิ่มค่า
$n$ มากขึ้นเรื่อย ๆ ความแตกต่างดังกล่าวก็จะค่อย ๆ ลดลง

---q ค่า $n$ ที่มากพอ
ให้คำนวณหาค่า $n$ ที่ทำให้อัตราส่วนของเวลาการทำงานในกรณีที่ 4 เมื่อข้อมูลมีจำนวน $n$
กับเมื่อกรณีที่ข้อมูลมี $2n$ มีค่ามากกว่า $1.99$ (นั่นคือใกล้เคียงกับอัตราส่วน $2n/n = 2$)
---

จากการทดลองแทนค่าดังกล่าว เราพบว่าจากนิพจน์ $2n+2$ ที่เราวิเคราะห์ไป ส่วนที่ใช้ได้จริง
ๆ คือพจน์ $n$ เท่านั้น  

นอกจากความแตกต่างด้านค่าคงที่ของเวลาการทำงานของอัลกอริทึมระหว่างเครื่องคอมพิวเตอร์ต่าง
ๆ แล้ว การวิเคราะห์ของเราที่ผ่านมายังไม่ได้พิจารณาผลที่เกิดจากการอิมพลีเมนท์แต่อย่างใด
เราจะทดลองเพิ่มความละเอียดในการวิเคราะห์โดยพิจารณาไปถึงโปรแกรมที่เขียนเป็นภาษา
C++ ดังด้านล่าง

---src[cpp]
int x = 0;
for(int i = 0; i < n; ++i)
  x += A[i];
return x;
---

ถ้าเราต้องการจะนับเวลาการทำงานจริง ๆ เราจะพบว่าคำสั่ง {\ct for} จริง ๆ แล้ว
จะทำงานรวม $n+1$ ครั้ง แทนที่จะเป็น $n$ ครั้ง
เนื่องจากในรอบสุดท้ายจะต้องมีการเปรียบเทียบค่า {\ct i} กับ {\ct n} อีกหนึ่งครั้ง
ดังนั้นถ้าเราสมมติให้ทุกคำสั่งทำงานด้วยเวลาที่เท่ากันเราจะได้ว่าเวลาการทำงานของเราเปลี่ยนไปเป็น
$2n+3$ หรือถ้าเราพิจารณาละเอียดขึ้นอีก เราจะพบว่าคำสั่ง {\ct for} จริง ๆ แล้ว
ประกอบด้วยคำสั่งย่อย ๆ อีก 3 คำสั่ง คำสั่งแรกที่กำหนดค่าเริ่มต้นให้กับ {\ct i} ทำงานแค่
1 ครั้ง คำสั่งเปรียบเทียบทำงาน $n$ ครั้ง และคำสั่งปรับค่าทำงาน $n-1$ ครั้ง
ถ้าเราคิดรวมคำสั่งเหล่านี้ไปด้วย เวลาที่ได้จากการวิเคราะห์ของเราจะเป็น $3n+3$
หรือถ้าเราพยายามคิดเวลาของแต่ละคำสั่งเพิ่มเติมเข้าไป เราจะต้องสมมติตัวแปรเพิ่มอีก 3
ตัวและจะทำให้การคำนวณต่าง ๆ ยุ่งยากมากขึ้น

อย่างไรก็ตาม ไม่ว่าเราจะวิเคราะห์ได้ $2n+2$, $2n+3$, หรือ $3n+3$ หรือจะเป็น
$c_1+c_4 + (c_3+c_4)n$ ก็ตาม เมื่อเราไม่ทราบค่าคงที่ของเวลาการทำงานต่าง ๆ
ที่ขึ้นกับเครื่องคอมพิวเตอร์และสถานะต่าง ๆ ของเครื่องในเวลานั้น
ความแม่นยำของการวิเคราะห์ที่เราได้เพิ่มขึ้นมานั้น
ก็ไม่ได้ทำให้เราทำนายเวลาการทำงานได้แม่นยำขึ้นแต่อย่างใด
จากการทดลองแทนค่าที่เราได้ทำมา ทุก ๆ นิพจน์แสดงเวลาการทำงานที่เราวิเคราะห์ได้นั้น
มีความหมายไม่ต่างจาก $n$
ในแง่ของการเปลี่ยนแปลงของเวลาการทำงานเมื่อขนาดข้อมูลเพิ่มขึ้น นั่นคือ
ถ้าขนาดของข้อมูลเพิ่มขึ้น $c$ เท่า เวลาที่ใช้ในการทำงานก็จะเพิ่มขึ้นประมาณ $c$
เท่าด้วยเช่นกัน

\subsubsection{หาคู่ข้อมูล}
เราจะทดลองวิเคราะห์อีกอัลกอริทึมหนึ่งเพื่อยืนยันความเชื่อนี้

พิจารณาปัญหาต่อไปนี้ ให้อาร์เรย์ $A$ ที่มีข้อมูลเป็นจำนวนเต็ม $n$ ตัว
ต้องการทราบว่ามีข้อมูลคู่ใด ๆ ใน $A$ ที่บวกกันแล้วได้ผลลัพธ์เท่ากับ $K$ หรือไม่?
ในปัญหานี้เราต้องการทดสอบว่ามีหรือไม่มีเท่านั้น

---q *
ก่อนจะอ่านต่อ ให้ลองเขียนอัลกอริทึมที่แก้ปัญหาดังกล่าว
---

พิจารณาอัลกอริทึมด้านล่าง

---algt ตรวจสอบว่ามีข้อมูลสองตัวในอาร์เรย์ $A$ ที่มีข้อมูล $n$ ตัว ที่บวกกันมีผลรวมเท่ากับ $K$ หรือไม่
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,n-2$
** พิจารณา ตัวแปร $j\leftarrow i+1,i+2,\ldots,n-1$
*** ถ้า $A[i] + A[j] = K$ แล้ว
**** ตอบว่า YES แล้วจบการทำงาน
* ตอบว่า NO
---

สังเกตว่าเวลาในการทำงานของอัลกอริทึมขึ้นกับข้อมูลนำเข้า สมมติว่า $A[0]$ และ $A[1]$
บวกกันได้ผลลัพธ์เท่ากับ $K$ พอดี อัลกอริทึมก็จะใช้เวลาในการทำงานน้อยมาก
การวิเคราะห์ดังกล่าวนี้เป็นการวิเคราะห์ในกรณีที่ดีที่สุด (best case)

อย่างไรก็ตาม อย่างที่เราได้กล่าวไว้ในบทที่~\ref{chapter:arrays}
เรามักจะสนใจในกรณีที่แย่ที่สุด ซึ่งในกรณีของอัลกอริทึมนี้
เกิดขึ้นเมื่อไม่มีข้อมูลคู่ใดที่รวมกันได้ผลรวมเท่ากับ $K$ เลย
(สังเกตว่าเราได้ข้อสรุปนี้เพราะเราเชื่อว่า คำสั่งในบรรทัดที่ 4
จะทำงานไม่นานไปกว่าคำสั่งในบรรทัดที่ 5 ที่เป็นคำสั่งคืนค่าเหมือนกัน) 

ในกรณีนี้ เราจะมาวิเคราะห์เวลาในการทำงานของอัลกอริทึม
โดยสมมติให้ทุกคำสั่งใช้เวลาในการทำงาน 1 ครั้งเท่ากัน
การวิเคราะห์ในบรรทัดแรกกับบรรทัดสุดท้าย นั้นไม่ยาก กล่าวคือ บรรทัดแรกทำงานรวมทั้งสิ้น
$n-1$ ครั้ง และบรรทัดสุดท้ายทำงาน $1$ ครั้ง

สำหรับการวงรอบรอบใน (ตัวแปร $j$)
เราจะทดลองแทนค่าดูเพื่อทำความเข้าใจกับอัลกอริทึมนี้ก่อน ในรอบแรกที่ $i=0$ ตัวแปร $j$
จะมีค่าตั้งแต่ $1$ ถึง $n-1$ นั่นคือวงรอบนี้ทำงาน $n-1$ รอบ ในรอบที่สองที่ $i=1$
ตัวแปร $j$ จะมีค่าตั้งแต่ $2$ ถึง $n-1$ นั่นคือทำงาน $n-2$ รอบ
อัลกอริทึมจะทำงานเช่นนี้ไปเรื่อย ๆ จนกระทั่ง $i=n-2$ ตัวแปร $j$ จะมีค่าเดียวคือ $n-1$
ถ้าเรานับรวมจำนวนรอบทั้งหมด เราจะได้เท่ากับ
\[
(n-1) + (n-2) + (n-3) +\cdots+1 = n(n-1)/2
\]
นั่นคือ บรรทัดที่ 2 ทำงานทั้งสิ้น $n(n-1)/2$ รอบ ในแต่ละรอบที่ทำงาน
การตรวจสอบในบรรทัดที่ 3 จะทำงาน 1 ครั้ง ดังนั้นเราก็จะสามารถสรุปได้เช่นเดียวกันว่า
คำสั่งในบรรทัดที่ 3 ก็ทำงาน $n(n-1)/2$ ครั้ง เช่นเดียวกัน

เมื่อรวมทั้งหมด เราจะได้ว่าถ้าทุก ๆ คำสั่งทำงานโดยใช้เวลา 1 หน่วยเท่ากันหมด อัลกอริทึมจะทำงานโดยใช้เวลา
\[
(n-1) + n(n-1)/2 + n(n-1)/2 + 1 = n + n(n-1) = n^2
\]
หน่วย

เราจะทดลองใส่รายละเอียดเพิ่มเติมในการวิเคราะห์เช่นเดียวกับในกรณีของอัลกอริทึม~\ref{algo:array-sum2}
อย่างไรก็ตาม เพื่อความกระชับเราจะไม่กำหนดให้ทุกคำสั่งทำงานต่างกันหมด
แต่จะกำหนดให้เวลาในการทำงานของคำสั่งที่คล้ายกันเท่ากัน

---algt *
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,n-2$   \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_1$ มิลลิวินาที
** พิจารณา ตัวแปร $j\leftarrow i+1,i+2,\ldots,n-1$   \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_1$ มิลลิวินาที
*** ถ้า $A[i] + A[j] = K$ แล้ว   \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_2$ มิลลิวินาที
**** ตอบว่า YES แล้วจบการทำงาน   \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_3$ มิลลิวินาที
* ตอบว่า NO   \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_3$ มิลลิวินาที
---

เมื่อเพิ่มค่าคงที่ดังกล่าวในการวิเคราะห์ เราจะได้ว่า เวลาในการทำงานคือ
\begin{eqnarray*}
c_1\cdot(n-1) + c_1\cdot n(n-1)/2 + c_2\cdot n(n-1)/2 + c_3 
&=& c_1\cdot(n-1)(n+2)/2 + c_2\cdot n(n-1)/2 + c_3\\
&=& 
\left(\frac{c_1}{2} + \frac{c_2}{2}\right)n^2 +
\left(\frac{c_1}{2} - \frac{c_2}{2}\right)n + c_3
\end{eqnarray*}

\subsubsection{ตัวอย่าง: ผลจากการเปลี่ยนรูปแบบการอ่านค่าในหน่วยความจำ}

พิจารณาฟังก์ชันสองฟังก์ชันที่คำนวณผลรวมของข้อมูลในอาร์เรย์สองมิติ
ในโปรแกรม~\ref{code:analysis-example-caching-effect}

\begin{figure}
---src[cpp,ฟังก์ชัน {\ct calA} และ {\ct calB} ที่คำนวณผลรวมของข้อมูลในอาร์เรย์สองมิติ,code:analysis-example-caching-effect]
int calA()
{
  int x = 0;
  for(int i = 0; i < n; ++i)
    for(int j = 0; j < n; ++j)
      x += ar[i][j];
  return x;
}
int calB()
{
  int x = 0;
  for(int j = 0; j < n; ++j)
    for(int i = 0; i < n; ++i)
      x += ar[i][j];
  return x;
}
---
\end{figure}

---q *
ฟังก์ชัน {\ct calA} กับ {\ct calB} ต่างกันอย่างไร?  เมื่อนำไปทำงาน
เวลาที่ใช้ทำงานจะแตกต่างกันหรือไม่?  ถ้าคิดว่าแตกต่างฟังก์ชันใดน่าจะทำงานเร็วกว่า
ทำไมถึงน่าจะเป็นเช่นนั้น?
---

เมื่อนำฟังก์ชันไปทดลอง เนื่องจากต้องมีการกำหนดค่าเริ่มต้นให้กับอาร์เรย์
เราจึงให้โปรแกรมกำหนดค่าเริ่มต้นให้อาร์เรย์ จากนั้นเรียกฟังก์ชันดังกล่าว 10 รอบ
เพื่อลดผลของเวลาจากการกำหนดค่าเริ่มต้น

ค่าเฉลี่ยของเวลาการทำงาน เมื่อ {\ct n} มีค่าเท่ากับ 10,000 ของโปรแกรมที่ใช้ฟังก์ชัน
{\ct calA} คือ 4.55 วินาที ในขณะที่โปรแกรมที่ใช้ฟังก์ชัน {\ct calB} คือ 11.54 วินาที
คิดเป็นประมาณ 2.5 เท่าของเวลาของโปรแกรมที่ใช้ฟังก์ชัน {\ct calA}

\section{โครงสร้างข้อมูลนามธรรม}

\subsection{รายการ}

\subsection{พจนานุกรม}

\section{การอิมพลีเมนท์ด้วยอาร์เรย์และการวิเคราะห์เวลาการทำงาน}
