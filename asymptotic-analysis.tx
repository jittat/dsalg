\chapter{การวิเคราะห์เวลาการทำงานและชนิดข้อมูลนามธรรมพื้นฐาน}
\label{chapter:analysis}

ในบทนี้เราจะศึกษาการวิเคราะห์เวลาการทำงานอย่างละเอียดขึ้น
พร้อมกับแนะนำชนิดข้อมูลนามธรรม (abstract data type) พื้นฐานบางชนิด
ซึ่งในบทนี้เราจะอิมพลีเมนท์\footnote{ในหนังสือเล่มนี้ เราจงใจทับศัพท์คำว่า implement
  ด้วย ``อิมพลีเมนท์'' และ implementation ด้วย ``อิมพลีเมนเทชัน''
  เนื่องจากไม่มีคำภาษาไทยที่มีความหมายตรงกับคำดังกล่าวในความหมายที่เราใช้}ด้วยอาร์เรย์และวิเคราะห์เวลาการทำงาน

\section{การวิเคราะห์เชิงเส้นกำกับ}
ในบทนี้เราจะศึกษาข้อจำกัดของการวิเคราะห์ดังกล่าว
และทำความเข้าใจกับเทคนิคการวิเคราะห์ที่เราจะใช้ต่อไปตลอดในหนังสือเล่มนี้

\subsection{ความแม่นยำของการวิเคราะห์}
จากตัวอย่างการวิเคราะห์ในบทที่~\ref{chapter:arrays}
เราได้วิเคราะห์อัลกอริทึม~\ref{alg:array-sum2} โดยสมมติให้ทุก ๆ
คำสั่งทำงานโดยใช้เวลาเท่ากันคือ 1 หน่วย เราได้ว่าอัลกอริทึมทำงานโดยใช้เวลา $2n+2$
หน่วย

ผล $2n+2$ ที่ได้จากการวิเคราะห์นั้น มีความแม่นยำเพียงใด?
แน่นอนว่าข้อสมมติว่าทุกคำสั่งทำงานโดยใช้เวลาเท่ากันนั้นไม่เป็นความจริง
ดังนั้นเราจะลองปรับการวิเคราะห์โดยสมมติค่าคงที่ $c_1,c_2,c_3,$ และ $c_4$
เป็นเวลาที่แต่ละคำสั่งทำงานเป็นมิลลิวินาที  ดังแสดงด้านล่าง

---algt *
* ให้ $x\leftarrow 0$   \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_1$ มิลลิวินาที ทำงานรวม 1 ครั้ง
* พิจารณา ตัวแปร $i\leftarrow 0,1,\ldots,n-1$  \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_2$ มิลลิวินาที ทำงานรวม $n$ ครั้ง
** ให้ $x \leftarrow x + A[i]$  \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_3$ มิลลิวินาที ทำงานรวม $n$ ครั้ง
* คืนค่า $x$ เป็นคำตอบ  \ \ \ \ $\rhd\rhd\rhd$ ทำงานใช้เวลา $c_4$ มิลลิวินาที ทำงานรวม 1 ครั้ง
---

เมื่อเราวิเคราะห์โดยละเอียดแล้ว เราจะได้ว่าเวลาการทำงานเป็นมิลลิวินาทีคือ 
\[
c_1 + c_2\cdot n + c_3\cdot n + c_4 = c_1+c_4 + (c_3+c_4)n
\]

ถ้าเราประมวลผลกับข้อมูลจำนวน 100 ตัว (นั่นคือ $n=100$) ตัวแปรทั้ง 4
ก็ทำให้ได้เวลาในการประมวลผลที่แตกต่างกันมากมาย
ดังตารางในรูป~\ref{fig:analysis-many-runtimes}

\begin{figure}
\begin{center}
\begin{tabular}{|c|r|r|r|r|r|c|}
\hline
กรณี & $c_1$ & $c_2$ & $c_3$ & $c_4$ & เวลา (มิลลิวินาที) & เวลาประมาณ (ที่เข้าใจง่ายขึ้น) \\
\hline
1& 1	& 1	& 1	& 1	& 202 & 0.2 วินาที\\
2& 100	& 1 	& 1	& 1	& 301 & 0.3 วินาที\\
3& 10,000	& 1	& 1	& 1	& 10,201 & 10 วินาที \\ 
4& 100	& 1	& 1	& 100,000	& 100,300 & 2 นาที\\
5& 100	& 1,000	& 10,000	& 100	& 1,100,200 & 18 นาที \\
6& 1	& 20,000	& 1	& 100	& 2,000,201 & ครึ่งชัวโมง \\
7& 10	& 10	& 100,000	& 100,000	& 10,101,010 & สามชั่วโมง \\
\hline
\end{tabular}
\end{center}
\caption{เวลาการทำงานหลากหลายที่เป็นไปได้เมื่อ $n=100$}
\label{fig:analysis-many-runtimes}
\end{figure}

จากนิพจน์ง่าย ๆ $2n+2$ เมื่อเราพยายามใส่รายละเอียดแล้วคำนวณเป็นเวลา
กลับกลายเป็นเวลาที่แตกต่างกันได้มากมาย เมื่อเราปรับค่าสมมติให้เป็นค่าต่าง ๆ
แน่นอนว่าหลาย ๆ กรณีในตารางอาจจะเป็นกรณีที่เป็นไปไม่ได้จริง ๆ
แต่ถ้าเราตั้งใจจะสมมติและละทิ้งรายละเอียดบางอย่างแล้ว
เราก็ต้องเตรียมตัวรับผลความคลาดเคลื่อนที่อยู่ในกรอบของการสมมติของเราเช่นเดียวกัน

แม้ตัวอย่างจะเป็นอัลกอริทึมง่าย ๆ
ผลของการวิเคราะห์แทบจะบอกอะไรเกี่ยวกับเวลาการทำงานสำหรับค่า $n$
คงที่ค่าหนึ่งไม่ได้เลย เพราะความเปลี่ยนแปลงของเครื่องคอมพิวเตอร์นำอัลกอริทึมไปใช้งาน
รวมถึงภาษาโปรแกรมที่เขียน

อย่างไรก็ตาม ค่าคงที่ $c_1,\ldots,c_4$ นั้น ไม่เปลี่ยนแปลง
ถ้าเราไม่เปลี่ยนเครื่องคอมพิวเตอร์ที่ใช้งาน ดังนั้นเราจะทดลองแทนค่าเวลาที่คำนวณได้ กับค่า
$n$ ต่าง ๆ กันแทน เราจะได้ผลดังตารางในรูปที่~\ref{fig:analysis-runtimes-by-n}

\begin{figure}
{\small
\begin{center}
\begin{tabular}{|c|r|r|r|r|r|r|r|}
\hline
กรณี & 100 & 200 & 400	& 1,000	& 10,000	& 100,000	& 1,000,000\\ \hline
1& 202	&402	&802	&2,002	&20,002	&200,002	&2,000,002\\
2& 301	&501	&901	&2,101	&20,101	&200,101	&2,000,101\\
3& 10,201	&10,401	&10,801	&12,001	&30,001	&210,001	&2,010,001\\
4& 100,300	&100,500	&100,900	&102,100	&120,100	&300,100	&2,100,100\\
5& 1,100,200	&2,200,200	&4,400,200	&11,000,200	&110,000,200    &1,100,000,200	&11,000,000,200\\
6& 2,000,201	&4,000,301	&8,000,501	&20,001,101	&200,010,101    &2,000,100,101	&20,001,000,101\\
7& 10,101,010	&20,102,010	&40,104,010	&100,110,010	&1,000,200,010	&10,001,100,010	&100,010,100,010\\
\hline
\end{tabular}
\end{center}
}
\caption{เวลาการทำงานในแต่ละกรณีเมื่อปรับค่า $n$}
\label{fig:analysis-runtimes-by-n}
\end{figure}

ถ้าเราสังเกตค่าในตารางให้ดี เราจะเห็นแนวโน้มบางอย่าง
สังเกตการเปลี่ยนแปลงของค่าในทุก ๆ มีลักษณะคล้ายกัน เพื่อให้เห็นค่าชัดเจน
เราจะคำนวณอัตราส่วนของค่าในแต่ละคอลัมน์กับค่าในคอลัมน์ก่อนหน้า
เราจะได้ตารางในรูปที่~\ref{fig:analysis-runtimes-by-n-div}

\begin{figure}
{\small
\begin{center}
\begin{tabular}{|c|r|r|r|r|r|r|r|}
\hline
กรณี & 200 & 400	& 1,000	& 10,000	& 100,000	& 1,000,000\\ \hline
อัตราการเปลี่ยนของ $n$ & 2.000	&2.000	&2.500	&10.000	&10.000	&10.000\\ \hline
1& 1.990	&1.995	&2.496	&9.991	&9.999	&10.000\\
2& 1.664	&1.798	&2.332	&9.567	&9.955	&9.995\\
3& 1.020	&1.038	&1.111	&2.500	&7.000	&9.571\\
4& 1.002	&1.004	&1.012	&1.176	&2.499	&6.998\\
5& 2.000	&2.000	&2.500	&10.000	&10.000	&10.000\\
6& 2.000	&2.000	&2.500	&10.000	&10.000	&10.000\\
7& 1.990	&1.995	&2.496	&9.991	&9.999	&10.000\\
\hline
\end{tabular}
\end{center}
}
\caption{อัตราส่วนของเวลาการทำงานเมื่อปรับค่า $n$ เทียบกับการเปลี่ยนค่า $n$}
\label{fig:analysis-runtimes-by-n-div}
\end{figure}

สังเกตว่าในทุก ๆ แถว การเปลี่ยนแปลงของเวลาใกล้เคียงกับการเปลี่ยนแปลงของ $n$
ยกเว้นแถวที่ 4 ที่นิพจน์ของเวลาคือ $2n + 10001$ มิลลิวินาที อย่างไรก็ตาม ถ้าเราเพิ่มค่า
$n$ มากขึ้นเรื่อย ๆ ความแตกต่างดังกล่าวก็จะค่อย ๆ ลดลง

---q ค่า $n$ ที่มากพอ
ให้คำนวณหาค่า $n$ ที่ทำให้อัตราส่วนของเวลาการทำงานในกรณีที่ 4 เมื่อข้อมูลมีจำนวน $n$
กับเมื่อกรณีที่ข้อมูลมี $2n$ มีค่ามากกว่า $1.99$ (นั่นคือใกล้เคียงกับอัตราส่วน $2n/n = 2$)
---

จากการทดลองแทนค่าดังกล่าว เราพบว่าจากนิพจน์ $2n+2$ ที่เราวิเคราะห์ไป ส่วนที่ใช้ได้จริง
ๆ คือพจน์ $n$ เท่านั้น  

นอกจากความแตกต่างด้านค่าคงที่ของเวลาการทำงานของอัลกอริทึมระหว่างเครื่องคอมพิวเตอร์ต่าง
ๆ แล้ว การวิเคราะห์ของเราที่ผ่านมายังไม่ได้พิจารณาผลที่เกิดจากการอิมพลีเมนท์แต่อย่างใด
เราจะทดลองเพิ่มความละเอียดในการวิเคราะห์โดยพิจารณาไปถึงโปรแกรมที่เขียนเป็นภาษา
C++ ดังด้านล่าง

---src[cpp]
int x = 0;
for(int i = 0; i < n; ++i)
  x += A[i];
return x;
---

ถ้าเราต้องการจะนับเวลาการทำงานจริง ๆ เราจะพบว่าคำสั่ง {\ct for} จริง ๆ แล้ว
จะทำงานรวม $n+1$ ครั้ง แทนที่จะเป็น $n$ ครั้ง
เนื่องจากในรอบสุดท้ายจะต้องมีการเปรียบเทียบค่า {\ct i} กับ {\ct n} อีกหนึ่งครั้ง
ดังนั้นถ้าเราสมมติให้ทุกคำสั่งทำงานด้วยเวลาที่เท่ากันเราจะได้ว่าเวลาการทำงานของเราเปลี่ยนไปเป็น
$2n+3$ หรือถ้าเราพิจารณาละเอียดขึ้นอีก เราจะพบว่าคำสั่ง {\ct for} จริง ๆ แล้ว
ประกอบด้วยคำสั่งย่อย ๆ อีก 3 คำสั่ง คำสั่งแรกที่กำหนดค่าเริ่มต้นให้กับ {\ct i} ทำงานแค่
1 ครั้ง คำสั่งเปรียบเทียบทำงาน $n$ ครั้ง และคำสั่งปรับค่าทำงาน $n-1$ ครั้ง
ถ้าเราคิดรวมคำสั่งเหล่านี้ไปด้วย เวลาที่ได้จากการวิเคราะห์ของเราจะเป็น $3n+3$
หรือถ้าเราพยายามคิดเวลาของแต่ละคำสั่งเพิ่มเติมเข้าไป เราจะต้องสมมติตัวแปรเพิ่มอีก 3
ตัวและจะทำให้การคำนวณต่าง ๆ ยุ่งยากมากขึ้น

อย่างไรก็ตาม ไม่ว่าเราจะวิเคราะห์ได้ $2n+2$, $2n+3$, หรือ $3n+3$ หรือจะเป็น
$c_1+c_4 + (c_3+c_4)n$ ก็ตาม เมื่อเราไม่ทราบค่าคงที่ของเวลาการทำงานต่าง ๆ
ที่ขึ้นกับเครื่องคอมพิวเตอร์และสถานะต่าง ๆ ของเครื่องในเวลานั้น
ความแม่นยำของการวิเคราะห์ที่เราได้เพิ่มขึ้นมานั้น
ก็ไม่ได้ทำให้เราทำนายเวลาการทำงานได้แม่นยำขึ้นแต่อย่างใด
จากการทดลองแทนค่าที่เราได้ทำมา ทุก ๆ นิพจน์แสดงเวลาการทำงานที่เราวิเคราะห์ได้นั้น
มีความหมายไม่ต่างจาก $n$
ในแง่ของการเปลี่ยนแปลงของเวลาการทำงานเมื่อขนาดข้อมูลเพิ่มขึ้น นั่นคือ
ถ้าขนาดของข้อมูลเพิ่มขึ้น $c$ เท่า เวลาที่ใช้ในการทำงานก็จะเพิ่มขึ้นประมาณ $c$
เท่าด้วยเช่นกัน

\subsubsection{หาคู่ข้อมูล}

เราจะทดลองวิเคราะห์อีกอัลกอริทึมหนึ่งเพื่อยืนยันข้อสรุปที่เราได้มา พิจารณาโจทย์ปัญหาด้านล่างนี้

---p ทำรั้วพอดี
สมศักดิ์พบกับปัญหาน้ำท่วม ทำให้เขาคิดจะซื้อรั้วบ้านสำเร็จมาใช้ รั้วมีทั้งหมด $n$ แบบ แบบที่
$i$ มีความยาว $a_i$ เมตร และราคา $c_i$ บาท ความยาวรั้วที่เขาต้องการคือ $K$
เมตรและเขาไม่ต้องการนำรั้วสำเร็จมาตัด นอกจากนี้
เพื่อลดภาระในการต่อรั้วสำเร็จเข้าด้วยกัน เขาจะซื้อรั้วสำเร็จไม่เกิน 2 อัน
(แต่อาจจะซื้ออันเดียวก็ได้)  จงหาวิธีการซื้อที่ทำให้สมศักดิ์ประหยัดเงินมากที่สุด
---

สมมติว่าข้อมูลป้อนเข้าอยู่ในอาร์เรย์ $A=[a_0,a_1,\ldots,a_{n-1}]$ และ
$C=[c_0,c_1,\ldots,c_{n-1}]$  เราจะพัฒนาอัลกอริทึมเพื่อแก้ปัญหานี้

---q *
ก่อนจะอ่านต่อไป ลองคิดว่าจะแก้ปัญหาดังกล่าวได้อย่างไร
พร้อมทั้งเขียนอัลกอริทึมและพยายามวิเคราะห์เวลาการทำงาน เป็นฟังก์ชันที่ขึ้นกับ $n$
---

ปัญหาดังกล่าว เราสามารถพิจารณาคำตอบว่ามีสองประเภทคือกรณีที่ใช้รั้วสำเร็จอันเดียว
และกรณีที่ใช้รั้วสองอัน
เราสามารถเขียนอัลกอริทึมเพื่อแก้ปัญหานี้ได้ดังอัลกอริทึม~\ref{algo:analysis-cheapest-pair}
ที่แสดงในรูปที่~\ref{fig:algo-analysis-cheapest-pair}
อัลกอริทึมดังกล่าวทดลองคำตอบที่เป็นไปได้ทุกแบบและเลือกคำตอบที่ใช้เงินน้อยที่สุด

\begin{figure}
---algt[*,algo:analysis-cheapest-pair] เลือกรั้วประหยัดที่สุด
* $mcost\leftarrow\infty$ \hfill\ ($c_1$ milliseconds (ms))
* $sol\leftarrow$ ``Impossible'' \hfill\ ($c_1$ ms)
* FOR $i\leftarrow 0,1,\ldots,n-1$ \hfill\ ($c_2$ ms)
** IF $a[i]=K$ and $c[i]\leq mcost$ THEN \hfill\ ($c_3$ ms)
*** $mcost\leftarrow c[i]$ \hfill\ ($c_1$ ms)
*** $sol\leftarrow$ ``Buy fence $i$'' \hfill\ ($c_1$ ms)
* FOR $i\leftarrow 0,1,\ldots,n-1$ \hfill\ ($c_2$ ms)
** FOR $j\leftarrow i+1,i+2,\ldots,n-1$ \hfill\ ($c_2$ ms)
*** IF ($A[i] + A[j] = K$) and ($c[i]+c[j]<mcost$ THEN \hfill\ ($c_3$ ms)
**** $mcost\leftarrow c[i]+c[j]$ \hfill\ ($c_1$ ms)
**** $sol\leftarrow$ ``Buy fence $i$ and $j$'' \hfill\ ($c_1$ ms)
* RETURN $sol$ \hfill\ ($c_4$ ms)
---
\caption{อัลกอริทึม~\ref{algo:analysis-cheapest-pair} สำหรับปัญหาทำรั้วพอดี พร้อมระบุค่าคงที่ของเวลาที่ใช้ในการวิเคราะห์แบบละเอียด}
\label{fig:algo-analysis-cheapest-pair}
\end{figure}

วงรอบ FOR ชุดแรกพิจารณากรณีที่ใช้รั้วสำเร็จอันเดียว อีกชุดสำหรับกรณีที่ใช้รั้วสำเร็จสองอัน
สังเกตว่าอัลกอริทึมดังกล่าวจะทำงานโดยมีจำนวนรอบเท่า ๆ กันเสมอ
แต่อาจจะใช้เวลาต่างกันเปลี่ยนไปตามข้อมูล เนื่องจากอาจจะเข้าไปทำงานคำสั่งภายในคำสั่ง
IF ต่างกัน อย่างไรก็ตาม อย่างที่เราได้กล่าวไว้ในบทที่~\ref{chapter:arrays}
เรามักจะสนใจในกรณีที่แย่ที่สุด
ซึ่งในกรณีของอัลกอริทึมนี้เราจะสมมติให้อัลกอริทึมเข้าไปทำงานในทุก ๆ คำสั่งภายในคำสั่ง IF

ในกรณีนี้ เราจะเริ่มโดยการวิเคราะห์เวลาในการทำงานของอัลกอริทึม
โดยสมมติให้ทุกคำสั่งใช้เวลาในการทำงาน 1 ครั้งเท่ากัน เราจะแบ่งพิจารณาดังนี้

\begin{itemize}
\item คำสั่งในบรรทัดที่ 1,2 และ 12 ทำงานรวมกันใช้เวลา 3 หน่วย (เพราะว่าไม่ได้อยู่ภายในวงรอบอะไรเลย)
\item คำสั่งในบรรทัดที่ 3 - 6 แต่ละคำสั่งทำงาน $n$ รอบ ดังนั้นใช้เวลารวมทั้งสิ้น $4n$ หน่วย
\item เช่นเดียวกับการวิเคราะห์บรรทัดที่ 3, บรรทัดที่ 7 ทำงาน $n$ รอบ
  ดังนั้นใช้เวลารวมทั้งสิ้น $n$ หน่วย
\item สำหรับวงรอบใน (ตัวแปร $j$ ในบรรทัดที่ 8 - 11)
เราจะทดลองแทนค่าดูเพื่อทำความเข้าใจกับอัลกอริทึมนี้ก่อน ในรอบแรกที่ $i=0$ ตัวแปร $j$
จะมีค่าตั้งแต่ $1$ ถึง $n-1$ นั่นคือวงรอบนี้ทำงาน $n-1$ รอบ ในรอบที่สองที่ $i=1$
ตัวแปร $j$ จะมีค่าตั้งแต่ $2$ ถึง $n-1$ นั่นคือทำงาน $n-2$ รอบ
อัลกอริทึมจะทำงานเช่นนี้ไปเรื่อย ๆ จนกระทั่ง $i=n-2$ ตัวแปร $j$ จะมีค่าเดียวคือ $n-1$
ถ้าเรานับรวมจำนวนรอบทั้งหมด เราจะได้เท่ากับ
\[
(n-1) + (n-2) + (n-3) +\cdots+1 = n(n-1)/2
\]

นั่นคือ บรรทัดที่ 8 - 11 แต่ละบรรทัดจะทำงานทั้งสิ้น $n(n-1)/2$ รอบ
ดังนั้นคำสั่งในบรรทัดเหล่านี้ทำงานรวมกัน $4\cdot n(n-1)/2=2n(n-1)$ หน่วย
\end{itemize}

เมื่อรวมทั้งหมด เราจะได้ว่าถ้าทุก ๆ คำสั่งทำงานโดยใช้เวลา 1 หน่วยเท่ากันหมด อัลกอริทึมจะทำงานโดยใช้เวลา
\[
3 + 4n + n + 2n(n-1) = 2n^2 + 3n + 3
\]
หน่วย

ในรูป~\ref{fig:algo-analysis-cheapest-pair}
เราได้ใส่รายละเอียดของเวลาในแต่ละคำสั่ง
ในการวิเคราะห์เช่นเดียวกับในกรณีของอัลกอริทึม~\ref{algo:array-sum2} อย่างไรก็ตาม
เพื่อความกระชับเราจะไม่กำหนดให้ทุกคำสั่งทำงานต่างกันหมด
แต่จะกำหนดให้เวลาในการทำงานของคำสั่งที่คล้ายกันเท่ากัน

เมื่อเพิ่มค่าคงที่ดังกล่าวในการวิเคราะห์ เราจะได้ว่า เวลาในการทำงานคือ
$2 c_1 + 4n(c_2 +c_3 + 2c_1) + c_2n + 2n(n-1)(c_2 +c_3 + 2c_1) + c_4$ หรือมีค่าเท่ากับ
\[
2(c_2+c_3+2c_1)n^2 + (3c_2 + 2c_3 + 4c_1)n + 2c_1 + c4
\]

เราทดลองเปลี่ยนค่าของ $c_1,c_2,c_3$ และ $c_4$ พร้อม ๆ
กับดูแนวโน้มของเวลาที่ใช้ที่เปลี่ยนไปเมื่อ $n$ มีค่าเป็น 100, 200, 400, 800, 1,600,
16,000, และ 160,000 ตามลำดับ
ผลที่ได้แสดงในรูปที่~\ref{fig:analysis-runtimes-by-n-2} สังเกตว่าบรรทัดแรกเมื่อ
$c_1=c_2=c_3=c_4=1$ เวลาการทำงานมีค่าเป็น $2n^2+3n+3$
เท่ากับเวลาที่เราได้วิเคราะห์ไว้กรณีทุกคำสั่งทำงานด้วยเวลาที่เท่ากันหมด

เราได้เปรียบเทียบอัตราส่วนของค่าในคอลัมน์ติดกันและแสดงพร้อมอัตราส่วนของการเปลี่ยนแปลงของค่า
$n$, $n^2$, และ $2n^2+2n+3$
ในตารางในรูปที่~\ref{fig:analysis-runtimes-by-n-2-div}

\begin{figure}
{\footnotesize
\begin{center}
\begin{tabular}{|r|r|r|r|r|r|r|r|r|r|r|}
\hline
\multicolumn{4}{|c|}{} & \multicolumn{7}{c|}{$n$}\\
\hline
c1 & c2 & c3 & c4 & 100 & 200 & 400 & 800 & 1,600 & 16,000 & 160,000\\
\hline
1 & 1 & 1 & 1 & 80901 & 321801 & 1283601 & 5127201 & 20494401 & 2048144001 & 204801440001\\
0.1 & 1 & 0.1 & 1 & 26361 & 104721 & 417441 & 1666881 & 6661761 & 665657601 & 66560576001\\
0.01 & 0.01 & 0.01 & 100 & 909 & 3318 & 12936 & 51372 & 205044 & 20481540 & 2048014500\\
0.01 & 0.01 & 0.01 & 10000 & 10809 & 13218 & 22836 & 61272 & 214944 & 20491440 & 2048024400\\
0.001 & 0.001 & 0.001 & 100000 & 100080.9 & 100321.8 & 101283.6 & 105127.2 & 120494.4 & 2148144 & 204901440\\
\hline
\end{tabular}
\end{center}
}
\caption{เวลาการทำงานในแต่ละชุดของค่าคงที่เมื่อปรับค่า $n$}
\label{fig:analysis-runtimes-by-n-2}
\end{figure}

\begin{figure}
{\small
\begin{center}
\begin{tabular}{|c|r|r|r|r|r|r|}
\hline
กรณี & 200 & 400 & 800 & 1,600 & 16,000 & 160,000\\
\hline
n & 2.000 & 2.000 & 2.000 & 2.000 & 10.000 & 10.000\\
n2 & 4.000 & 4.000 & 4.000 & 4.000 & 100.000 & 100.000\\
1 (หรือ $2n^2 + 3n + 3$) & 3.978 & 3.989 & 3.994 & 3.997 & 99.937 & 99.994\\
2 & 3.973 & 3.986 & 3.993 & 3.997 & 99.922 & 99.992\\
3 & 3.650 & 3.899 & 3.971 & 3.991 & 99.889 & 99.993\\
4 & 1.223 & 1.728 & 2.683 & 3.508 & 95.334 & 99.945\\
5 & 1.002 & 1.010 & 1.038 & 1.146 & 17.828 & 95.385\\
\hline
\end{tabular}
\end{center}
}
\caption{อัตราส่วนของเวลาการทำงานเมื่อปรับค่า $n$ เทียบกับการเปลี่ยนค่า $n$}
\label{fig:analysis-runtimes-by-n-2-div}
\end{figure}

สังเกตว่าในกรณีนี้ อัตราการเปลี่ยนแปลงของเวลาที่ใช้
จะใกล้เคียงกับการเปลี่ยนแปลงของฟังก์ชัน $n^2$ แทนที่จะเป็น $n$ เหมือนกับในกรณีก่อน

---q *
ทำไมในกรณีนี้อัตราการเปลี่ยนแปลงคล้ายกับ $n^2$ มากกว่า $n$?
---

ดังนั้น สิ่งที่เราได้แน่นอนจากการวิเคราะห์ แทนที่จะเป็นเวลาที่สามารถประมาณได้
กลับเป็นข้อมูลของอัตราการเปลี่ยนแปลงของเวลาที่อัลกอริทึมใช้ในการทำงาน
ในกรณีนี้เราทราบว่าเวลาการทำงานเมื่อเทียบกับขนาดของข้อมูล แปรผันใกล้เคียงกับฟังก์ชัน
$n^2$

การที่วิธีการนี้ใช้เวลาแปรผันกับขนาดข้อมูลเป็น $n^2$ หมายความว่า ถ้าข้อมูลมีขนาดใหญ่มาก
ๆ อัลกอริทึมดังกล่าวจะใช้เวลามากขึ้นไปด้วย
และอาจจะใช้เวลานานเกินกว่าที่เราจะรอผลลัพธ์ได้ (เช่น นานหลายปี)
เมื่อเราศึกษาเทคนิคการค้นข้อมูลมากขึ้นแล้ว
เราจะสามารถแก้ปัญหานี้ได้โดยใช้เวลาที่แปรผันไม่ต่างจากฟังก์ชัน $n$ มากนัก

จากตัวอย่างที่กล่าวมาแล้ว เราพบว่าแม้ว่าเราจะวิเคราะห์เวลาการทำงานเป็นได้ $2n+2$,
$2n+3$, $3n+3$ สิ่งที่เราสามารถกล่าวได้อย่างชัดเจนเกี่ยวกับเวลาการทำงาน
ก็คือเวลาที่ใช้มีอัตราการเปลี่ยนแปลงเหมือนกับฟังก์ชัน $n$ และในตัวอย่างนี้
ไม่ว่าเราจะวิเคราะห์เวลาการทำงานแบบคร่าว ๆ ได้เป็น $2n^2+3n+3$
หรือจะพยายามวิเคราะห์ให้ละเอียดขึ้นเป็น $2(c_2+c_3+2c_1)n^2 + (3c_2 + 2c_3 +
4c_1)n + 2c_1 + c4$
สิ่งที่เรารู้อย่างชัดเจนจากการวิเคราะห์ก็คือเวลาที่ใช้มีลักษณะการเปลี่ยนแปลงเหมือนกับฟังก์ชัน
$n^2$

อย่างไรก็ตาม สิ่งที่เรากล่าวมานั้นยังไม่ชัดเจนทางคณิตศาสตร์มากพอ แม้ว่าเราจะพอนึกภาพได้
แต่เรายังไม่สามารถกล่าวอย่างชัดเจนว่า
เมื่อเรากล่าวว่าฟังก์ชันหนึ่งมีอัตราการเปลี่ยนแปลงเหมือนกับอีกฟังก์ชันหนึ่ง
แท้จริงแล้วมีความหมายอย่างไร ในส่วน~\ref{sect:analysis-big-o-definition}
เราจะศึกษานิยามเกี่ยวกับอัตราการโตของฟังก์ชันที่จะทำให้เรากล่าวถึงแนวคิดนี้ได้อย่างเป็นรูปแบบ

ในส่วนที่เหลือนี้ เราจะยกตัวอย่างความคลาดเคลื่อนในการวิเคราะห์เวลาการทำงาน
ที่เป็นผลจากสถาปัตยกรรมของคอมพิวเตอร์ที่โปรแกรมทำงาน

\subsubsection{ตัวอย่าง: ผลจากการเปลี่ยนรูปแบบการอ่านค่าในหน่วยความจำ}

พิจารณาฟังก์ชันสองฟังก์ชันที่คำนวณผลรวมของข้อมูลในอาร์เรย์สองมิติ
ในโปรแกรม~\ref{code:analysis-example-caching-effect}

\begin{figure}
---src[cpp,ฟังก์ชัน {\ct calA} และ {\ct calB} ที่คำนวณผลรวมของข้อมูลในอาร์เรย์สองมิติ,code:analysis-example-caching-effect]
int calA()
{
  int x = 0;
  for(int i = 0; i < n; ++i)
    for(int j = 0; j < n; ++j)
      x += ar[i][j];
  return x;
}
int calB()
{
  int x = 0;
  for(int j = 0; j < n; ++j)
    for(int i = 0; i < n; ++i)
      x += ar[i][j];
  return x;
}
---
\end{figure}

---q *
ฟังก์ชัน {\ct calA} กับ {\ct calB} ต่างกันอย่างไร?  เมื่อนำไปทำงาน
เวลาที่ใช้ทำงานจะแตกต่างกันหรือไม่?  ถ้าคิดว่าแตกต่างฟังก์ชันใดน่าจะทำงานเร็วกว่า
ทำไมถึงน่าจะเป็นเช่นนั้น?
---

เมื่อนำฟังก์ชันไปทดลอง เนื่องจากต้องมีการกำหนดค่าเริ่มต้นให้กับอาร์เรย์
เราจึงให้โปรแกรมกำหนดค่าเริ่มต้นให้อาร์เรย์ จากนั้นเรียกฟังก์ชันดังกล่าว 10 รอบ
เพื่อลดผลของเวลาจากการกำหนดค่าเริ่มต้น

ค่าเฉลี่ยของเวลาการทำงาน เมื่อ {\ct n} มีค่าเท่ากับ 10,000 ของโปรแกรมที่ใช้ฟังก์ชัน
{\ct calA} คือ 4.55 วินาที ในขณะที่โปรแกรมที่ใช้ฟังก์ชัน {\ct calB} คือ 11.54 วินาที
คิดเป็นประมาณ 2.5 เท่าของเวลาของโปรแกรมที่ใช้ฟังก์ชัน {\ct calA}

ความแตกต่างดังกล่าว เกิดขึ้นเนื่องจากรูปแบบของการอ่านข้อมูลในหน่วยความจำที่ต่างกัน
มีผลต่อประสิทธิภาพของระบบหน่วยความจำ (ในที่นี้คือระบบ cache)
ซึ่งการที่จะวิเคราะห์ให้ละเอียดระดับนี้ได้
จะต้องใช้ข้อมูลและความรู้เกี่ยวกับเครื่องคอมพิวเตอร์ที่จะนำโปรแกรมไปทำงาน
และการปรับโปรแกรมให้ทำงานได้ดีในลักษณะนี้ แม้จะเป็นงานเชิงวิศวกรรมที่น่าสนใจ
แต่ก็อยู่นอกขอบเขตของหนังสือเล่มนี้

สังเกตว่า ในการวิเคราะห์เวลาการทำงานโดยใช้วิธีที่เรากล่าวมาแล้ว
เวลาการทำงานของทั้งสองฟังก์ชันจะมีค่าเท่ากัน แต่เวลาที่ใช้งานจริง กลับแตกต่างกันมาก
ฟังก์ชันดังกล่าวเป็นตัวอย่างหนึ่งของความคลาดเคลื่อนของการวิเคราะห์
ที่เป็นผลมาจากสถาปัตยกรรมของคอมพิวเตอร์และรูปแบบการเก็บข้อมูลของภาษาโปรแกรมที่ใช้

\subsection{สัญกรณ์โอใหญ่ (Big-O)}
\label{sect:analysis-big-o-definition}

เป้าหมายหลักของการวิเคราะห์เวลาการทำงานของอัลกอริทึม
นอกจากเพื่อจะพิจารณาความเป็นไปได้ที่อัลกอริทึมจะมีประสิทธิภาพพอแล้ว
ยังทำไปเพื่อเลือกอัลกอริทึมที่เหมาะสมที่สุดที่จะนำมาอิมพลีเมนท์ด้วย
ดังนั้นในการวิเคราะห์เราต้องการให้อัลกอริทึมที่มีประสิทธิภาพแตกต่างกัน
มีเวลาที่วิเคราะห์ได้แตกต่างกันและสามารถเปรียบเทียบกันได้

---q *
จากฟังก์ชันของเวลาที่วิเคราะห์ได้ด้านล่าง
พิจารณาว่าฟังก์ชันใดเปรียบเทียบกันได้อย่างมีความหมายในแง่ของประสิทธิภาพ
\[
2n, \ \ \ \ n^3 + 4n, \ \ \ \ 10n^2, \ \ \ \ 0.5n + 100, \ \ \ \ 3n^2 + 1000n
\]
---

จากตัวอย่างในเนื้อหาส่วนที่แล้ว เราพบว่าฟังก์ชันของเวลาที่เราวิเคราะห์ได้นั้น
ค่าคงที่ที่ติดมาในนิพจน์นั้นไม่มีผลชัดเจนในการระบุความเร็วหรือช้าของอัลกอริทึม นอกจากนี้
ถ้าฟังก์ชันที่ได้มีหลายพจน์ พจน์ที่มีกำลังต่ำกว่าจะมีผลในเวลาการทำงานน้อยลง
ถ้าข้อมูลมีขนาดใหญ่ขึ้นเรื่อย ๆ จากข้อสังเกตทั้งสอง
ในการเปรียบเทียบเราสามารถตัดส่วนของนิพจน์ที่ไม่สำคัญออกได้
โดยฟังก์ชันตัวอย่างในคำถามข้างต้น เมื่อตัดค่าคงที่และพจน์ที่มีกำลังต่ำออกไปแล้ว
จะเป็นดังด้านล่าง
\[
n, \ \ \ \ n^3, \ \ \ \ n^2, \ \ \ \ n, \ \ \ \ n^2
\]
ซึ่งฟังก์ชันเหล่านี้จะบอกแนวโน้มของการโตของเวลาการทำงาน

ก่อนที่เราจะเสนอนิยามของการโตอย่างเป็นทางการ เราจำเป็นต้องย้ำอีกทีว่า
การที่เราละทิ้งหรือตัดค่าคงที่ออกไปนั้นไม่ได้หมายความว่าค่าคงที่ต่าง ๆ
ไม่มีผลต่อเวลาการทำงาน หลาย ๆ อัลกอริทึมที่วิเคราะห์ออกมาพบว่าประสิทธิภาพดี
แต่เมื่อทำงานจริงกลับช้ากว่าอัลกอริทึมที่วิเคราะห์ออกมาได้ว่ามีประสิทธิภาพต่ำกว่า
ทั้งนี้เนื่องจากค่าคงที่ต่าง ๆ ที่ผู้วิเคราะห์ได้ละทิ้งออกจากการพิจารณา
ทั้งนี้โดยมากเป็นเพราะว่าขนาดของข้อมูลป้อนเข้ามีขนาดไม่ใหญ่พอ
ที่ผลของอัตราการโตจะชนะผลของค่าคงที่ เราจะได้เห็นตัวอย่างที่ชัดเจนขึ้นต่อไป

---q *
พิจารณาคู่ของฟังก์ชันต่อไปนี้ ให้หาค่า $n$ ที่รับประกันว่าฟังก์ชันแรกจะมีค่าน้อยกว่าฟังก์ชันที่สอง
(1) $10000$ กับ $n$, \ \ (2) $1000n$ กับ $n^2$, \ \ (3) $5000n$ กับ $2n^2 -
100n$, \ \ และ (4) $10000n$ กับ $0.01n^3$
---

ในการที่เราจะบอกว่าฟังก์ชันหนึ่ง มีขอบเขตบนของการโตเป็นอะไรเราจะใช้สัญกรณ์โอใหญ่
(big-O notation) โดยตัวอย่างของการใช้สัญกรณ์ดังกล่า่ว เช่น $n^2 + 100n$ เป็น
$O(n^2)$ หรือ $30n + 5$ เป็น $O(n)$ 

เราจะหาคำนิยามที่สะท้อนสิ่งที่เราได้ทดลองมาในการที่จะระบุว่าฟังก์ชัน $f(n)$ เป็น
$O(g(n))$ (หรือมีอัตราการโตไม่เกินฟังก์ชัน $g(n)$)
\begin{itemize}
\item ข้อสังเกตข้อแรกก็คือ ค่าคงที่ไม่มีผล นั่นคือฟังก์ชัน $100n$ หรือ $1000n$ หรือกระทั่ง
  $0.0001n$ ก็เป็น $O(n)$ เหมือนกัน ดังนั้นในการจะกล่าวว่า $f(n)$ เป็น $O(g(n))$
  เราต้องยอมให้มีการใช้ค่าคงที่มา ``ช่วย'' ฟังก์ชัน $g(n)$
  ให้มีค่ามากขึ้นจนเปรียบเทียบกับ $f(n)$ ได้
\item ข้อสังเกตข้อที่สองคือ พจน์ที่มีกำลังต่ำ ๆ จะไม่มีผล
  การที่จะทำให้พจน์ดังกล่าวลดความสำคัญลงไปนั้น เราจะต้องวิเคราะห์ฟังก์ชันเมื่อ $n$
  มีค่ามาก~ๆ เพื่อให้พจน์ที่สำคัญน้อยมีผลต่อค่าของฟังก์ชันลดลง
\end{itemize}

---q ทดลองสร้างคำนิยาม
จากข้อสังเกตสองข้อข้างต้น ทดลองเขียนคำนิยามของสัญกรณ์โอใหญ่: \\
เราจะกล่าวว่า $f(n)$ เป็น $O(g(n))$ เมื่อ ...................
---

พิจารณากรณีที่เราต้องการแสดงว่า $3n+100$ เป็น $O(n)$ (นั่นคือในที่นี้ $f(n)=3n+100$
และ $g(n)=n$ และเราต้องการแสดงว่า $f(n)$ เป็น $O(g(n))$) สังเกตว่า
\[
3n + 100 > n,
\]
สำหรับทุก ๆ $n\geq 0$ ดังนั้นเราจำเป็นจะต้องเพิ่มค่าคงที่ให้กับฟังก์ชัน $g(n)$
อย่างไรก็ตามถ้าเราคูณ $g(n)$ ด้วย 3 ก็ยังไม่เพียงพอเพราะว่า
\[
3n + 100 > 3\cdot n,
\]
อยู่ดี  ดังนั้นเราจะคูณ $g(n)$ ด้วย 4  อย่างไรก็ตาม อสมการ
\[
3n + 100 \leq 4\cdot n
\]
ก็ยังไม่เป็นจริงสำหรับทุก ๆ ค่า $n$ ที่มากกว่าหรือเท่ากับศูนย์

---q ขีดจำกัดล่าง
ค่า $n$ จะต้องมีค่าอย่างน้อยเท่าใด อสมการ $3n+100\leq 4n$ จึงจะเป็นจริง?
---

จากตัวอย่างข้างต้น เราใช้ค่าคงที่สองตัวคือ $c$ เป็นค่าคงที่สำหรับเป็นตัวคูณของฟังก์ชัน
$g(n)$ และ $n_0$ เพื่อระบุขอบเขตล่างของขนาดข้อมูลที่เราสนใจ
เราจะนิยามสัญกรณ์โอใหญ่อย่างเป็นทางการดังนี้:

เราจะกล่าวว่าฟังก์ชัน $f(n)$ เป็น $O(g(n))$ ก็ต่อเมื่อ มีค่าคงที่ $c$ และ $n_0$ ที่
$f(n) \leq c\cdot g(n)$ เมื่อ $n\geq n_0$

ในกรณีดังกล่าว บางครั้งเราก็จะกล่าวว่า $f(n)$ มีการโตเป็น $O(g(n))$ หรือเขียนว่า
$f(n)=O(g(n))$ ซึ่งในกรณีหลังนี้ เครื่องหมายเท่ากับที่ใช้ ไม่ได้มีความหมายว่าเท่ากัน
แต่เป็นการบิดสัญกรณ์เท่ากับให้เป็นความหมายตามที่เรานิยามมาแล้ว\footnote{ซึ่งถ้าจะให้ถูกต้องตามนิยามจริง
  ๆ เราจะต้องนิยามสัญกรณ์ $O(\cdot)$ ว่าเป็นเซตของฟังก์ชัน แล้วใช้เครื่องหมาย $\in$
  แทนเครื่องหมายเท่ากับ เช่น เราจะเขียนว่า $3n+100\in O(n)$ แทนที่จะเขียน
  $3n+100=O(n)$
  แต่ในหนังสือเล่มนี้เรายินดีจะบิดพริ้วนิยามของสัญกรณ์เท่ากับเพื่อความเรียบง่าย}

สำหรับตัวอย่างข้างต้นที่เราแสดงว่า $3n+100$ เป็น $O(n)$ นั้น เราใช้ $c=4$ และ
$n_0$ ที่เป็นไปได้ก็คือ 100 อย่างไรก็ตาม เราสามารถเลือกคู่ของค่าคงที่ $c$ และ $n_0$
แบบอื่น ๆ ได้อีก เช่น ถ้าเราให้ $c=13$ เราอาจใช้ $n_0=10$ ก็เพียงพอ เพราะว่า
\[
3n+100 \leq 13n
\]
เมื่อ $n\leq 10 = n_0$

คำถามทั้ง 3 คำถามต่อไปสำคัญต่อการทำความเข้าใจต่อไปในบทนี้

---q ฟังก์ชันกำลังสอง
จงแสดงว่า $5n^2 + 100n + 1000$ เป็น $O(n^2)$
---

---q ฟังก์ชันที่ใหญ่กว่า
จงแสดงว่า $100n + 1000$ เป็น $O(n^2)$
---

---q ค่าคงที่
จงแสดงว่า สำหรับค่าคงที่ $c$ ใด ๆ $c = O(1)$
---

สำหรับฟังก์ชันที่เป็นฟังก์ชันพหุนาม
เรามีวิธีการที่จะระบุการโตได้โดยพิจารณาพจน์ที่มีกำลังมากที่สุด เราจะพิสูจน์ว่าวิธีดังกล่าวถูกต้อง

\begin{theorem}
สำหรับฟังก์ชัน $f(n)=a_dn^d + a_{d-1}n^{d-1} + a_{d-2}n^{d-2} +\cdots +
a_1n + a_0$ เราจะได้ว่า $f(n)=O(n^d)$
\end{theorem}
\begin{proof}
สังเกตว่าพจน์ที่มีสัมประสิทธิ์เป็นลบ จะไม่มีผลในการเปรียบเทียบกับ $c\cdot n^d$
ดังนั้นเราจะตัดออกไป โดยพิจารณาอีกฟังก์ชันหนึ่งที่ทุกสัมประสิทธิ์ไม่เป็นลบ

นิยามฟังก์ชัน $f'(n)$ โดยให้ $f'(n)=\sum_{i=0}^{d} a'_i n^i$ เมื่อ
$a'_i=\max\{a_i,0\}$ สังเกตว่า $f(n)\leq f'(n)$ เมื่อ $n \geq 0$ เสมอ

เราต้องเพิ่มสัมประสิทธิ์ให้กับ $n^d$ เพื่อจะให้ฟังก์ชันนี้ใหญ่กว่าทุก ๆ พจน์ สังเกตว่า
\[
a'_i n^i \leq a'_i n^d
\]
เมื่อ $n\geq 0$, นั่นคือ
\begin{eqnarray*}
a'_d n^d + a'_{d-1}n^{d-1} +\cdots + a'_1n + a'_0 
&\leq&
a'_d n^d + a'_{d-1}n^d +\cdots + a'_1n^d + a'_0n^d\\
&=&
\left(a'_d + a'_{d-1} +\cdots + a'_1 + a'_0\right)n^d,
\end{eqnarray*}
เมื่อ $n\geq 0$ ดังนั้นเราจะเลือกให้ $n_0=0$ และ
\[
c = \left(a'_d + a'_{d-1} +\cdots + a'_1 + a'_0\right)
\]
เราจะได้ว่า
\[
f(n) \leq f'(n) \leq c\cdot n^d,
\]
เมื่อ $n\geq n_0=0$, นั่นคือ $f(n)=O(n^d)$ ตามต้องการ
\end{proof}

---q กำลังที่มากกว่า
ให้ $f(n) = O(n^d)$ จงแสดงว่า $f(n) = O(n^e)$ เมื่อ $e\geq d$
---

เนื่องจากโดยมากฟังก์ชันของเราจะเป็นฟังก์ชันที่ขึ้นกับ $n$
เพื่อความสะดวกเราจะละอาร์กิวเมนท์ $n$ ไว้ โดยเราจะเขียน $f(n)$ ด้วย $f$
นอกจากนี้เรายังเขียนแทน $f(n)+g(n)$ ด้วย $f+g$

ด้านล่างเป็นคุณสมบัติอื่น ๆ
ที่มีประโยชน์ในการนำสัญกรณ์โอใหญ่ไปใช้ในการวิเคราะห์เวลาการทำงานของอัลกอริทึม

\begin{theorem}
ถ้า $f=O(h)$ และ $g=O(h)$ แล้ว $f+g = O(h)$
\end{theorem}
\begin{proof}
เนื่องจาก $f=O(h)$ และ $g=O(h)$ จึงมีค่าคงที่ $c_1$ และ $n_1$ ที่
\[ f(n) \leq c_1\cdot h(n)\] 
เมื่อ $n\geq n_1$ และค่าคงที่ $c_2$ กับ $n_2$ ที่ 
\[ g(n) \leq c_2\cdot h(n) \] 
เมื่อ $n\geq n_2$

ดังนั้น ถ้าให้ $c=c_1+c_2$ และ $n_0=\max\{n_1,n_2\}$ เราจะได้ว่า
\[
f(n) + g(n) \leq c_1\cdot h(n) + c_2\cdot h(n) = c\cdot h(n)
\]
เมื่อ $n\geq n_0$, นั่นคือ $f+g=O(h)$
\end{proof}

---q *
จงพิสูจน์ว่า ถ้า $f=O(g)$ และ $g=O(h)$ แล้ว $f=O(h)$
---

---q *
เราสามารถคุณสมบัติสองคุณสมบัติข้างต้น ไปใช้ในการวิเคราะห์อัลกอริทึมในลักษณะใด?
---

\subsection{การวิเคราะห์เวลาการทำงานโดยใช้สัญกรณ์โอใหญ่}

ที่ผ่านมาเราวิเคราะห์เวลาการทำงานอย่างละเอียดและได้ผลลัพธ์เช่น $2n+2$ หรือเป็น
$2n^2 + 2n + 4$
จากนั้นเราจึงใช้สัญกรณ์โอใหญ่ในการวิเคราะห์การโตและสรุปว่าเวลาการทำงานเป็น $O(n)$
หรือ $O(n^2)$
อย่างไรก็ตามถ้าเราต้องการวิเคราะห์แค่อัตราการโตของเวลาการทำงานในสัญกรณ์โอใหญ่
เราสามารถใช้สัญกรณ์โอใหญ่ระหว่างการนับเวลาการทำงานของแต่ละคำสั่งในอัลกอริทึมได้ด้วย

เราจะกลับมาวิเคราะห์เวลาการทำงานของอัลกอริทึม~\ref{algo:analysis-cheapest-pair}
(ในรูปที่~\ref{fig:algo-analysis-cheapest-pair}) โดยใช้สัญกรณ์โอใหญ่ตั้งแต่เริ่มต้น
สังเกตว่าอัลกอริทึมนี้มีการทำงาน 4 ส่วนใหญ่ ๆ คือส่วนตอนแรกที่กำหนดค่าเริ่มต้น (บรรทัดที่ 1
และ 2), ส่วนคำนวณรั้วเดี่ยว, ส่วนคำนวณรั้วคู่, และส่วนคืนคำตอบ ในส่วนแรกและส่วนสุดท้าย
ทำงานในเวลาคงที่ ดังนั้นจะได้ว่าทำงานในเวลา $O(1)$

สำหรับส่วนรั้วเดี่ยว การทำงานในบรรทัดที่ 4-6 นั้นแต่ละคำสั่งทำงานในเวลาคงที่
ดังนั้นใช้เวลา $O(1)$ การทำงานดังกล่าว ทำซ้ำจำนวน $n$ รอบ ดังนั้นจะใช้เวลารวมเป็น
$O(n)$

ในส่วนรั้วคู่นั้น ถ้าเราพิจารณาเฉพาะวงรอบภายใน เราพบว่าไม่ว่าค่า $i$
จะเป็นเท่าใดจะทำงานไม่เกิน $n$ รอบ นั่นคือการทำงานวนรอบ FOR ในบรรทัดที่ 7
แต่ละรอบ จะใช้เวลา $O(n)$ เราจะทำงานทั้งสิ้น $n$ รอบ ดังนั้นจะใช้เวลา $O(n^2)$

ดังนั้นเวลารวมคือ $O(1) + O(n) + O(n^2)$ ซึ่งสามารถแสดงได้ไม่ยากว่าคือ $O(n^2)$

เราจะวิเคราะห์เวลาการทำงานของอีกอัลกอริทึมหนึ่ง 

TODO: เขียนส่วนนี้ ให้มีการเปลี่ยนเทียบเวลาการทำงานของอัลกอริทึมสองอันที่เวลาไม่เท่ากัน แสดงกราฟ

ในส่วนถัดไปของบทนี้เราจะได้วิเคราะห์เวลาการทำงานของโครงสร้างข้อมูลหลายแบบที่พัฒนาบนอาร์เรย์
และในส่วนสุดท้ายเราจะได้พิจารณาตัวอย่างอัลกอริทึมที่มีเวลาการทำงานอื่น ๆ

\section{แบบชนิดข้อมูลนามธรรมและการอิมพลีเมนท์ด้วยอาร์เรย์}

แบบชนิดข้อมูลนามธรรม (abstract data types)
ระบุวิธีการที่เราจะเข้าถึงและจัดการกับข้อมูลผ่านทางแบบชนิดข้อมูลนั้น ๆ
โดยไม่จำเป็นต้องระบุว่าขั้นตอนดำเนินการจริง ๆ ของวิธีการเหล่านั้นเป็นอย่างไร

ในส่วนที่~\ref{sect:array-list-processing}
เราได้ศึกษาวิธีการนำอาร์เรย์ไปใช้เก็บข้อมูลที่มีลักษณะเป็นรายการ ในที่นี้ เมื่อเรากล่าวถึง
``รายการ'' เราจะมีภาพอยู่ว่าเราจะต้องดำเนินการอะไรกับรายการได้บ้าง
นั่นคือวิธีการที่เราจะเข้าถึงและจัดการกับข้อมูลในรายการ ซึ่งจริง ๆ แล้ว
เราอาจจะใช้โครงสร้างข้อมูลแบบอื่นในการอิมพลีเมนท์ไม่จำเป็นต้องเป็นอาร์เรย์ก็ได้

เราจะเรียกกระบวนการทั้งหมดที่เราสามารถเรียกใช้งานกับแบบชนิดข้อมูลนามธรรมว่าอินเทอร์เฟส
(interface) ของแบบชนิดข้อมูลนั้น สำหรับข้อมูลแบบรายการที่เราได้พิจารณามาแล้ว
จะมีอินเทอร์เฟสโดยทั่วไปดังนี้

\begin{itemize}
\item IsEmpty($L$) ตรวจสอบว่ารายการ $L$ ว่างเปล่าหรือไม่
\item Find($L$,$x$) - ค้นหาข้อมูล $x$ ใน $L$ แล้วคืนผลลัพธ์เป็นข้อมูลที่ทำให้อ้างถึง
  $x$ ในรายการได้ (ซึ่งจะถูกใช้ในคำสั่ง Delete และ Insert ได้)
\item Append($L$,$x$) - เพิ่มข้อมูล $x$ ท้ายรายการ $L$
\item Delete($L$,$p$) - ลบข้อมูลที่ถูกอ้างถึงโดย $p$
\item InsertAfter($L$,$p$,$x$) - เพิ่มข้อมูล $x$ ต่อจากข้อมูลที่อ้างถึงโดย $p$
\end{itemize}

สังเกตว่า อินเทอร์เฟสดังกล่าว
มีความแตกต่างจากรูปแบบที่เราใช้ในการประกาศฟังก์ชันที่ทำงานดังกล่าวเล็กน้อย
ความแตกต่างนี้ไม่ใช่สิ่งสลักสำคัญมากนักเมื่อเราออกแบบอัลกอริทึม
และการนำแบบชนิดข้อมูลใปใช้จริงก็มักจะต้องอ้างอิงกับการอิมพลีเมนท์ตลอดอยู่ดี อย่างไรก็ตาม
ถ้าอินเทอร์เฟสของแบบชนิดข้อมูลนามธรรมนี้เหมือนกัน
ไม่ว่าจะอิมพลีเมนท์ด้วยโครงสร้างข้อมูลใด
ก็จะทำให้การเปลี่ยนประเภทโครงสร้างข้อมูลในโปรแกรมทำได้สะดวก
ในบทที่~\ref{chapter:classes} เราจะศึกษาวิธีการพัฒนาโปรแกรมภาษา C++
เพื่อทำให้บรรลุจุดประสงค์นี้

ผู้อ่านที่สนใจอาจสงสัยว่าเมื่อมี InsertAfter ทำไมไม่มีการระบุกระบวนการ
\begin{itemize}
\item InsertBefore($L$,$p$,$x$) - เพิ่มข้อมูล $x$ ก่อนหน้าข้อมูลที่อ้างถึงโดย $p$
\end{itemize}
อยู่ในรายการอินเทอร์เฟส ในบทต่อ ๆ ไป เราจะพบว่าโครงสร้างข้อมูลที่จะรองรับทั้ง
InsertAfter และ InsertBefore ได้พร้อม ๆ
กันจะต้องมีภาระมากกว่าโครงสร้างข้อมูลที่รองรับแค่รูปแบบเดียวและเราจะได้พัฒนาโครงสร้างข้อมูลดังกล่าวด้วย
อย่างไรก็ตามในบทนี้ เราจะยังไม่พิจารณากระบวนการดังกล่าว

ตารางในรูปที่~\ref{fig:array-running-time-list-by-array}
แสดงเวลาที่เราเคยได้วิเคราะห์ไว้ในรูปของอัตราการโต เมื่อรายการมีข้อมูล $n$ จำนวน

\begin{figure}
\begin{center}
\begin{tabular}{|l|c|}\hline
กระบวนการ & เวลาการทำงานเมื่อพัฒนาด้วยอาร์เรย์ \\
\hline
IsEmpty & $O(1)$\\
Find & $O(n)$\\
Append & $O(1)$\\
Delete & $O(n)$\\
InsertAfter & $O(n)$\\
\hline
\end{tabular}
\end{center}
\caption{เวลาการทำงานของกระบวนการต่าง ๆ ของรายการ ที่พัฒนาด้วยอาร์เรย์}
\label{fig:array-running-time-list-by-array}
\end{figure}

สำหรับรายการโดยทั่วไปแล้ว เราอาจจะมีกระบวนการอื่น ๆ อีก เช่น
นำรายการที่สองไปต่อท้ายรายการแรก หรือนำรายการหนึ่งไปแทรกภายในอีกรายการหนึ่ง
กระบวนการเหล่านี้สามารถอิมพลีเมนท์ด้วยอาร์เรย์ได้ไม่ยากนัก และโดยมากจะใช้เวลา
$O(n)$ เมื่อ $n$ แทนจำนวนข้อมูลที่อยู่ในรายการ

\subsubsection{การวิ่งไปในชุดของข้อมูล}

อินเทอร์เฟสที่เรากล่าวไปแล้วนั้นยังขาดกลุ่มกระบวนการเข้าถึงข้อมูลทุกตัวในรายการไปทีละตัว
รูปแบบที่เราจะใช้จะสอดคล้องกับการใช้งานตัววิ่ง (iterator) ในไลบรารีมาตรฐานของ C++

ในการอ้างถึงข้อมูลทุกตัวในรายการ
เราจะใช้ตัววิ่งที่มีลักษณะการทำงานเหมือนกับการใช้พอยน์เตอร์วิ่งไปในอาร์เรย์
สังเกตว่าในกรณีของอาร์เรย์ เรายังสามารถใช้ดัชนีในการไล่พิจารณาข้อมูลทุกตัวได้
แต่กับแบบชนิดข้อมูลอื่น ๆ การใช้ดัชนีอาจจะไม่ใช้วิธีที่เป็นธรรมชาตินัก

ตัววิ่งที่ใช้ในการไล่พิจารณาข้อมูลนี้ มักนิยมใช้ในการอ้างถึงข้อมูลในการใช้งานกระบวนการเช่น
Delete หรือ InsertAfter ด้วย

เราจะนิยามอินเทอร์เฟสเพิ่มเติมดังนี้
\begin{itemize}
\item Begin($L$) คืนตัววิ่งที่อ้างถึงข้อมูลตัวแรกในรายการ $L$
\item End($L$) คืนตัววิ่งที่อ้างถึงตำแหน่งที่ไม่มีข้อมูลแล้วของรายการ $L$
  (เราจะใช้ตัววิ่งนี้ในการระบุจุดสิ้นสุดของข้อมูล)
\item Next($p$) คืนตัววิ่งที่อ้างถึงข้อมูลถัดจากตัววิ่ง $p$
\item Value($p$) คือข้อมูลที่อ้างถึงโดยตัววิ่ง $p$
\end{itemize}

การใช้งานตัววิ่งจะมีลักษณะเดียวกันกับการใช้พอยน์เตอร์วิ่งไปในอาร์เรย์ ดังแสดงในโปรแกรมที่~\ref{code:analysis-iterator-and-pointer}

\begin{figure}
---src[cpp,โปรแกรมที่หาผลรวมโดยการใช้ตัววิ่งผ่านทางอินเทอร์เฟสเทียบกับการใช้พอยน์เตอร์,code:analysis-iterator-and-pointer]
int list_sum_itr(int list[],      | int list_sum_ptr(int list[],
                 int size)        |                  int size)
{                                 | {
  int s = 0;                      |   int s = 0;
  for(list_itr i =                |   for(int* i = &list[0];
        list_begin(list,size);    | 
      i != list_end(list,size);   |       i != &list[size];
      i = list_itr_next(i)) {     |       i = i + 1) {
    s += list_itr_value(i);       |     s += *i;
  }                               |   }
  return s;                       |   return s;
}                                 | }
---
\end{figure}

เราจะประกาศแบบชนิดข้อมูล {\ct list\_itr} เพื่อใช้เป็นชนิดของข้อมูลตัววิ่ง
โดยจะประกาศด้วยคีย์เวิร์ด {\ct typedef} ดังด้านล่าง

---src[cpp]
typedef int* list_itr;
---

ในบทนี้เราจะเขียนการดำเนินการดังกล่าวในลักษณะของฟังก์ชันธรรมดา
ซึ่งจะทำให้การเรียกใช้ค่อนข้างยุ่งยากไม่สะดวกเหมือนกับการใช้งานพอยน์เตอร์
ในบทที่~\ref{chapter:classes} เราจะใช้การเขียนฟังก์ชันของตัวดำเนินการ (operator
overloading) ทำให้กระบวนการดังกล่าวมีรูปแบบการใช้งานเหมือนกับพอยน์เตอร์ดังด้านขวา

โปรแกรมที่~\ref{code:analysis-list-operations-in-arrays}
แสดงการอิมพลีเมนท์บางกระบวนการในอินเทอร์เฟสของรายการด้วยอาร์เรย์ตามที่ได้กล่าวมาแล้ว
สังเกตว่าโดยมากฟังก์ชันที่เกี่ยวข้องกับตัววิ่งเป็นฟังก์ชันที่สั้น การประกาศให้เป็น {\ct
  inline} จะทำให้คอมไพเลอร์เลือกที่จะแทรกฟังก์ชันเหล่านี้ลงไปยังจุดที่เรียกใช้งานเลย
แทนที่จะมีการเรียกฟังก์ชันจริง ๆ เพื่อลดเวลาการทำงาน

\begin{figure}
---src[cpp,การอิมพลีเมนท์บางกระบวนการของรายการด้วยอาร์เรย์,code:analysis-list-operations-in-arrays]
// iterator functions
inline list_itr list_begin(int list[],int size) {return &list[0];}
inline list_itr list_end(int list[],int size) {return &list[size];}
inline list_itr list_itr_next(list_itr p) { return p+1; }
inline int list_itr_value(list_itr p) { return *p; }

// other interesting list functions
void list_delete(int list[], int size, list_itr p)
{
  list_itr end = list_end(list,size);
  list_itr np = list_itr_next(p);
  while(np != end) {
    *p = *np;
    p = np;
    np = list_itr_next(np;
  }
}
---
\end{figure}

ในการใช้งาน {\ct list\_itr} เป็นตัววิ่งในการคืนค่าจากฟังก์ชันเช่น {\ct list\_find}
เราจำเป็นจะต้องกำหนดว่าถ้าไม่พบข้อมูล ตัววิ่งจะมีค่าเป็นเช่นใด
เราจะใช้รูปแบบเช่นเดียวกับไลบรารีมาตรฐานคือเราจะคืนค่าตัววิ่งที่อ้างถึงตำแหน่งที่ไม่มีข้อมูล
(นั่นคือจะมีค่าเท่ากับค่าที่ได้เมื่อเรียกฟังก์ชัน End)

---q *
ทดลองเขียนฟังก์ชันทั้งหมดในอินเทอร์เฟสรายการด้วยอาร์เรย์
---

เวลาการทำงานของฟังก์ชันที่เกี่ยวกับตัววิ่งทั้งหมดเป็นค่าคงที่ นั่นคือใช้เวลา $O(1)$ 

\subsection{พจนานุกรม}
พิจารณาปัญหาต่อไปนี้

---p *
TODO: เพิ่มปัญหาที่มีการใช้พจนานุกรม
---

ในส่วนนี้เราจะทำความรู้จักกับแบบชนิดข้อมูลนามธรรมที่มีประโยชน์มากที่เรียกว่า {\em
  พจนานุกรม} หรือ {\em dictionary}
แบบชนิดข้อมูลนี้รองรับการเก็บข้อมูลที่ประกอบด้วยข้อมูลและกุญแจ
จากนั้นสามารถค้นหาข้อมูลได้ด้วยกุญแจ ยกตัวอย่างเช่น
เราสามารถเก็บข้อมูลเกี่ยวกับพนักงานบริษัทไว้ โดยใช้กุญแจเป็นหมายเลขประจำตัวพนักงาน
เมื่อเราต้องการหาข้อมูล เราก็จะระบุหมายเลขประจำตัวพนักงาน
แบบชนิดข้อมูลนี้ก็จะคืนข้อมูลทั้งหมดของพนักงานคนนั้นให้

ในมุมหนึ่งโครงสร้างข้อมูลแบบอาร์เรย์ ก็เป็นรูปแบบหนึ่งของการเก็บข้อมูลแบบพจนานุกรม
แต่กุญแจที่ใช้จะต้องเป็นจำนวนเต็มเท่านั้น
นอกจากนี้ขนาดของอาร์เรย์ก็จะขึ้นกับค่าที่มากที่สุดของกุญแจ
ซึ่งอาจจะมีค่ามากกว่าจำนวนข้อมูลที่ต้องการเก็บลงในพจนานุกรมเป็นจำนวนมากก็ได้

อินเทอร์เฟสของพจนานุกรมมีรูปแบบทั่วไปดังนี้
\begin{itemize}
\item IsEmpty($D$) - ตรวจสอบว่าพจนานุกรม $D$ ว่างเปล่าหรือไม่
\item Insert($D$,$(k,v)$) - เพิ่มข้อมูล $v$ ลงในพจนานุกรม $D$ โดยให้ $k$ เป้นกุญแจ
\item Find($D$,$k$) - ค้นหาข้อมูลในพจนานุกรม $D$ ที่มีกุญแจเป็น $k$
  แล้วคืนตัววิ่งที่อ้างถึงข้อมูลดังกล่าว
\item Delete($D$,$p$) - ลบข้อมูลในพจนานุกรม $D$ ที่ถูกอ้างถึงโดยตัววิ่ง $p$
\end{itemize}

พจนานุกรมยังมีประเภทย่อย ๆ อีกหลายแบบ
โดยขึ้นกับเงื่อนไขที่พจนานุกรมแบบนั้นรองรับการใช้งาน เช่น
การรองรับกรณีที่ข้อมูลหลายตัวมีกุญแจซ้ำกัน เป็นต้น
พจนานุกรมบางประเภทยังสามารถค้นหาข้อมูลที่มีกุญแจน้อยที่สุด (หรือมากที่สุดได้ด้วย)

ในที่นี้ เพื่อความง่าย เราจะสมมติว่าไม่มีกรณีที่ข้อมูลสองจำนวนใช้กุญแจเดียวกัน
ถ้ามีการจัดเก็บข้อมูลสองชุดด้วยกุญแจเดียวกัน ผลลัพธ์ที่ได้จะขึ้นกับรูปแบบที่เราจะอิมพลีเมนท์

\subsubsection{การอิมพลีเมนท์ด้วยอาร์เรย์แบบแรก}

เราจะอิมพลีเมนท์กระบวนการต่าง ๆ โดยใช้อาร์เรย์สำหรับเก็บรายการสองชุด
ชุดแรกเป็นกุญแจ อีกชุดเป็นข้อมูล
เราจะสมมติว่าทั้งกุญแจและข้อมูลที่เราต้องการจะเก็บเป็นจำนวนเต็ม {\ct int}
ในบทที่~\ref{chapter:classes}
เราจะศึกษาวิธีที่ทำให้โครงสร้างข้อมูลที่เราเขียนทำงานกับข้อมูลประเภทใดก็ได้

ในที่นี้เราจะประกาศอาร์เรย์สำหรับรายการดังนี้
---src[cpp]
int keys[max_size];
int values[max_size];
int dict_size;
---

การสร้างพจนานุกรมเปล่าทำโดยกำหนดให้ตัวแปร {\ct dict\_size} มีค่าเท่ากับศูนย์
การทดสอบ IsEmpty ทำได้โดยการตรวจสอบตัวแปรดังกล่าว

กระบวนการ Insert สามารถจัดการได้โดยใช้กระบวนการ Append ของรายการที่เขียนโดยอาร์เรย์

\begin{figure}
---src[cpp,โปรแกรมการ Insert ที่เรียกใช้ {\ct list\_append} ที่ทำงานผิดพลาด,code:analysis-buggy-dict-insert]
void dict_insert(int keys[], int values[], int& size,  // BUGGY
                 int k, int v)                         // BUGGY
{                                                      // BUGGY
  list_append(keys, size, k);                          // BUGGY
  list_append(values, size, v);                        // BUGGY 
}                                                      // BUGGY
---
\end{figure}

---q *
พิจารณาฟังก์ชันเพิ่มข้อมูลในรายการดังโปรแกรมที่~\ref{code:analysis-buggy-dict-insert}
ฟังก์ชันดังกล่าวเรียกใช้การ Append จากแบบชนิดข้อมูลรายการที่พัฒนาด้วยอาร์เรย์
โปรแกรมทำงานผิดพลาดเพราะว่าอะไร? 
---

ตัวอย่างข้างต้นแสดงให้เห็นความผิดพลาดที่เกิดจากการใช้รายการเขียนพัฒนาบนอาร์เรย์สองรายการ
แต่มีการเปิดใช้ตัวแปร {\ct list\_size} ร่วมกัน
การเปิดให้มีการจัดการข้อมูลภายในโดยตรงอาจส่งให้เกิดผลข้างเคียงได้
ในการพัฒนาโครงสร้างข้อมูลด้วยภาษา C++
เราสามารถป้องกันปัญหาดังกล่าวได้โดยการกำหนดขอบเขตการเข้าถึงข้อมูล
(จะได้ศึกษาในบทที่~\ref{chapter:classes})

---q * 
ถ้ามีการสั่ง Insert ด้วยข้อมูลสองจำนวนที่มีกุญแจเดียวกัน
จะมีผลต่อการทำงานของแบบชนิดข้อมูลที่อิมพลีเมนท์ด้วยวิธีนี้อย่างไร
---

กระบวนการ Find และ Delete ต้องการตัววิ่งที่อ้างถึงข้อมูลในพจนานุกรม
สำหรับตัววิ่งในกรณีนี้เราไม่สามารถใช้พอยน์เตอร์ไปยังข้อมูลในอาร์เรย์ได้เนื่องจากเรามีอาร์เรย์สองอาร์เรย์

---q * 
ถ้าเราต้องการให้ตัววิ่งนั้นสมบูรณ์ในตัวเอง
คือสามารถอ้างถึงข้อมูลทั้งกุญแจและข้อมูลได้โดยใช้เฉพาะข้อมูลที่มีอยู่ในตัววิ่งเท่านั้น (กล่าวคือ
ไม่ต้องอ้างถึงตัวแปร {\ct keys} และ {\ct values})
ชนิดข้อมของตัววิ่งจะต้องเก็บข้อมูลใดบ้าง?
---

เราจะศึกษาวิธีการเขียนคลาสเพื่อที่จะจัดการตามคำตอบของคำถามข้างต้นในบทต่อ ๆ ไป
ในบทนี้เราจะใช้แค่ข้อมูลดัชนีเพื่อแทนตัววิ่ง (ที่ไม่สมบูรณ์) ไปก่อน

กระบวนการ Find และ Delete ทำงานได้ไม่ต่างจากในการอิมพลีเมนท์รายการเท่าใดนัก
เพียงแต่ในการค้นหา เราจะเทียบกุญแจใน {\ct keys} คืนดัชนี และในการลบ
จะต้องย้ายข้อมูลจากทั้งอาร์เรย์ {\ct keys} และอาร์เรย์ {\ct values}
ตัวอย่างของฟังก์ชัน {\ct dict\_find }
แสดงในโปรแกรมที่~\ref{code:analysis-dict-find}

\begin{figure}
---src[cpp,การค้นหาข้อมูลในพจนานุกรมแบบแรก,code:analysis-dict-find]
int dict_find(int keys[], int values[], int size, int x)
{
  for(int i = 0; i != size; ++i)
    if(keys[i] == x)
      return i;
  return -1;                // ****
}
---
\end{figure}

สังเกตว่าเราคืนค่า {\ct -1} เมื่อกุญแจนั้นไม่อยู่ในข้อมูลที่เก็บไว้ การใช้ค่า {\ct -1} นี้
เป็นไปตามความสะดวกที่เราสามารถกำหนดขึ้นได้ เมื่อเราเขียนต่อ ๆ ไป
เรจะเปลี่ยนไปคืนค่าเป็นตัววิ่งที่แสดงถึงสถานะของข้อมูลที่ไม่มี (เช่นที่คืนจาก {\ct
  list\_itr\_end} เป็นต้น) ตามรูปแบบของไลบรารีมาตรฐาน

เวลาการทำงานของฟังก์ชั่นต่าง ๆ
แสดงในตารางในรูปที่~\ref{fig:array-running-time-dict-by-array}

---q *
เขียนอัลกอริทึมสำหรับกระบวนการ Delete ข้อมูลในรายการ และวิเคราะห์เวลาการทำงาน
---

\subsubsection{การอิมพลีเมนท์ด้วยอาร์เรย์อีกรูปแบบหนึ่ง}
วิธีการอิมพลีเมนท์ที่แล้วเก็บข้อมูลในพจนานุกรมลงในอาร์เรย์โดยไม่มีการจัดระบบใด ๆ เลย
ทำให้การหาข้อมูลจำเป็นต้องพิจารณาข้อมูลทุกตัวในอาร์เรย์

---q *
ลองเสนอวิธีการต่าง ๆ ที่เป็นไปได้ในการเก็บข้อมูลให้เป็นระบบมากขึ้น
เพื่อทำให้การค้นข้อมูลทำได้ง่าย
---

เราจะทดลองวิธีง่าย ๆ ที่เราก็มักใช้ในชีวิตประจำวัน
นั่นคือการเรียงข้อมูลในรายการที่เก็บในอาร์เรย์ตามลำดับของกุญแจ
ข้อเสียของเงื่อนไขนี้คือการเพิ่มข้อมูลในพจนานุกรมจะใช้เวลามากขึ้น
เนื่องจากเราจะต้องแทรกข้อมูลลงไปในตำแหน่งที่เหมาะสม อย่างไรก็ตาม
เงื่อนไขนี้จะทำให้เราจัดการกรณีที่มีการเพิ่มข้อมูลที่ใช้กุญแจซ้ำกันได้

จากข้อกำหนดดังกล่าวทำให้เราสามารถพัฒนากระบวนการค้นหาข้อมูลให้เร็วขึ้นได้ กล่าวคือ
ถ้าเราต้องการหาข้อมูลที่มีกุญแจ $k$ โดยการไล่พิจารณากุญแจที่มีค่าน้อยที่สุด
จนกระทั่งเราพบกุญแจที่มีค่ามากกว่า $k$ เราจะทราบได้ทันที่ว่า
ข้อมูลที่เราต้องการหาไม่อยู่ในพจนานุกรมอย่างแน่นอน เราเขียนฟังก์ชัน {\ct dict\_find}
สำหรับกรณีนี้ได้ดังนี้

---src[cpp]
int dict_find(int keys[], int values[], int size, int x)
{
  for(int i = 0; i != size; ++i) {
    if(keys[i] == x)
      return i;
    if(keys[i] > x)
      return -1;
  }
  return -1; 
}
---

---q *
กรณีใดบ้างที่ฟังก์ชัน {\ct dict\_find}
ทำงานได้เร็วกว่าฟังก์ชันเดียวกันในกรณีที่ข้อมูลไม่มีการเรียงลำดับ
กรณีใดบ้างที่ไม่มีประโยชน์เลย
---

ในฟังก์ชันดังกล่าว เราใช้ประโยชน์จากการที่ข้อมูลเรียงกันในการจบการทำงานเร็วกว่ากำหนด
อย่างไรก็ตามเรามีวิธีการที่จะค้นหาได้เร็วกว่านั้นในแทบจะทุก ๆ กรณี
วิธีที่เราจะใช้นั้นมีลักษณะเดียวกับเทคนิคที่เราใช้ในการเล่นเกมทายเลข

---q เกมทายเลข
เกมทายเลขเป็นเกมระหว่างผู้เล่นสองคน ผู้เล่นคนแรกนึกตัวเลขระหว่าง 1 - 100
จากนั้นผู้เล่นคนที่สองจะทายตัวเลขตัวนั้น
ผู้เล่นคนแรกจะใบ้โดยการบอกว่าตัวเลขที่ทายมีค่าเท่ากับ มากกว่า หรือน้อยกว่าตัวเลขที่นึกไว้
ผู้เล่นคนที่สองจะใช้ข้อมูลดังกล่าวในการเลือกเลขที่จะทายตัวต่อ ๆ ไป

ให้หาวิธีการถามของผู้เล่นคนที่สอง เพื่อให้ได้คำตอบเร็วที่สุดสำหรับทุก ๆ
ตัวเลขที่ผู้เล่นคนแรกนึกไว้

(คำใบ้: เกมดังกล่าวผู้เล่นคนที่สองจะสามารถทายคำตอบโดยทายเลขไม่เกิน 7 ครั้ง)
---

---q *
ทำไมการถามที่ตอบมาจึงสามารถหาคำตอบได้เร็วกว่าการไล่ถามจาก $1,2,3,\ldots$ ? 

คำใบ้: ให้พิจารณาจำนวนคำตอบที่เป็นไปได้ในเวลาหนึ่ง ๆ
---

ถ้าเราไม่มีข้อมูลอะไรเลย นั่นหมายความว่าเราเชื่อว่าผู้เล่นคนแรกอาจจะนึกตัวเลขใด ๆ
ก็ได้ตั้งแต่ 1 - 100 ดังนั้น โดยทั่วไปแล้ว เรามักจะถามเลขตัวแรกเป็น 50 หรือ 49

ตัวเลขนี้มีความน่าสนใจเป็นพิเศษ

---q เลข 50
ทำไมการเลือกทายค่า 50 จึงน่าจะ ``มีประโยชน์'' มากกว่าเริ่มทายด้วย 10 หรือ 5 หรือ 1

คำใบ้: พิจารณาผลที่ได้จากการทาย 50 เมื่อได้รับคำบอกใบ้จากผู้เล่นคนแรก
---

ถ้าเราใช้หลักคิดดังกล่าว ซ้ำไปเรื่อย ๆ กับผลลัพธ์ที่ได้
เราจะทายค่าตรงกลางของขอบเขตที่เป็นไปได้ที่เหลือตลอด จนกว่าจะไม่มีค่าที่เป็นไปได้อีก

---q กรณีแย่สุด
ถ้าใช้วิธีดังกล่าว เราจะต้องทายอย่างมากที่สุดกี่ครั้ง?  อธิบายเหตุผลประกอบ
===
เราจะพิจารณาให้ผู้เล่นคนแรกพยายามเล่นให้ผู้เล่นคนที่สองต้องทายให้มากครั้งที่สุดเท่าที่จะทำได้
เมื่อเขาทายค่า 50 ผู้เล่นคนแรกสามารถตอบว่า ผลลัพธ์ถูกต้อง (จบเลยไม่ทายต่อ),
ค่าที่ทายมีค่ามากกว่าค่าที่สมมติ (ค่าที่เป็นไปได้ต่อไปคือ 1-49), หรือ
ค่าที่ทำนายมีค่าน้อยกว่าค่าที่สมมติ (ค่าที่เป็นไปได้ต่อไปคือ 51 - 100)
สังเกตว่าในกรณีที่ผู้เล่นคนแรกตอบว่าค่าที่ทำนานมีค่าน้อยกว่าค่าที่สมมติ
ทำให้ตัวเลือกที่เป็นไปได้เหลือ 50 ตัวเลือกซึ่งมากที่สุดเท่าที่จะเป็นไปได้แล้ว
ถ้าผู้เล่นคนที่สองเริ่มถามด้วยค่า 50

จะตอบว่าผู้เล่นคนแรกควรตอบอะไร เราต้องตอบคำถามให้ได้ว่า ในรอบต่อไป กรณีที่ 2
(1-49) หรือกรณีที่ 3 (51-100)
จะเป็นกรณีที่แย่ที่สุดสำหรับผู้เล่นคนที่สองที่ต้องทายตัวเลขมากกว่ากัน
สังเกตว่าขอบเขตบนหรือล่างของช่วงคำตอบที่เป็นไปได้นั้นไม่มีผลต่อจำนวนครั้งในการถาม
(จะเป็น 1-49 หรือ 1001 - 1049
วิธีการถามที่ดีที่สุดและวิธีการตอบที่ทำร้ายผู้เล่นคนที่สองมากที่สุด
ก็สามารถนำมาใช้ได้ผลเป็นจำนวนครั้งของการถามที่เท่ากัน) อย่างไรก็ตามสิ่งที่สำคัญกว่า
ก็คือจำนวนคำตอบที่เป็นไปได้
เพราะว่าถ้าช่วงที่เล็กกว่าต้องใช้จำนวนคำถามที่เป็นไปได้มากกว่าช่วงที่ใหญ่กว่า
เราก็สามารถสมมติให้ช่วงที่เล็กมีขนาดเท่ากับช่วงที่ใหญ่กว่า
ได้โดยเพิ่มขอบเขตบนไปให้จำนวนเท่ากัน 

ดังนั้น ทางเลือกที่ผู้เล่นคนแรก จะทำให้ผู้เล่นคนที่สองต้องทายเป็นจำนวนมากครั้งที่สุด
ก็คือเลือกให้คำตอบที่เป็นไปได้หลังจากรู้คำตอบแล้ว มีจำนวนมากที่สุดเท่าที่จะทำได้

ถ้าเราไล่พิจารณาไปเรื่อย ๆ ในรอบต่อไปเราจะเลือกคำตอบที่เป็นไปได้คือ $\lfloor
50/2\rfloor=25$, $\lfloor 25/2\rfloor=12$, $\lfloor 12/2\rfloor=6$,
$\lfloor 6/2\rfloor=3$, $\lfloor 3/2\rfloor=1$, รอบสุดท้าย (รอบที่ 7)
เราถามอีกหนึ่งครั้ง ก็จะเป็นคำตอบที่ถูกต้องแน่นอน
---

หลักการดังกล่วา สามารถประยุกต์ใช้กับการค้นหาข้อมุลในพจนานุกรมได้

---q การหาข้อมูลในพจนานุกรม
ถ้าเราทราบว่ากุญแจที่เก็บในอาร์เรย์จำนวน $n$ ตัวเรียงตามลำดับจากน้อยไปหามาก
จงออกแบบอัลกอริทึมในการค้นข้อมูลที่มีประสิทธิภาพ โดยใช้แนวคิดที่ได้จากเกมทายเลข

(คำใบ้: อาจจะต้องมีการปรับมุมมองเล็กน้อย)
---

เราอาจจะต้องมีการปรับมุมมองเล็กน้อย เพื่อนำแนวคิดจากเกมทายเลขมาใช้ได้ ในกรณีนี้
เรามีกุญแจ {\ct k} ที่ต้องการค้นหาในอาร์เรย์ {\ct keys} เราอยากทราบว่าดัชนี {\ct
i} ใดในอาร์เรย์ ที่ {\ct keys[i]} มีค่าเท่ากับ {\ct k}

สังเกตว่าในกรณีนี้ ถ้ากุญแจอยู่ในอาร์เรย์ คำตอบที่เป็นไปได้คือ $0,1,\ldots,n-1$
เราจะสมมติให้ผู้เล่นคนที่หนึ่งทราบคำตอบนี้ จากนั้นผู้เล่นคนที่สอง (นั่นคืออัลกอริทึมของเรา)
จะเริ่มทาย เมื่อผู้เล่นทายค่า {\ct x} แล้ว
เราสามารถตรวจสอบผลลัพธ์ของการทายและคำใบ้ได้โดยการดูค่าในอาร์เรย์ {\ct keys[x]}

---q *
ค่าของ {\ct keys[x]} มีความหมายเป็นคำใบ้ของการทายเลขได้อย่างไร?
---

จากแนวทางคร่าว ๆ เราจะพัฒนาอัลกอริทึมขึ้นมา
โดยอัลกอริทึมจะทายดัชนีจากขอบเขตของดัชนีที่เป็นไปได้
จากนั้นจะดูค่าในอาร์เรย์เพื่อปรับขอบเขตต่อไป

---q *
ในการดำเนินการตามอัลกอริทึมดังกล่าว จะต้องใช้ตัวแปรใดเก็บข้อมูลการทำงานในแต่ละรอบบ้าง
---

เราจะต้องเก็บขอบเขตของดัชนีที่สามารถเป็นดัชนีที่เราต้องการหา เราจะใช้ตัวแปร $s$
และ $t$ ในการเก็บค่าดัชนีที่น้อยที่สุดและดัชนีที่มากที่สุด ที่สามารถเป็นคำตอบได้ เริ่มต้น
$s=0$ และ $t=n-1$ ในแต่ละรอบ เราจะทายค่าตรงกลางระหว่างสองค่านี้

---q ค่าตรงกลาง
ค่าตรงกลางระหว่าง $s$ และ $t$ ที่เราจะทาย คือค่าใด?
---

เนื่องจากค่าดัชนีต้องเป็นจำนวนเต็มเท่านั้น เราจำต้องทำการปัดค่ากลางที่ได้
ดังนั้นในแต่ละรอบอัลกอริทึมจะทายค่า $\lfloor (s+t)/2 \rfloor$ ให้ตัวแปร $m$
เก็บค่ากลางนี้

---q การดำเนินการหลังการทาย
ถ้าเราต้องการค้นหากุญแจ $x$ เราจะปรับค่าของ $s$ และ $t$ อย่างไร พิจารณากรณีที่ (1)
$keys[m] < x$ และ (2) $keys[m] > x$
---

ในการปรับค่าดังกล่าว
มีรายละเอียดเล็กน้อยซึ่งถ้าเราไม่ระวัง อาจทำให้เกิดปัญหาได้

---q
พิจารณาเงื่อนไขในการปรับค่าดังนี้: (1) ถ้า $keys[m] < x$ ปรับค่า $s\leftarrow m$ และ (2)
ถ้า $keys[m] > x$ ปรับค่า $t\rightarrow m$  

พิจารณาการทำงานของอัลกอริทึมที่ใช้การปรับค่าดังกล่าว มีกรณีใดบ้างที่เงื่อนไขในการปรับค่านี้
ทำให้อัลกอริทึมไม่สามารถหาข้อมูลที่ต้องการเจอได้

(ตำใบ้: พิจารณกรณีที่เหลือขอบเขตของดัชนีที่เป็นไปได้ขนาดเล็ก ๆ)
---

---q *
เราจะแก้ปัญหาดังกล่าวได้อย่างไร?
---

เราจะปรับค่าอย่างระมัดระวังขึ้น นั่นคือในกรณี (1) เราจะให้ $s\leftarrow m+1$
และในกรณีที่ (2) เราจะให้ $t\leftarrow m-1$
การปรับค่าดังกล่าวมีผลเกี่ยวข้องกับอีกกรณีหนึ่งซึ่งไม่เกิดขึ้นในเกมทายเลขที่เราต้องพิจารณา
นั่นคือกรณีที่ค้นหาข้อมูลไม่เจอ

---q *
เราจะทราบได้อย่างไรว่ากุญแจที่เราค้นหาไม่อยู่ในอาร์เรย์

(คำใบ้: ดูจากขอบเขตที่เป็นไปได้)
---

เรานำแนวทางดังกล่าวมาเขียนเป็นอัลกอริทึมได้ดังอัลกอริทึม~\ref{algo:analysis-bin-search}

\begin{figure}
---algt[*,algo:analysis-bin-search] ค้นหากุญแจ $k$ จากอาร์เรย์ $keys$ ขนาด $n$ ที่ข้อมูลเรียงลำดับจากน้อยไปมาก
* $s\leftarrow 0$, $t\leftarrow n-1$
* WHILE $s\leq t$ DO
** $m\leftarrow \lfloor (s+t)/2\rfloor$
** IF $keys[m] = k$ THEN
*** RETURN $m$ and EXIT
** IF $keys[m] < k$ THEN
*** $s\leftarrow m+1$
** IF $keys[m] > k$ THEN
*** $t\leftarrow m-1$
* RETURN $-1$ and EXIT   // not found
---
\end{figure}

เราจะวิเคราะห์เวลาการทำงานของอัลกอริทึมดังกล่าว โดยทั่วไปแล้ว
ในการวิเคราะห์เวลาการทำงานของอัลกอริทึมใด
เราจำเป็นจะต้องให้เหตุผลว่าอัลกอริทึมนั้นเมื่อทำงานแล้วก่อให้เกิด ``ความก้าวหน้า''
และใช้ความก้าวหน้านั้นในการให้เหตุผลต่อไป

เราจะลองใช้เหตุผลเกี่ยวกับความก้าวหน้าในการพิจารณาอัลกอริทึมการค้นหาแบบตามลำดับ
ในวิธีอิมพลีเมนท์พจนานุกรมด้วยอาร์เรย์แบบแรกเพื่อแสดงเป็นตัวอย่าง

---q ความก้าวหน้าของการค้นหาแบบตามลำดับ
การค้นหาตามโปรแกรมที่~\ref{code:analysis-dict-find} เป็นการค้นหาแบบตามลำดับ
ให้พิจารณาโปรแกรมดังกล่าว และลองหาว่าเราสามารถใช้สถานะอะไรของโปรแกรม (เช่น
ตัวแปรหรือค่าอื่น ๆ) เพื่อบอกว่าโปรแกรมมีความก้าวหน้าในการทำงานได้บ้าง?
---

ในการค้นหาข้อมูลจากอาร์เรย์ที่เก็บกุญแจใด ๆ ก็ตาม ถ้าเราไล่พิจารณาตามลำดับจากกุญแจแรก
ไปจนถึงกุญแจสุดท้ายในอาร์เรย์ ทุก ๆ ครั้งที่เราพิจารณากุญแจหนึ่ง มีผลลัพธ์ที่เป็นไปได้สองแบบ
คือ เราพบกุญแจที่เราต้องการหา หรือถ้าเราไม่พบ เราจะสามารถ ``ทิ้ง''
กุญแจที่เราพิจารณาอยู่ไปได้ (เนื่องจากไม่ใช่เป้าหมายที่เราต้องการแล้ว) ในกรณีนี้
ความก้าวหน้าของงานที่เราทำก็คือ จำนวนกุญแจที่เราสามารถทิ้งไปได้ ดังนั้นถ้าเรามีกุญแจทั้งสิ้น
$n$ กุญแจ และในแต่ละรอบของการทำงาน เราใช้เวลา $O(1)$
เพื่อจะทิ้งกุญแจที่ไม่ถูกต้องได้ 1 อัน ดังนั้นในกรณีที่แย่ที่สุด ก็คือเราจะต้องใช้เวลา $O(n)$

---q ความก้าวหน้าของการค้นหาที่ดีขึ้น
ถ้าเราใช้จำนวนกุญแจที่เราจะต้องพิจารณาแทนปริมาณงานทั้งหมด (เริ่มต้นที่ $n$ หน่วย)
ในแต่ละรอบของอัลกอริทึม~\ref{algo:analysis-bin-search}
เราจัดการกับงานดังกล่าวไปได้เท่าใด?

(คำใบ้: พิจาณารอบที่ 1, รอบที่ 2, แล้วค่อยพยายามพิจารณาในรอบใด ๆ)
---

เราสามารถพิสูจน์ได้ว่า ในทุก ๆ รอบการทำงานของวนรอบ WHILE
จำนวนดัชนีของกุญแจที่เป็นไปได้จะมีค่าลดลงอย่างน้อย 2 เท่า
สังเกตว่าเมื่อเริ่มต้นเข้าทำงานในวนรอบ จำนวนกุญแจที่เป็นไปได้คือ $t - s + 1$
ถ้าเราพบคำตอบ อัลกอริทึมจะจบการทำงาน ถ้าไม่เช่นนั้น มีสองกรณีที่เราต้องพิจารณา
\begin{itemize}
\item ถ้าเราผ่านเงื่อนไขในบรรทัดที่ 6 เข้าไปทำงานในบรรทัดที่ 7 เราจะได้ว่า
  $s\leftarrow m+1$ ดังนั้นจำนวนกุญแจใหม่คือ
  \begin{eqnarray*}
    t - (\lfloor (s+t)/2\rfloor + 1) + 1 
    &=& \lceil t - s/2 - t/2 \rceil\\
    &=& \lceil t/2 - s/2\rceil\\
    &\leq& t/2 - s/2 + 1/2 = (t-s+1)/2
  \end{eqnarray*}
\item ในอีกกรณีหนึ่ง ถ้าเงื่อนไขบรรทัดที่ 8 เป็นจริง แล้วเราเข้าไปทำงานในบรรทัดที่ 9
  ในส่วนนี้สามารถพิสูจน์ได้ด้วยวิธีที่คล้ายกัน
\end{itemize}

---q ก้าวหน้าอย่างน้อย...
จงพิสูจน์ว่า ถ้าโปรแกรมทำงานเข้าไปในคำสั่งบรรทัดที่ 9
จำนวนกุญแจที่จะต้องพิจารณาจะมีค่าลดลงอย่างน้อย 2 เท่า
---

เราจะวิเคราะห์เวลาการทำงาน \ สังเกตว่าในแต่ละรอบการทำงานของวนรอบ WHILE
ใช้เวลา $O(1)$ \ \ เมื่อทำงานเสร็จในแต่ละรอบ ถ้าโปรแกรมไม่หยุดการทำงาน
จากการพิจารณาข้างต้น เราจะพบว่าจำนวนกุญแจที่เหลือต้องพิจารณาจะลดลงอย่างน้อย 2 เท่า
นั่นคือเราทราบว่าหลังการทำงานรอบแรก จะเหลือกุญแจไม่เกิน $n/2$
หลังรอบที่สองจะเหลือกุญแจไม่เกิน $n/2/2 = n/4$ และหลังรอบที่ $x$ จะเหลือกุญแจไม่เกิน
$n/2^x$ อัน

เราทราบว่าโปรแกรมจะหยุดทำงานแน่นอนถ้าไม่มีกุญแจให้พิจารณาอีก
เนื่องจากเมื่อเริ่มต้นเรามีกุญแจต้องพิจารณาจำนวน $n$ กุญแจ ถ้าให้ $x$
แทนจำนวนรอบการทำงานของอัลกอริทึมที่ไม่ใช่รอบสุดท้าย เราจะได้ว่า $\frac{n}{2^x} >
1$ เมื่อแก้สมการเราจะได้ว่า $x < \log_2 n$ นั่นคือโปรแกรมจะทำงานไม่เกิน $\log n$
รอบ\footnote{ในหนังสือเล่มนี้ ถ้าไม่ระบุฐาน เราจะถือว่าเราใช้ลอการิทึมฐาน 2 เสมอ}

ดังนั้นเวลาการทำงานของการค้นหาดังกล่าวคือ $O(\log n)$
การค้นหาโดยการเลือกค่าที่แบ่งข้อมูลออกเป็นสองส่วนแบบนี้เป็นเทคนิคสำคัญในการออกแบบอัลกอริทึม
การค้นหาแบบนี้มีชื่อว่า {\em การค้นหาแบบทวิภาค} ({\em binary searching})

เราสรุปเวลาของกระบวนการต่างเมื่ออิมพลีเมนท์พจนานุกรมด้วยอาร์เรย์ทั้งสองแบบเป็นตารางในรูป~\ref{fig:array-running-time-dict-by-array}

\begin{figure}
\begin{center}
\begin{tabular}{|l|c|c|}\hline
กระบวนการ & เก็บตามลำดับการใส่ข้อมูล & เก็บเรียงตามกุญแจ \\
\hline
IsEmpty & $O(1)$ & $O(1)$ \\
Insert & $O(1)$ & $O(n)$ \\
Find & $O(n)$ & $O(n)$ หรือ $O(\log n)$ ถ้าค้นหาแบบทวิภาค \\
Delete & $O(n)$ & $O(n)$ \\
\hline
\end{tabular}
\end{center}
\caption{เวลาการทำงานของกระบวนการต่าง ๆ ของพจนานุกรม ที่พัฒนาด้วยอาร์เรย์ทั้งสองแบบ โดยที่ $n$ แทนจำนวนข้อมูลในพจนานุกรม}
\label{fig:array-running-time-dict-by-array}
\end{figure}

---q *
จงอิมพลีเมนท์ฟังก์ชัน {\ct dict\_find} 
ที่มีประสิทธิภาพมากขึ้นเมื่อกุญแจในอาร์เรย์ {\ct keys} เรียงตามลำดับจากน้อยไปหามาก
---

\subsubsection{ความแตกต่างระหว่าง $O(n)$ และ $O(\log n)$}

TODO: เขียนส่วนนี้

\subsubsection{ควรจะเลือกใช้วิธีการอิมพลีเมนท์แบบใด?}

TODO: เขียนส่วนนี้
